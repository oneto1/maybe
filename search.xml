<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LVS学习</title>
    <url>/2020/05/10/LVS%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>记录的非常详细,值得学习–&gt; <a href="http://superproxy.github.io/docs/lvs/index.html" target="_blank" rel="noopener">LVS介绍</a></p>
]]></content>
      <tags>
        <tag>LVS</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下文件I/O学习</title>
    <url>/2019/09/22/UNIX%E4%B8%8B%E6%96%87%E4%BB%B6I-O%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="/images/20190922=0.png" alt></p>
<p>GUN操作系统也称GUN/linux,简称linux,其内核是linux内核</p>
<h2 id="c-标准"><a href="#c-标准" class="headerlink" title="c 标准"></a>c 标准</h2><ul>
<li>ISO C </li>
<li>IEEE POSIX </li>
<li>Single UNIX Seecification(SUS)  [posix的一个超集]</li>
</ul>
<h2 id="UNIX标准的实现"><a href="#UNIX标准的实现" class="headerlink" title="UNIX标准的实现"></a>UNIX标准的实现</h2><p>标准是接口的规范，要由厂商采用转变为具体实现</p>
<ul>
<li>SVR</li>
<li>BSD</li>
<li>Linux</li>
<li>Mac os</li>
</ul>
<p><img src="/images/20190922=1.png" alt></p>
<ul>
<li>SVR4 为(AT&amp;T)UNIX Systerm V Release 4.0 (被称为UNIX的商业版)</li>
<li>FreeBSD 基于4.4BSD-Lite </li>
</ul>
<hr>
<h1 id="文件I-O与目录"><a href="#文件I-O与目录" class="headerlink" title="文件I/O与目录"></a>文件I/O与目录</h1><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符是一个非负常数,当打开或新建一个文件时，内核会向进程返回一个文件描述符</p>
<p>直接使用的常数叫做幻数，如</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">stdin</td>
<td style="text-align:center">stdout</td>
<td style="text-align:center">stderr</td>
</tr>
</tbody>
</table>
<h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">open</span>(<span class="keyword">const</span> <span class="keyword">char</span> *__file, <span class="keyword">int</span> __oflag, ...)</span><br><span class="line"></span><br><span class="line">成功返回文件描述符，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>常用flag<br>  O_RDONLY只读模式<br>  O_WRONLY只写模式<br>  O_RDWR读写模式<br>  O_APPEND每次写操作都写入文件的末尾<br>  O_CREAT如果指定文件不存在，则创建这个文件<br>  O_EXCL如果要创建的文件已存在，则返回-1，并且修改errno的值<br>  O_TRUNC如果文件存在，以只写/读写方式打开，并清空文件全部内容(即将其长度截短为0)</p>
</li>
<li><p>多个flag可用逻辑或连接</p>
</li>
<li>open返回的文件描述符一定是最小的未被使用的描述符</li>
</ul>
<h3 id="craet"><a href="#craet" class="headerlink" title="craet()"></a>craet()</h3><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">int creat(const char *__file, mode_t __mode)</span><br><span class="line"></span><br><span class="line">成功返回!!只写!!的文件描述符，失败返回-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>等效于open(path,O_WRONLY|O_CREAT|O_TRUNK,node)</li>
</ul>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">close</span>(<span class="keyword">int</span> fd)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当进程关闭时，内核会自动关闭打开的文件，即不需要调用close()</li>
</ul>
<h3 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __n)</span><br><span class="line"></span><br><span class="line">成功返回写入的字节数,失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> __fd, <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __nbytes)</span><br><span class="line"></span><br><span class="line">成功返回读到的字节数，到文件尾返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">6</span>]=<span class="string">"123456"</span>;</span><br><span class="line">    <span class="keyword">void</span> *Rbuf=<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> pi;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建文件并写入字符串</span></span><br><span class="line">    <span class="comment">//creat()返回的文件描述符是只写的     </span></span><br><span class="line">    <span class="keyword">if</span>(write(creat(<span class="string">"test"</span>,S_IRWXU),buf,<span class="number">6</span>)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write error!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write success!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得文件描述符</span></span><br><span class="line">    pi=open(<span class="string">"test"</span>,O_RDONLY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读并打印</span></span><br><span class="line">    <span class="keyword">if</span>(read(pi,Rbuf,<span class="keyword">sizeof</span>(buf))!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read : %s"</span>,Rbuf);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read error!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; write success!</span><br><span class="line">  read : <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h3><p>通常文件读写从当前文件偏移量开始，并使偏移量增加所读写量<br>默认情况下偏移量被设为0，除了O_APPEND追加模式<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">__off_t</span> lseek(int <span class="variable">__fd</span>, <span class="variable">__off_t</span> <span class="variable">__offset</span>, int <span class="variable">__whence</span>)</span><br><span class="line"></span><br><span class="line">成功返回新的偏移量,失败返回-<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">whence</th>
<th style="text-align:center">SEEK_SET</th>
<th style="text-align:center">SEEK_CUR</th>
<th style="text-align:center">SEEK_END</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">距文件开始加上offset</td>
<td style="text-align:center">当前值加上</td>
<td style="text-align:center">文件末尾加上</td>
</tr>
</tbody>
</table>
<ul>
<li>lseek只修改偏移量，不进行I/O操作</li>
</ul>
<h3 id="内核打开文件的数据结构"><a href="#内核打开文件的数据结构" class="headerlink" title="内核打开文件的数据结构"></a>内核打开文件的数据结构</h3><p><img src="/images/20190922=2.png" alt></p>
<ol>
<li>进程表项<ul>
<li>fd标志即文件描述符的标志</li>
<li>文件指针</li>
</ul>
</li>
<li>文件表项<ul>
<li>文件状态标志 读写追加同步非阻塞 ( 详见open() flag))</li>
<li>文件偏移量</li>
<li>v节点指针</li>
</ul>
</li>
<li>v节点项<ul>
<li>v节点信息</li>
<li>v节点数据</li>
<li>i节点信息</li>
<li>当前文件长度</li>
<li>v节点指针</li>
</ul>
</li>
</ol>
<h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup() dup2()"></a>dup() dup2()</h3><p>用于复制文件描述符<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> dup(<span class="built_in">int</span> __fd)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> dup2(<span class="built_in">int</span> __fd, <span class="built_in">int</span> __fd2)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>文件描述符0、1、2默认由shell打开，dup(1)得到的是立即可用的最小描述符即3</li>
<li>dup2() 中fd2用于指定新的文件描述符,若fd等于fd2，则返回fd2</li>
<li>dup2()是一个原子操作，不会出现任务进行中进程切换导致前后状态不一致</li>
</ul>
<h3 id="sync"><a href="#sync" class="headerlink" title="sync()"></a>sync()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> __fd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatesync</span><span class="params">(<span class="keyword">int</span> __fd)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>sync()将修改过的块缓存区排入写队列，然后返回，不等待实际磁盘I/O结束</li>
<li>fsync()指定文件作用，等待实际磁盘I/O结束才返回</li>
<li>fdatesync() 与fsync()类似，只更新数据，不更新属性</li>
</ul>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>假设test.c 是有错误的</p>
<table>
<thead>
<tr>
<th style="text-align:center">gcc test.c 2&gt;&amp;1 &gt;outlfile</th>
<th style="text-align:center">gcc test.c &gt;outlfile 2&gt;&amp;1 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">stdout有输出，而outfile没有</td>
<td style="text-align:center">outfile有错误输出，而stdout没有</td>
</tr>
</tbody>
</table>
<ul>
<li>shell从左到右执行</li>
<li>2 指向 1，于是stdout有了输出，然后 1 指向 outfile ，这时的1由于编译失败是没有的，所以outfile为空</li>
<li>gcc test.c &gt;outlfile 2&gt;&amp;1  可简写为<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gcc test<span class="selector-class">.c</span> &amp;&gt;outlfile    </span><br><span class="line"></span><br><span class="line">gcc test<span class="selector-class">.c</span> &gt;&amp;outlfile</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下信号与进程关系学习</title>
    <url>/2019/10/06/UNIX%E4%B8%8B%E4%BF%A1%E5%8F%B7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h1><h3 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h3><p>在早期的UNIX系统中，是采用硬链接(哑终端)即本地连接或远程调制解调器登录的。</p>
<p>而如今，终端又有了基于字符的终端、图形终端、仿真基于字符终端的图形终端</p>
<p><img src="/images/20191007=0.png" alt><br><img src="/images/20191007=1.png" alt></p>
<p>为了使同一个软件既能处理终端登录，又能处理网络登录，系统使用了一种称为<strong>伪终端</strong>的软件驱动程序，它仿真串行终端的运行行为，并将终端操作映射为网络操作</p>
<p><img src="/images/20191007=2.png" alt></p>
<ul>
<li>inetd为一个因特网服务守护进程，它等待大多数网络连接</li>
</ul>
<p><img src="/images/20191007=3.png" alt></p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组是一个或多个进程的集合。通常，它们是同一个作业里结合起来的，同一进程组中的的进程接受来自同一终端的各种信号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> getpgrp()</span><br><span class="line"></span><br><span class="line">返回进程的进程组id</span><br></pre></td></tr></table></figure>
<ul>
<li>每一个进程组都有一个组长进程，组长进程id等于进程组id</li>
<li>进程组的是否终止与其组长进程的终止无关，只要有一个进程存在即进程组存在</li>
<li>从进程组创建开始到最后一个进程结束的时间区间被称为其生命周期</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line">int setpgid(<span class="variable">__pid_t</span> <span class="variable">__pid</span>, <span class="variable">__pid_t</span> <span class="variable">__pgid</span>)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将pid进程的进程组id设为pgid</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">pid = pgid</th>
<th style="text-align:center">则由pid指定的进程称为进程组组长</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pid = 0</td>
<td style="text-align:center">则使用调用者id</td>
</tr>
<tr>
<td style="text-align:center">pgid = 0</td>
<td style="text-align:center">则由pid指定id作为进程组id</td>
</tr>
</tbody>
</table>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话是一个或多个进程组的集合，通常是由shell是管道将其编为一组<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> setsid(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">成功返回进程组id，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>若调用该函数的进程是一个进程组组长，则报错</p>
</li>
<li><p>若不是进程组组长，则会创建一个新会话</p>
<ol>
<li>该进程成为为该会话的会话首进程，此时是唯一的一个进程</li>
<li>该进程成为新进程组组长，新进程组id等于调用该函数进程id</li>
<li>该进程没有控制终端，若之前有会被切断</li>
</ol>
</li>
</ul>
<h3 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h3><ul>
<li>一个会话可以有一个控制终端。通常是终端设备或伪终端设备</li>
<li>建立和控制终端连接的会话首进程被称为控制进程</li>
<li>会话中的进程组可被分为前台和后台进程组</li>
<li>终端输入和产生的信号被送至前台进程组</li>
<li>终端接口检测到调制解调或网络断开，则将挂断信号发往控制进程(会话首进程))</li>
</ul>
<p><img src="/images/20191007=4.png" alt></p>
<h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p>作业(进程组)控制它允许在一个终端启动多个作业，它控制那些哪些作业可以访问终端以及那些作<br>业可以在后台运行</p>
<p>作业控制需要以下支持:</p>
<ol>
<li>shell</li>
<li>终端驱动</li>
<li>内核</li>
</ol>
<p><img src="/images/20191007=5.png" alt></p>
<p>(SIGINT,SIGQUIT,SIGTST)分别对应字符c-c、c-/、c-d，具体由终端驱动程序决定</p>
<p>shell任务调度命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br><span class="line">将一个在后台暂停的命令，变成继续执行</span><br><span class="line"></span><br><span class="line"><span class="built_in">fg</span></span><br><span class="line">将后台中的命令调至前台继续运行</span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line">查看当前有多少在后台运行的命令</span><br><span class="line"></span><br><span class="line">ctrl + z</span><br><span class="line">可以将一个正在前台执行的命令放到后台，并且暂停</span><br><span class="line"></span><br><span class="line">nohup 命令</span><br><span class="line"></span><br><span class="line">用途：不挂断地运行命令。</span><br><span class="line"></span><br><span class="line">语法：nohup Command [ Arg … ] [　&amp; ]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号是软件中断</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7" target="_blank" rel="noopener">中断</a>是用以提高计算机工作效率、增强计算机功能的一项重要技术。最初引入硬件中断，只是出于性能上的考量。如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待（Busy waiting），反复轮询该设备是否完成了动作并返回结果。这就造成了大量处理器周期被浪费。引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价。后来被用于CPU外部与内部紧急事件的处理、机器故障的处理、时间控制等多个方面，并产生通过软件方式进入中断处理（软中断）的概念。</p>
</blockquote>
<p>对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个阶段：</p>
<ol>
<li><p>信号诞生</p>
</li>
<li><p>信号在进程中注册</p>
</li>
<li><p>信号的执行和注销</p>
</li>
</ol>
<h3 id="关于信号"><a href="#关于信号" class="headerlink" title="关于信号"></a>关于信号</h3><p>每一个信号都有名字，以SIG开头，在&lt;<strong>signal.h</strong>&gt;中，信号被定义为正整数常量(信号编号)</p>
<p>信息编号为0的被称为空信号</p>
<p>主要有以下几种来源：</p>
<ol>
<li><p>程序错误：除零，非法内存访问…</p>
</li>
<li><p>外部信号：终端Ctrl-C产生SGINT信号，定时器到期产生SIGALRM…</p>
</li>
<li><p>显式请求：kill函数允许进程发送任何信号给其他进程或进程组。</p>
</li>
</ol>
<p>一般情况下一个进程接受到信号后，会有如下的行为：</p>
<ol>
<li><p>忽略信号：大部分信号可被忽略，除SIGSTOP和SIGKILL信号外（这是超级用户杀掉或停掉任意进程的手段）。</p>
</li>
<li><p>捕获信号：注册信号处理函数，它对产生的特定信号做处理。</p>
</li>
<li><p>让信号默认动作起作用：unix内核定义的默认动作，有5种情况：<br>a) 流产abort：终止进程并产生core文件。</p>
<p>b) 终止stop：终止进程但不生成core文件。</p>
<p>c) 忽略：忽略信号。</p>
<p>d) 挂起suspend：挂起进程。</p>
<p>e) 继续continue：若进程是挂起的，则resume进程，否则忽略此信号。</p>
</li>
</ol>
<ul>
<li>目前Linux支持64种信号。信号分为非实时信号(不可靠信号)和实时信号（可靠信号）两种类型，对应于 Linux 的信号值为 1-31 和 34-64。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"signal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">__sighandler_t</span> signal(int <span class="variable">__sig</span>, <span class="variable">__sighandler_t</span> <span class="variable">__handler</span>)</span><br><span class="line"></span><br><span class="line">成功返回之前的信号处理配置，失败返回SIG_ERR</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数为信号编号，第二个参数为信号处理函数指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">__sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="comment">/* 为一个参数为int名字为__sighandler_t的指针函数 且返回值为void */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SIG_ERR	 ((__sighandler_t) -1)	<span class="comment">/* Error return.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SIG_DFL	 ((__sighandler_t)  0)	<span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SIG_IGN	 ((__sighandler_t)  1)	<span class="comment">/* Ignore signal.  */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>当一个程序启动时，所有的信号状态都是默认或忽略</p>
</li>
<li><p>当一个进程调用fork(),子进程默认继承父进程处理方式</p>
</li>
</ul>
<h3 id="系统调用的中断"><a href="#系统调用的中断" class="headerlink" title="系统调用的中断"></a>系统调用的中断</h3><p>捕捉到信号的时候，中断的是系统调用而不是函数(因为函数调用的是系统调用)</p>
<p>系统调用分成两类：低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的一类系统调用：</p>
<ol>
<li>在读某些类型的文件（管道，终端设备以及网络设备）时，如果数据并不存在则可能会使调用者永远阻塞。</li>
<li>在写这些类型的文件时，如果不能立即接受这些数据，则会使调用者永远阻塞。</li>
<li>打开某些类型的文件，在某些条件发生之前也可能会使调用者阻塞（例如，打开终端设备，它要等待直到所连接的调制解调器应答了电话）</li>
<li>pause函数和wait函数</li>
<li>某些ioctl函数</li>
<li>某些进程间通信函数。</li>
</ol>
<p>与被中断的系统调用相关的问题是必须显式地处理出错返回。典型的代码如下：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n=<span class="built_in">read</span>(fd,buf,BUFFSIZE))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可靠信号术语及语义"><a href="#可靠信号术语及语义" class="headerlink" title="可靠信号术语及语义"></a>可靠信号术语及语义</h3><p>当一个信号产生时，内核会在进程表中以某种方式设置一个标志，当对信号采取了这种动作时，我们说向进程递送了一个信号。</p>
<p>在信号产生（generation）和递送（delivery）之间的时间间隔，称信号是未决的（pending）。</p>
<p>进程可以选用信号递送阻塞。如果为进程产生了一个选择为阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程（a）对此信号解除了阻塞，或者（b）将对此信号的动作更改为忽略。内核在递送一个原来被阻塞（现在解除了阻塞）的信号给进程时（而不是在产生该信号时），才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用sigpending函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>在进程结束对某个信号的堵塞前，系统递送这种信号多次，可称这些信号进行了排队</p>
<p>每个进程都有一个信号屏蔽字（signal mask），它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则它当前是被阻塞的。进程可以调用sigprocmask来检测和更改其当前信号屏蔽字。</p>
<h3 id="kill-raise"><a href="#kill-raise" class="headerlink" title="kill()/raise()"></a>kill()/raise()</h3><p>kill将信号发给进程或进程组，raise可将信号发给自己</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="string">"signal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> kill(pit_t pit,<span class="built_in">int</span> __sig)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> raise(<span class="built_in">int</span> __sig)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">pid</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pid &gt; 0</td>
<td style="text-align:center">将信号发给pid进程</td>
</tr>
<tr>
<td style="text-align:center">pid ==0</td>
<td style="text-align:center">将信号发给同一个进程组的进程(前提是该进程有权限发送信号给进程组)</td>
</tr>
<tr>
<td style="text-align:center">pid &lt;0</td>
<td style="text-align:center">将信号发给pid的绝对值的进程和所有有权限发送的进程</td>
</tr>
<tr>
<td style="text-align:center">pid ==-1</td>
<td style="text-align:center">将信号发给所有有权限发送的进程</td>
</tr>
</tbody>
</table>
<p><img src="/images/20191007=6.png" alt></p>
<p>权限的基本判别方法为:</p>
<ul>
<li>发送者有效id或实际id等于接受者有效id或实际id</li>
</ul>
<h3 id="alarm-、pause"><a href="#alarm-、pause" class="headerlink" title="alarm()、pause()"></a>alarm()、pause()</h3><p>alarm()可设置一个定时器，当定时器超时时会产生一个SIGALRM信号，但不捕捉或忽略它时，默认结束该进程<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alarm(<span class="keyword">unsigned</span> <span class="keyword">int</span> __seconds)</span><br><span class="line"></span><br><span class="line">返回<span class="number">0</span>或以前设置的时间</span><br></pre></td></tr></table></figure></p>
<ul>
<li>当信号产生时，由于进程调度的延迟，进程并不能及时得到控制及处理信号</li>
<li>每个进程只能有一个闹钟时间。若之前有一个时间，则返回之前时间的余值，且用新值代替旧值</li>
<li>若之前注册了一个时间且没有超时，而调用时seconds为0，则取消以前的闹钟时间，余值作为返回值</li>
</ul>
<p>使调用进程挂起直至捕捉到一个信号<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pause(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">返回值为<span class="number">-1</span>，errno为EINTR</span><br></pre></td></tr></table></figure></p>
<ul>
<li>当执行完信号处理函数才返回</li>
</ul>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">无返回值</span><br></pre></td></tr></table></figure>
<ul>
<li>向进程发送SIGABORT信号，默认情况下进程会异常退出，当然可定义自己的信号处理函数。即使SIGABORT被进程设置为阻塞信号，调用abort()后，SIGABORT仍然能被进程接收。</li>
</ul>
<h3 id="sigqueue（）"><a href="#sigqueue（）" class="headerlink" title="sigqueue（）"></a>sigqueue（）</h3><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">int sigqueue(pid_t pid, int sig, const <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">val</span>)</span></span><br><span class="line"></span><br><span class="line">调用成功返回 <span class="number">0</span>；否则，返回 -<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sigqueue()是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数sigaction()配合使用。</p>
</li>
<li><p>sigqueue的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line"></span><br><span class="line">               int  sival_int;</span><br><span class="line"></span><br><span class="line">               void *sival_ptr;</span><br><span class="line"></span><br><span class="line">&#125;sigval_t;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sigqueue()比kill()传递了更多的附加信息，但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。如果signo=0，将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。</p>
</li>
</ul>
<ul>
<li>在调用sigqueue时，sigval_t指定的信息会拷贝到对应sig 注册的3参数信号处理函数的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。由于sigqueue系统调用支持发送带参数信号，所以比kill()系统调用的功能要灵活和强大得多。</li>
</ul>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h3><p><a href="https://blog.csdn.net/return_cc/article/details/78845346" target="_blank" rel="noopener">完善版signal()</a></p>
<p>新可靠信号<br><img src="/images/20191007=7.png" alt></p>
<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>信号集被定义为一种数据类型，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> sig[_NSIG_WORDS]；</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">sigset_t</span></span><br></pre></td></tr></table></figure></p>
<p>信号集用来描述信号的集合，每个信号占用一位。Linux所支持的所有信号可以全部或部分的出现在信号集中</p>
<h3 id="linux下的信号应用常见三步法"><a href="#linux下的信号应用常见三步法" class="headerlink" title="linux下的信号应用常见三步法"></a>linux下的信号应用常见三步法</h3><ol>
<li><p>安装信号（推荐使用sigaction()） [signal()]</p>
</li>
<li><p>实现三参数信号处理函数，handler(int signal,struct siginfo <em>info, void </em>)；</p>
</li>
<li><p>发送信号，推荐使用sigqueue()   [kill()\raise()]</p>
</li>
</ol>
<p>实际上，对有些信号来说，只要安装信号就足够了（信号处理方式采用缺省或忽略）。其他可能要做的无非是与信号集相关的几种操作。</p>
<hr>
<p><a href="http://m.elecfans.com/article/579913.html" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/return_cc/article/details/78845346" target="_blank" rel="noopener">完善版signal</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下文件系统学习</title>
    <url>/2019/11/01/UNIX%E4%B8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p><img src="/images/20191103=0.png" alt><br><a href="http://makelinux.net/kernel_map/" target="_blank" rel="noopener">原图地址</a></p>
<p>在UNIX中，文件是一个数据容器的抽象概念，文件系统则允许用户来组织、管理和使用不同的文件</p>
<p><img src="/images/20191103=1.png" alt></p>
<p>该图较为直观的展现了文件系统与内核其他部分的关系</p>
<h1 id="文件的用户接口"><a href="#文件的用户接口" class="headerlink" title="文件的用户接口"></a>文件的用户接口</h1><p>内核允许用户进程通过一个定义良好的、过程化的接口来与文件系统交互。</p>
<p>这些接口封装了文件系统的用户视图并指定所有的相关系统调用的行为与场景。</p>
<p>这些接口向用户暴露出几个抽象概念:</p>
<ul>
<li>文件</li>
<li>目录</li>
<li>文件描述符</li>
<li>文件系统</li>
</ul>
<hr>
<h1 id="vnode-vfs"><a href="#vnode-vfs" class="headerlink" title="vnode/vfs"></a>vnode/vfs</h1><p>传统的UNIX内核中的文件系统是单一组织的。它仅支持一种文件系统。</p>
<p>为了同时支持多种文件系统而不用修改内核，这时文件系统框架出现了，而最流行的是 <strong>Vnode/Vfs</strong>虚拟文件系统，它被集成为内核的一个功能</p>
<p>下面将对字符设备进行<strong>read</strong>系统调用来说明：</p>
<ol>
<li>使用文件描述符获得打开文件对象</li>
<li>检查是否被打开用于读取</li>
<li>从这个项中获得指向内存inode节点的指针</li>
<li>锁定该inode以便串行化访问该文件</li>
<li>检查inode文件属性，发现该文件是一个字符设备</li>
<li>使用存储在inode中的主设备号来定位字符设备表并得到针对该设备的cdexsw项。该项指向针对该设备的特定操作函数</li>
<li>从sdevsw结构中获得d_raed函数指针</li>
<li>调用该函数来执行操作</li>
<li>解锁inode并返回</li>
</ol>
<p>从中可以发现大多数操作与设备无关：</p>
<ul>
<li>1-4、9步与文件类型无关</li>
<li>5-7步是执行了内核与设备之间的接口</li>
<li>第8步才是对设备进行操作</li>
</ul>
<p>这种设计方式将文件系统代码分为文件系统相关和文件系统不相关两部分<br>两部分之间的接口则为一组通用函数，文件系统无关部分调用这些函数来执行不同的文件操作和访问，相关部分代码则与文件系统类型相关，提供对每种函数的实现</p>
<p><strong>vnode/vfs接口使用了面向对象的编程概念设计</strong></p>
<ul>
<li>一般而言，我们用基类来简单表示一个抽象类或定义一个接口，用派生类来实现其成员函数的实现。由此文件类可以创建一个creat()的成员函数，但是当用户调用这个函数来处理任何文件时，将基于文件类型来调用不同的函数。 而实际上，没有通用的可以创建任何文件的通用函数实现，这样的函数叫虚函数</li>
<li>由于基类针对该函数没有具体的实现，因此该基类不能被实例化。 它仅可以被提供该虚函数特定实现的派生子类使用，但它可以被子类重写该函数，就叫面向对象的重载</li>
<li>所有对象是派生类的一个实例，但用户可以使用一个指向基类的指针来操作对象，不需要知道该对象属于哪个子类。当对象调用一个虚函数时，实现将基于对象的实际类型自动决定调用哪个具体的函数</li>
</ul>
<p>vnode(virtual node)抽象表示在UNIX内核中一个的文件，vfs(virtual file system)抽象表示为一个文件系统，都被认为是抽象基类，由这两个基类派生出针对不同文件系统类型实现的子类，如<br>s5fs、ufs、NFS、FAT等等</p>
<p>在vnode基类的数据域均为文件系统类型无关的属性，而其成员函数分为两类：</p>
<ol>
<li>定义了文件系统相关接口的虚函数集合，每种不同的文件系统必须给出相应的函数实现</li>
<li>另一类是可以被其他内核子系统用来操作文件的高层工具函数，这些函数可以调用文件系统相关的函数来执行底层任务</li>
</ol>
<p><img src="/images/20191103=2.png" alt><br><img src="/images/20190922=2.png" alt></p>
<p>vnode基类由两个数据域来实现子类化。</p>
<ul>
<li>第一个是v_data,它是一个指针，指向保存着特定文件系统的vnode数据的私有数据结构，对于s5fs，这个结构是inode，对于nfs，它是rnode。 因为这个结构直接通过v_data访问，所以它对vnode基类不透明，其字段仅仅对特定文件系统的内部函数可见。</li>
<li>另一个数据域为v_op,其指向一个vnoideops结构，该结构包含一个vnode虚拟接口的函数实现集合</li>
</ul>
<blockquote>
<p>v-data和v_op域在vnode被初始化时赋值，一般是在open或create系统调用过程中。当文件系统无关的代码调用任意一个vnode的虚函数时，把内核解除v_op指针的引用并调用对应文件系统的实现函数。比如VOP_CLOSE操作允许调用者关闭域vnode关联的文件，其宏定义为<br>  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#define VOP_CLOSE(<span class="name">vp</span>,...) (<span class="name">*</span>((<span class="name">vp</span>)-&gt;v_op-&gt;vop_close))(<span class="name">vp</span>,...)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p><img src="/images/20191103=3.png" alt></p>
<p>同样的，vfs基类也有两个数据域，分别为vfs_data和vfs_op,它们将链接到特定文件系统<br>实现的数据与函数</p>
<p><strong>在c语言中，一个基类通过结构体的方式实现，在结构中包含了一些定义为公共的非虚的全局内核函数（或宏）。基类包含了指向另一个结构的指针，该结构包含了一个函数指针集合（每个虚函数一个函数指针）</strong></p>
<hr>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><blockquote>
<p>计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。</p>
</blockquote>
<p><a href="https://juejin.im/post/5b8ba9e26fb9a019c372e100" target="_blank" rel="noopener">补充链接</a></p>
<h3 id="s5fs"><a href="#s5fs" class="headerlink" title="s5fs"></a>s5fs</h3><p><img src="/images/20191103=4.png" alt><br><img src="/images/20190924=1.png" alt></p>
<p><strong>超级块</strong>中包含文件系统的元数据，每一个文件系统都有一个超级快，它驻留在磁盘上文件系统的开始处。当挂载一个文件系统时，内核读取超级块到内存中，当文件系统被卸载时，将其从内存中删除。 </p>
<p>一个超级块中包含：</p>
<ul>
<li>文件系统块大小</li>
<li>inode列表中块大小</li>
<li>空闲块和空闲inode数目</li>
<li>空闲块列表</li>
<li>空闲inode列表</li>
</ul>
<h3 id="ffs"><a href="#ffs" class="headerlink" title="ffs"></a>ffs</h3><p><img src="/images/20191103=5.png" alt><br><img src="/images/20191103=6.png" alt></p>
<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><p><img src="/images/20191103=7.png" alt><br><img src="/images/20191103=8.png" alt><br><img src="/images/20191103=9.png" alt></p>
<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p><img src="/images/20191103=10.png" alt><br><img src="/images/20191103=11.png" alt><br><a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">wiki</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-journaling-filesystems/index.html" target="_blank" rel="noopener">IBM-learn</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下文件目录学习</title>
    <url>/2019/09/24/UNIX%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ol>
<li>普通文件</li>
<li>目录文件</li>
<li>块缓存文件(对文件设备提供带缓存的访问)</li>
<li>字符特殊文件(对设备提供不带缓存的访问)</li>
<li>FIFO(命名管道)</li>
<li>套接字</li>
<li>符号链接</li>
</ol>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat()"></a>stat()</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include<span class="meta-string">"sys/stat.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stat(<span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ __file, <span class="keyword">struct</span> stat *__restrict__ __buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fstat(<span class="keyword">int</span> __fd, <span class="keyword">struct</span> stat *__buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lstst(<span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ __file, <span class="keyword">struct</span> stat *__restrict__ __buf)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>stat()第一个参数为文件路径，第二个参数是返回一个已经定义好的结构体</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mode_t</span>     st_mode;       <span class="comment">//文件对应的模式，文件，目录等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">ino_t</span>      st_ino;       <span class="comment">//inode节点号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">dev_t</span>      st_dev;        <span class="comment">//设备号码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">dev_t</span>      st_rdev;       <span class="comment">//特殊设备号码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">nlink_t</span>    st_nlink;      <span class="comment">//文件的连接数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uid_t</span>      st_uid;        <span class="comment">//文件所有者</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">gid_t</span>      st_gid;        <span class="comment">//文件所有者对应的组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">off_t</span>      st_size;       <span class="comment">//普通文件，对应的文件字节数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">time_t</span>     st_atime;      <span class="comment">//文件最后被访问的时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">time_t</span>     st_mtime;      <span class="comment">//文件内容最后被修改的时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">time_t</span>     st_ctime;      <span class="comment">//文件状态改变时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">blksize_t</span> st_blksize;    <span class="comment">//文件内容对应的块大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">blkcnt_t</span>   st_blocks;     <span class="comment">//该文件内容对应的块数量</span></span><br><span class="line"></span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>fstat()则是用的文件描述符代替路径</li>
<li>lstat()与stat()类似，当打开文件是一个符号链接时，只返回符号链接本身，而不是指向的文件</li>
<li>在&lt;sys/stat.h&gt;中定义了判断文件类型的宏</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th style="text-align:center">文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S_ISREG (st_mode)</td>
<td style="text-align:center">一般文件</td>
</tr>
<tr>
<td style="text-align:center">S_ISDIR (st_mode)</td>
<td style="text-align:center">目录</td>
</tr>
<tr>
<td style="text-align:center">S_ISCHR (st_mode)</td>
<td style="text-align:center">字符特殊文件</td>
</tr>
<tr>
<td style="text-align:center">S_ISBLK (st_mode)</td>
<td style="text-align:center">块特殊文件</td>
</tr>
<tr>
<td style="text-align:center">S_ISLNK (st_mode)</td>
<td style="text-align:center">符号连接</td>
</tr>
<tr>
<td style="text-align:center">S_ISBLK (st_mode)</td>
<td style="text-align:center">FIFO</td>
</tr>
<tr>
<td style="text-align:center">S_ISSOCK (st_mode)</td>
<td style="text-align:center">socket</td>
</tr>
</tbody>
</table>
<h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><ul>
<li>id 分有效id、实际id、设置id</li>
<li>一般有效id等于实际id</li>
<li>设置id 就是将执行该文件的进程有效id更换为文件所有者id ，在文件的st_mode值中</li>
</ul>
<p><img src="/images/20190924=0.png" alt></p>
<ul>
<li>对文件访问权限位也在st_mode内</li>
<li>为了打开目录内的文件，必须有对目录的读和执行权限、以及对文件的相应权限</li>
</ul>
<h3 id="access"><a href="#access" class="headerlink" title="access()"></a>access()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> access(<span class="keyword">const</span> <span class="keyword">char</span> *__name, <span class="keyword">int</span> __type)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>open()是以有效id测试其访问权限</li>
<li>acces()是以实际id测试</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">__type</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F_OK</td>
<td style="text-align:center">文件是否存在</td>
</tr>
<tr>
<td style="text-align:center">R_OK</td>
<td style="text-align:center">读</td>
</tr>
<tr>
<td style="text-align:center">W_OK</td>
<td style="text-align:center">写</td>
</tr>
<tr>
<td style="text-align:center">X_OK</td>
<td style="text-align:center">执行</td>
</tr>
</tbody>
</table>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask()"></a>umask()</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">__mode_t</span> umask(<span class="variable">__mode_t</span> <span class="variable">__mask</span>)</span><br><span class="line"></span><br><span class="line">返回之前的文件模式创建屏蔽字</span><br></pre></td></tr></table></figure>
<ul>
<li>__mask 即为文件权限描述符</li>
<li>umask()即屏蔽相应权限</li>
<li>shell 中<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式化查看当前文件模式创建屏蔽字</span><br><span class="line"></span><br><span class="line"><span class="built_in">umask</span> -S</span><br><span class="line"></span><br><span class="line">屏蔽others所有权限</span><br><span class="line"></span><br><span class="line"><span class="built_in">umask</span> 007</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod()"></a>chmod()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “sys/stat.h” </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">mode_t</span> mode)</span></span>; </span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>node 除了基本的9个外，还可用 </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">S_ISUID</th>
<th style="text-align:center">设置用户id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S_ISGID</td>
<td style="text-align:center">设置组id</td>
</tr>
<tr>
<td style="text-align:center">S_ISVTX</td>
<td style="text-align:center">保存粘着位(保存正文位)</td>
</tr>
<tr>
<td style="text-align:center">S_IRWXU</td>
<td style="text-align:center">用户读写执行</td>
</tr>
<tr>
<td style="text-align:center">S_IRWXG</td>
<td style="text-align:center">群组读写执行</td>
</tr>
<tr>
<td style="text-align:center">S_IRWXO</td>
<td style="text-align:center">其他读写执行</td>
</tr>
</tbody>
</table>
<ul>
<li>一个可执行文件的粘着位设置后，那么当它第一次被执行被终止的的时候，程序正文部分的一个副本会被保存在交换区，方便下次执行的时候快速载入内存</li>
<li>也允许对一个目录设置粘着位，如/var/tmp、/tmp，必须对该目录有写权限且拥有该目录或文件才能删除或重命名文件，当然root是全能的</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><img src="/images/20190924=1.png" alt></p>
<p><img src="/images/20190924=2.png" alt></p>
<ul>
<li>二图中有两个目录项指向同一个i节点，也就是链接数为2，存在于i节点。</li>
<li>当链接数减少为0的时候才删除相应数据块，这种链接类型被称为硬链接</li>
<li>而另一种链接方式是链接文件所指向的是另一个文件名字，类似于windows下的快捷方式，对于一个文件的简介指针这是符号链接</li>
<li>一个空文件夹最小链接数为2，即. 和 ..</li>
</ul>
<h3 id="link"><a href="#link" class="headerlink" title="link()"></a>link()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> link(<span class="keyword">const</span> <span class="keyword">char</span> *__from, <span class="keyword">const</span> <span class="keyword">char</span> *__to)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> unlink(<span class="keyword">const</span> <span class="keyword">char</span> *__name)</span><br><span class="line"> </span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>被指向路径只应该最后一部分不存在，否则失败</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">remove</span>(<span class="keyword">const</span> <span class="keyword">char</span> *__filename)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>等同于unink(),针对的是非UNIX系统</li>
</ul>
<h3 id="rename"><a href="#rename" class="headerlink" title="rename()"></a>rename()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>“stdio”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rename(<span class="keyword">const</span> <span class="keyword">char</span> *__old, <span class="keyword">const</span> <span class="keyword">char</span> *__new)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir()"></a>mkdir()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"sys/stat.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">mkdir</span>(<span class="keyword">const</span> <span class="keyword">char</span> *__path, __mode_t __mode)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>目录必须拥有一个执行位</li>
<li>文件模式屏蔽字同样适用</li>
</ul>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include“unistd.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rmdir(<span class="keyword">const</span> <span class="keyword">char</span> *__path)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="chdir"><a href="#chdir" class="headerlink" title="chdir()"></a>chdir()</h3><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include”unistd.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> chdir(<span class="keyword">const</span> <span class="keyword">char</span> *__path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fchdir(<span class="keyword">int</span> fd)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行chdir()后shell并不会切换目录、</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unisted.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * getcwd(<span class="keyword">char</span> *__buf, size_t __size)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用于获得绝对路径</li>
</ul>
<h3 id="文件位权限位小结"><a href="#文件位权限位小结" class="headerlink" title="文件位权限位小结"></a>文件位权限位小结</h3><p><img src="/images/20190924=3.png" alt></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a href="https://www.cnblogs.com/luntai/p/6129634.html" target="_blank" rel="noopener">复杂定义读法</a><br>从变量名看起，先往右，再往左，碰到圆括号就调转阅读的方向；括号内分析完就跳出括号，还是先右后左的顺序。如此循环，直到分析完整个定义。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pfunc) (<span class="built_in">int</span>);</span><br><span class="line"> 找到变量名pfunc，先往右是圆括号，调转方向，左边是一个*号，这说明pfunc是一个指针；然</span><br><span class="line"> 后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*pfunc)是一个函数，所以pfunc是一个</span><br><span class="line"> 指向这类函数的指针，即函数指针，这类函数具有一个<span class="built_in">int</span>类型的参数，返回值类型是<span class="built_in">int</span>。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> (* (*fp2) (<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">float</span>)) (<span class="built_in">int</span>);</span><br><span class="line">找到变量名fp2，往右看是圆括号，调转方向往左看到*号，说明fp2是一个指针；跳出内层圆括号</span><br><span class="line">，往右看是参数列表，说明fp2是一个函数指针，接着往 左看是*号，说明指向的函数返回值是指</span><br><span class="line">针；再跳出外层圆括号，往右看还是参数列表，说明返回的指针是一个函数指针，该函数有一个</span><br><span class="line"><span class="built_in">int</span>类型的参数，返回值 类型是<span class="built_in">float</span>。简言之，fp2是一个指向函数的指针，该函数接受三个参</span><br><span class="line">数(<span class="built_in">int</span>, <span class="built_in">int</span>和<span class="built_in">float</span>)，且返回一个指向函数的指针，该函数接受一个整型参数并返回一个<span class="built_in">float</span>。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下套接字学习</title>
    <url>/2020/01/15/UNIX%E4%B8%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>socket 是进程间通信方法中的一种,其他的还有管道,命名管道,信号量,信号,共享内存,消息队列</p>
<p>总体来说,建立一个socket连接分为以下几步<br><img src="/images/20200115=0.png" alt></p>
<table>
<thead>
<tr>
<th style="text-align:center">server</th>
<th style="text-align:center">client </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">socket()</td>
<td style="text-align:center">socket()</td>
</tr>
<tr>
<td style="text-align:center">bind()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">listen()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">accpet()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">connect() </td>
</tr>
<tr>
<td style="text-align:center">send()</td>
<td style="text-align:center">recv()</td>
</tr>
<tr>
<td style="text-align:center">close()</td>
<td style="text-align:center">close()</td>
</tr>
</tbody>
</table>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h1><p>用于新建一个套接字文件描述符,对于服务器将在这个描述符上监听端口,对于客户端将在这个描述符上建立连接<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"></span><br><span class="line">int socket(int doamin, int<span class="built_in"> type </span>, int protocol)</span><br><span class="line"></span><br><span class="line">成功返回文件描述符,失败返回-1</span><br></pre></td></tr></table></figure></p>
<p>常见domain </p>
<ul>
<li>AF_INET</li>
<li>AF_INET6</li>
<li>AF_UNIX (本地通讯)</li>
</ul>
<p>常见type</p>
<ul>
<li>SOCK_STREAM 提供基于连接可靠的、有顺序的、双工的字节流 (运输层采用的是TCP)</li>
<li>SOCK_DGRAM 提供了无连接的数据报支持 (采用UDP)</li>
<li>SOCK_RAW 提供了原始网络接口访问 (用于底层操作)</li>
</ul>
<h1 id="相关数据结构及转换函数"><a href="#相关数据结构及转换函数" class="headerlink" title="相关数据结构及转换函数"></a>相关数据结构及转换函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;</span><br><span class="line"><span class="comment">/* address族, AF_xxx */</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line"><span class="comment">/* 14 bytes 的协议地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in指的是 internet</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">        <span class="keyword">short</span> <span class="keyword">int</span> sin_family ;  <span class="comment">// 协议族</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port ;   <span class="comment">// 端口号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span> <span class="comment">// internet 地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">// 置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放internet 地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不同主机架构不同所定义的主机顺序不同,为了让数据在网络通讯中保持一致,所以还<br>有一些转换函数帮忙转换大端小端数据<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">网络通信采用是大端顺序</span><br><span class="line"></span><br><span class="line">大端是指数据高字节存储在内存低有效位上</span><br><span class="line">小端则是数据高字节存储在内存高有效位上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里的ｈ指的是host ,即主机顺序</li>
<li>ｎ指的则是网络顺序，nl则是64bit(8 bytes)长度,ns是32bit( 4 bypes)长度</li>
</ul>
<p>举个例子<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">        <span class="keyword">short</span> <span class="keyword">int</span> sin_family ;  <span class="comment">// 协议族</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port ;   <span class="comment">// 端口号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span> <span class="comment">// internet 地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">// 置0</span></span><br><span class="line">&#125;addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">addr.sin_port = htons(<span class="number">1234</span>); <span class="comment">/* 查看addr.sin_port 定义为unsigned short int */</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>可见只需调用转换函数就可以不用关心自己主机是大端序还是<br>小端序了,统统转换为网络顺序即可</li>
</ul>
<p>当然如何判断大小端也是需要知道的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> tmp&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">char</span> date;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    利用指针强制转换</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> * )&amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*p)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"small "</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   初始化一个16进制的类型的数据，然后把它放在一个char类型的数组中，由于十六进制的</span></span><br><span class="line"><span class="comment">   数据一位代表四个bit位char型是8个bit位，那么十六进制的两位占一个char位，那么就可</span></span><br><span class="line"><span class="comment">   以把数据位分离。</span></span><br><span class="line"><span class="comment">    若是小字节,数值高字节在高有效位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> a = <span class="number">0x1122</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *pp = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pp[<span class="number">0</span>]==<span class="number">0x22</span> &amp;&amp; pp[<span class="number">1</span>] == <span class="number">0x11</span>) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"small "</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"big "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    利用共用体内存占用为最小占用者大小性质</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">union</span> tmp t;</span><br><span class="line">	t.val = <span class="number">0x1122</span>;</span><br><span class="line">	<span class="keyword">if</span>(t.date == <span class="number">0x11</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"big "</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"small "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从sockaddr_in这个数据结构看出不仅有端口需要转换,还有ip地址也需要转换<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;sys/socket.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;netinet/<span class="keyword">in</span>.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> inet<span class="constructor">_aton(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">cp</span>, <span class="params">struct</span> <span class="params">in_addr</span> <span class="operator">*</span><span class="params">inp</span>)</span>;</span><br><span class="line"><span class="comment">// 将cp所指向的.和数字组成的ip地址字符串转化为网络序存储在inp指向结构内</span></span><br><span class="line"><span class="built_in">char</span> *inet<span class="constructor">_ntoa(<span class="params">struct</span> <span class="params">in_addr</span> <span class="params">in</span>)</span>;<span class="comment">//</span></span><br><span class="line"><span class="comment">//跟上面函数相反,返回的为静态分配的数组</span></span><br><span class="line"></span><br><span class="line">in_addr_t inet<span class="constructor">_addr(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">cp</span>)</span>;</span><br><span class="line"><span class="comment">//将.和数字组成的ip地址字符串转换为网络序</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>简单例子<code>addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</code></li>
</ul>
<hr>
<h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><p>用于将地址和套接字描述符绑定<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>从定义看出该函数用的是sockaddr结构,从sockaddr和sockaddr_in定义可以发现,这两个结构其实是等价的,sockaddr_in中的sin_port占两字节,sin_addr占4字节,sin_zero[8]为8字节,加起来刚好等于14字节对应sockaddr的sa_data[14]</li>
<li>所以我们可以通过sockaddr_in方便访问地址的每一部分,最后需要sockaddr的时候再进行类型转换就够了</li>
<li><p>当然数据都必须是网络字节顺序</p>
</li>
<li><p><code>bind(sockfd,(struct sockaddr *)addr_in,sizeof(addr_in));</code></p>
</li>
</ul>
<hr>
<h1 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h1><p>在一个套接字上监听一个连接<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>backlog 为监听队列上最大监听数量</li>
<li>失败返回时具体原因代码存储在全局变量errno中,若在程序中使用了多个errno,在打印错误时要现将errno置0,否则errno可能为上一个发生的错误</li>
<li>errno 定义于 <code>&lt;errno.h&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="comment">// 可方便的将errno对应的原因打印出来</span></span><br><span class="line"><span class="comment">// 打印格式为 *s :error reason</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h1><p>用于接受一个套接字连接，并返回新的套接字描述符<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">成功返回一个新的套接字描述符，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>sockfd为之前监听的套接字</li>
<li>addr保存了远程机器连接的信息</li>
<li>*addelen为指向addr长度的指针</li>
<li>这里返回新的描述符用于进行读写操作，区别与之前用于监听的描述符</li>
</ul>
<hr>
<h1 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h1><p>建立一个新的套接字连接,客户端用于连接服务器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里的addr 是目标连接机器的信息结构</li>
</ul>
<hr>
<h1 id="recv-、send"><a href="#recv-、send" class="headerlink" title="recv()、send()"></a>recv()、send()</h1><p>类似与read()、write()<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回接收、发送字节数</span><br></pre></td></tr></table></figure></p>
<ul>
<li>flags一般设为0</li>
</ul>
<hr>
<h1 id="简单C-S实现"><a href="#简单C-S实现" class="headerlink" title="简单C/S实现"></a>简单C/S实现</h1><p>服务端<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 1234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLOG 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_error_exit</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"service is running at %s:%d\n"</span>,IP,PORT);</span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        server_error_exit(fd,<span class="string">"init socket "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init local data structure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_in</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_in,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr_in));</span><br><span class="line">    addr_in.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    addr_in.sin_family = AF_INET;</span><br><span class="line">    addr_in.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(fd,(struct sockaddr *)&amp;addr_in,<span class="keyword">sizeof</span>(addr_in)) &lt; <span class="number">0</span>)</span><br><span class="line">        server_error_exit(fd,<span class="string">"bind "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(fd,MAXLOG) &lt; <span class="number">0</span>)</span><br><span class="line">        server_error_exit(fd,<span class="string">"listen error "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock</span> ;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sock_len = <span class="keyword">sizeof</span>(sock);</span><br><span class="line">    <span class="keyword">int</span> fd_d = accept(fd,(struct sockaddr *)&amp;sock,&amp;sock_len);</span><br><span class="line">    <span class="keyword">if</span>(fd_d &lt; <span class="number">0</span> )</span><br><span class="line">        server_error_exit(fd_d,<span class="string">"accept error "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">40</span>]=<span class="string">" \nthis is server"</span>;</span><br><span class="line">    send(fd_d,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"do you accept ? "</span>);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	recv(fd_d,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n%s remote port is %d"</span>,buf,ntohs(sock.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了完整抓到四次挥手中的最后一次挥手</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">    close(fd_d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_error_exit</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(buf);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 1234</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_error_exit</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//init a socket</span></span><br><span class="line">	<span class="keyword">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        client_error_exit(fd,<span class="string">"socket init "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init remote pc data structure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sock,<span class="number">0</span>,<span class="keyword">sizeof</span>(sock));</span><br><span class="line">    sock.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    sock.sin_family = AF_INET;</span><br><span class="line">    sock.sin_port = ntohs(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(fd,(struct sockaddr *)&amp;sock,<span class="keyword">sizeof</span>(sock)) &lt; <span class="number">0</span>)</span><br><span class="line">        client_error_exit(fd,<span class="string">"connect error "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read data from fd</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(recv(fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        client_error_exit(fd,<span class="string">"recv "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is client ! that is ? %s "</span>,buf);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write data to fd</span></span><br><span class="line">    <span class="keyword">char</span> a[] = <span class="string">"yes !"</span>;</span><br><span class="line">    send(fd,a,<span class="keyword">sizeof</span>(a),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_error_exit</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(buf);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$<span class="built_in"> service </span>is running at 127.0.0.1:1234</span><br><span class="line"><span class="keyword">do</span> you accept ? </span><br><span class="line"><span class="literal">yes</span> ! remote<span class="built_in"> port </span>is 33744%  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ this is<span class="built_in"> client </span>! that is ?  </span><br><span class="line">this is<span class="built_in"> server </span>%</span><br></pre></td></tr></table></figure>
<ul>
<li>可见正常工作</li>
</ul>
<hr>
<h1 id="抓包分析报文"><a href="#抓包分析报文" class="headerlink" title="抓包分析报文"></a>抓包分析报文</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">apt install -y wireshark  </span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">wireshark</span></span><br></pre></td></tr></table></figure>
<ul>
<li>选择loop接口,分别运行server和client</li>
<li><p>在筛选框输入<code>tcp.port == 1234</code>,于是得到<br><img src="/images/20200115=1.png" alt></p>
</li>
<li><p>TCP报文格式<br><img src="/images/20200115=2.png" alt></p>
</li>
</ul>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/images/20200115=4.png" alt></p>
<ol>
<li>客户端向服务器发起连接请求,SYN = 1 ,seq = 0,ack = 0</li>
<li>服务器收到后,允许建立连接,发送ACK = 1,SYN = 1 , seq = 0, ack = 1(表示客户端seq = 0 的报文收到)</li>
<li>客户端最后向服务器确认,发送ACK = 1,seq = 1 ,ack = 1(表示服务器seq = 0 的报文收到)</li>
</ol>
<ul>
<li>然后就可以发送数据了</li>
</ul>
<p>为什么需要三次握手</p>
<ul>
<li>为了确认SYN的有效性:如果是一次握手的话,客户端无法知道服务器是否建立了连接,两次握手的话只能确定服务器收到了客户端发来的请求,可能会出现客户端第一次发送SYN由于网络堵塞没能及时送至服务器,然后超时重传又发送了一次SYN,建立连接之后第一个SYN到达,此时服务器认为这是一个新连接,发送ACK给客户端,但此时客户端连接已经建立,会丢弃该报文,而服务器却在一直等待客户端回复,浪费了资源</li>
<li>为了数据的可靠传输,在TCP连接的双方都有一个序列号需要维护,两次握手只能确认连接发起方的数据顺序性,而连接被连接方的序号顺序性不能得到检验</li>
</ul>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="/images/20200115=3.png" alt><br>设A为连接先关闭的一方,B为另一方</p>
<ol>
<li>连接先关闭的一方先发送FIN = 1,ACK = 1,seq = x 給B</li>
<li>B 收到后先发送ACK = 1,seq= y,ack =x+1給A,表示A到B的连接已关闭,A只能接受不能发送</li>
<li>B 再发送FIN = 1 , ACK = 1,seq = p,ack = x+1給A</li>
<li>A 收到后,发送ACK = 1, seq = x+1,ack = p+1</li>
</ol>
<p>为什么需要四次挥手</p>
<ul>
<li>TCP连接是全双工的,每一边连接都需要发送终止信号并被确认直至链路没有数据传输才能销毁连接,如果是三次挥手的话,被动关闭方需要同时回复ACK = 1和FIN = 1,如果被动关闭方此时没有待处理数据,则是可以的,如果有则不行</li>
<li>这种情况在四次握手对应的是close-wait状况,被关闭方处理待发送数据</li>
<li>time-wait是2msl是为了防止最后一个ACK报文不能到达和使本次连接的报文都从网络中消失</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下标准I/O与系统信息学习</title>
    <url>/2019/09/28/UNIX%E4%B8%8B%E6%A0%87%E5%87%86I-O%E4%B8%8E%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><h3 id="流与文件指针"><a href="#流与文件指针" class="headerlink" title="流与文件指针"></a>流与文件指针</h3><blockquote>
<p> a <a href="https://en.wikipedia.org/wiki/Stream_(computing" target="_blank" rel="noopener">stream</a>) is a source or sink of data, usually individual bytes or characters.</p>
</blockquote>
<ul>
<li>标准I/O都是围绕流来进行的</li>
<li>同样标准I/O操作都是围绕FILE指针完成的</li>
<li>典型的stdin、stdout、stderr流都是被相应的文件指针绑定的</li>
</ul>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><ul>
<li>全缓冲(填满缓冲区进行IO)</li>
<li>行缓冲(遇到换行符就进行IO))</li>
<li>不缓冲</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line">void setbuf(FILE *<span class="variable">__restrict__</span> <span class="variable">__stream</span>, char *<span class="variable">__restrict__</span> <span class="variable">__buf</span>)</span><br><span class="line"></span><br><span class="line">int setvbuf(FILE *<span class="variable">__restrict__</span> <span class="variable">__stream</span>, char *<span class="variable">__restrict__</span> <span class="variable">__buf</span>, int <span class="variable">__modes</span>, size_t <span class="variable">__n</span>)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回非<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>setbuf()通常设置后是全缓冲，但终端设备可以是行缓冲，不进行缓冲则将buf设置为NULL</li>
<li>setvbuf()可以指定缓冲类型，具体见下图<br><img src="/images/20190928=0.png" alt></li>
</ul>
<h3 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span><span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span> * fopen(<span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ __filename, <span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ __modes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span> *freopen(<span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ __filename, <span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ __modes, <span class="keyword">FILE</span> *__restrict__ __stream)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span> *fdopen (int __fd, <span class="keyword">const</span> <span class="keyword">char</span> *__modes)</span><br><span class="line"></span><br><span class="line">成功返回文件指针，失败返回NULL</span><br></pre></td></tr></table></figure>
<ul>
<li>freopen()用于在一个指定的流上打开文件</li>
<li>type<br><img src="/images/20190928=1.png" alt></li>
</ul>
<h3 id="读写流"><a href="#读写流" class="headerlink" title="读写流"></a>读写流</h3><ul>
<li><p>读</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc(_fp) _IO_getc (_fp)</span></span><br><span class="line"><span class="keyword">int</span> _IO_getc(_IO_FILE *__fp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fgetc(FILE *__stream)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> getchar(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">成功返回下一个字符，失败返回EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>写</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> putc(_ch,_fp) </span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> fputc(<span class="built_in">int</span> __c, FILE *__stream)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> putchar(<span class="built_in">int</span> __c)</span><br><span class="line"></span><br><span class="line">成功返回c，失败返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回的c为ASCII字符</p>
</li>
</ul>
<p>行IO<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * fgets(<span class="keyword">char</span> *__restrict__ __s, <span class="keyword">int</span> __n, <span class="keyword">FILE</span> *__restrict__ __stream)</span><br><span class="line"></span><br><span class="line">成功返回buf，失败返回<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fputs(const <span class="keyword">char</span> *__restrict__ __s, <span class="keyword">FILE</span> *__restrict__ __stream)</span><br><span class="line"></span><br><span class="line">成功返回非负，失败返回<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span><span class="string">"stdio.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> ftell(<span class="keyword">FILE</span> *__stream)</span><br><span class="line"></span><br><span class="line">成功返回当前文件位置指示，失败返回-<span class="number">1</span>L</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fseek(<span class="keyword">FILE</span> *__stream, <span class="keyword">long</span> __off, <span class="keyword">int</span> __whence)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * tmpnam(<span class="keyword">char</span> *__s)</span><br><span class="line"></span><br><span class="line">成功返回文件指针，失败返回NULL</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="系统数据文件信息"><a href="#系统数据文件信息" class="headerlink" title="系统数据文件信息"></a>系统数据文件信息</h1><h3 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/passwd</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line"><span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"><span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"><span class="symbol">sys:</span><span class="symbol">x:</span><span class="number">3</span><span class="symbol">:</span><span class="number">3</span><span class="symbol">:sys</span><span class="symbol">:/dev</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"><span class="symbol">sync:</span><span class="symbol">x:</span><span class="number">4</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:sync</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sync</span></span><br><span class="line"><span class="symbol">games:</span><span class="symbol">x:</span><span class="number">5</span><span class="symbol">:</span><span class="number">60</span><span class="symbol">:games</span><span class="symbol">:/usr/games</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"><span class="symbol">nobody:</span><span class="symbol">x:</span><span class="number">65534</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:nobody</span><span class="symbol">:/nonexistent</span><span class="symbol">:/usr/sbin/nologin</span></span><br></pre></td></tr></table></figure>
<ul>
<li>相对应的是用户、口令、用户id、组id、注释、用户工作目录、登录可执行文件</li>
<li>像/usr/sbin/nologin、/dev/null是为了防止其登录</li>
<li>用户id、组id65534 没有任何特权，只能访问人人都能读写的文件</li>
<li>一般口令经单向加密算法加密后存放在/etc/shadow</li>
</ul>
<h3 id="组文件与id"><a href="#组文件与id" class="headerlink" title="组文件与id"></a>组文件与id</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"># /<span class="selector-tag">etc</span>/<span class="selector-tag">group</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">root</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:0</span>:</span><br><span class="line"><span class="selector-tag">daemon</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:1</span>:</span><br><span class="line"><span class="selector-tag">bin</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:2</span>:</span><br><span class="line"><span class="selector-tag">sys</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:3</span>:</span><br><span class="line"><span class="selector-tag">adm</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:4</span><span class="selector-pseudo">:syslog</span></span><br><span class="line"><span class="selector-tag">tty</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:5</span>:</span><br><span class="line"><span class="selector-tag">disk</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:6</span>:</span><br><span class="line"><span class="selector-tag">lp</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:7</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li>类似于passwd结构，相对应是组名、口令、组id、所包含的用户名</li>
<li>在使用useradd命令创建用户的时侯可以用-g 和-G 指定用户所属组和附属组。<br>基本组：如果没有指定用户组，创建用户的时候系统会默认同时创建一个和这个用户名同名的组，这个组就是基本组，不可以把用户从基本组中删除。在创建文件时，文件的所属组就是用户的基本组。<br>附加组：除了基本组之外，用户所在的其他组，都是附加组。用户是可以从附加组中被删除的。<br>用户不论是在基本组中还是附加组中，就会拥有该组的权限。一个用户可以属于多个附加组。但是一个用户只能有一个基本组。</li>
</ul>
<p>使用下列命令查看当前用户(user)权限<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">id</span> user</span><br></pre></td></tr></table></figure></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">uid=<span class="number">1000</span>(<span class="number">123</span>) gid=<span class="number">1000</span>(<span class="number">123</span>) groups=<span class="number">1000</span>(<span class="number">123</span>),<span class="number">4</span>(adm),<span class="number">20</span>(dialout),<span class="number">24</span>(cdrom),<span class="number">25</span>(floppy),<span class="number">27</span>(sudo),<span class="number">29</span>(audio),<span class="number">30</span>(dip),<span class="number">44</span>(video),<span class="number">46</span>(plugdev),<span class="number">108</span>(lxd),<span class="number">114</span>(netdev)</span><br></pre></td></tr></table></figure>
<ul>
<li>groups后除了123组之外，全是附属组</li>
</ul>
<hr>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"time.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *__timer)</span><br><span class="line"></span><br><span class="line">成功返回时间值，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回的是日历时间，又叫Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用</p>
</li>
<li><p>时间值被保存在__timer所指单元内</p>
</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"time.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">tm</span> *<span class="built_in">gmtime</span>(const time_t *__timer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">tm</span> *<span class="built_in">localtime</span>(const time_t *__timer)</span><br><span class="line"></span><br><span class="line">成功返回指向tm结构体的指针,失败返回<span class="built_in">NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li>gtime()将日历时间转化为UTC时间(协调世界时),localtime则是本地时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;			<span class="comment">/* Seconds.	[0-60] (1 leap second) */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;			<span class="comment">/* Minutes.	[0-59] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;			<span class="comment">/* Hours.	[0-23] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;			<span class="comment">/* Day.		[1-31] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;			<span class="comment">/* Month.	[0-11] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;			<span class="comment">/* Year	- 1900.  */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;			<span class="comment">/* Day of week.	[0-6] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;			<span class="comment">/* Days in year.[0-365]	*/</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;			<span class="comment">/* DST.		[-1/0/1]*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span>	__USE_MISC</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> tm_gmtoff;		<span class="comment">/* Seconds east of UTC.  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *tm_zone;		<span class="comment">/* Timezone abbreviation.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __tm_gmtoff;		<span class="comment">/* Seconds east of UTC.  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *__tm_zone;	<span class="comment">/* Timezone abbreviation.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>用于格式化输出时间</em><br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"time.h"</span></span></span><br><span class="line"></span><br><span class="line">size_t strftime(char *<span class="variable">__restrict__</span> <span class="variable">__s</span>, size_t <span class="variable">__maxsize</span>, const char *<span class="variable">__restrict__</span> <span class="variable">__format</span>, const struct tm *<span class="variable">__restrict__</span> <span class="variable">__tp</span>)</span><br><span class="line"></span><br><span class="line">成功返回存入数组字节，失败返回<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20190928=2.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"time.h"</span></span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> qq[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">stime</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> timer;</span><br><span class="line">    </span><br><span class="line">    time(&amp;timer);</span><br><span class="line">    stime=localtime(&amp;timer);</span><br><span class="line">    strftime(qq,<span class="number">100</span>,<span class="string">"%c"</span>,stime);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,qq);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld"</span>,timer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Sat Sep <span class="number">28</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">54</span> <span class="number">2019</span></span><br><span class="line"><span class="number">1569666834</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可见可以快速打印出漂亮的格式</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose学习</title>
    <url>/2020/04/12/docker-compose%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="构建自己的镜像"><a href="#构建自己的镜像" class="headerlink" title="构建自己的镜像"></a>构建自己的镜像</h1><p>创建自己的docker镜像可以有两种方式</p>
<ol>
<li>在已有镜像上做修改再commit</li>
<li>利用dockerfile构建</li>
<li>手动导入导出（过时）</li>
</ol>
<h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>默认容器启动时是在一个可以修改的最顶层镜像层上保存着所有修改的内容，然后重启失效</p>
<p>可用<code>docker commit -a &quot;作者&quot; -m &quot;描述信息&quot; id 新的镜像名:tag</code> 来将修改的内容保存形成一个新的镜像</p>
<p>用<code>docker histiry id</code> 查看历史记录</p>
<p>用<code>docker diff id</code> 查看文件变动</p>
<p>每次调用<code>commit</code>都会使镜像新增一个新的存储层,哪怕是添加文件后又删除,而每一次操作都是黑箱式操作,不利于维护,所以构建镜像应该用<code>dockerfile</code>来构建</p>
<h4 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h4><p>dockerfile是一个文本文件,包含了构建docker镜像的指令,每一个指令都会形成一个新的镜像层</p>
<p><strong>FROM</strong> 用于指定基础镜像</p>
<ul>
<li>基础镜像可以是一个服务(mysql)也可以是一个操作系统(alpine 一个非常轻量的linux发行版,仅占5MB左右)</li>
<li>也可以不指定基础镜像,直接从二进制文件开始作为第一层镜像,需用到<code>FROM scratch</code>，代表的是一个空镜像，然后执行命令</li>
</ul>
<p><strong>COPY</strong> 复制文件</p>
<ul>
<li>格式为 <code>COPY 源地址 目的地址</code> ，复制完成后会形成一层新的镜像层，相对于一条指令形成一层镜像层</li>
<li>复制时默认保留文件的元数据，即权限、时间等，也可以手动指定用户和用户组 <code>COPY --chown=user：group 123 123</code></li>
</ul>
<p><strong>RUN</strong> 执行命令<br>一共有两种执行格式：</p>
<ul>
<li>shell： <code>RUN echo $SHELL</code> 后接一条shell语句或用 <code>&amp;&amp;</code> 拼接的多条语句（这是因为多条指令会多形成新的层，镜像层有最大层数限制且不利于维护，不美观）</li>
<li>exec： <code>RUN [&quot;echo&quot;,&quot;$SHELL&quot;]</code> 前面为可执行文件，后面为可选的参数</li>
</ul>
<p><strong>CMD</strong> 容器启动命令</p>
<ul>
<li>格式与<code>RUN</code> 类似</li>
<li>shell格式的命令会被解析为<code>sh -c command</code>格式，实际为`RUN [“sh”,”-c”,”command”],所以在命令中可用环境变量</li>
<li>在运行容器时可手动覆盖<code>CMD</code>，如<code>docker run -it test /bin/bsah</code>，镜像名后接的命令即是覆盖后的命令</li>
<li>需要注意一点，容器提供服务的只是一个进程，容器的1号进程为自己指定的程序，所以当进程退出了容器随即消亡，容器没有后台服务的概念，如果将<code>CMD</code>设置为一个shell命令，那么就是执行完命令容器就退出了，要让容器持续提供服务，<code>CMD</code>应为一个长久的前台命令，如<code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off&quot;]</code></li>
</ul>
<p><strong>ENTRYPOINT</strong> 入口点</p>
<ul>
<li>格式与<code>CMD</code>相似，同时也是启动命令</li>
<li>当<code>CMD</code>和<code>ENTRYPOINT</code>同时出现时（上面说道，），<code>CMD</code>的意义就发生了变化，不再是容器启动命令，而被当作<code>ENTRYPOINT</code>所指定的命令的参数</li>
<li>和<code>CMD</code>一样可以被覆盖，<code>docker run</code>使用<code>--entrypoint command</code> </li>
<li>[有点绕&gt;&gt;&gt;&gt;例子]（<a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/entrypoint.html）" target="_blank" rel="noopener">https://vuepress.mirror.docker-practice.com/image/dockerfile/entrypoint.html）</a></li>
</ul>
<p><strong>ENV</strong> 环境变量</p>
<ul>
<li><code>ENV key value</code> 或者 <code>ENV key=value</code></li>
<li>设置完的变量在其他指令里也可以用</li>
<li>同样也可以被覆盖，<code>docker run</code> + <code>-e key=value</code></li>
</ul>
<p><strong>VOLUME</strong> 定义匿名卷</p>
<ul>
<li>格式与<code>CMD</code>类似，<code>VOLUME /PATH</code>或<code>VOLUME [&quot;PATH&quot;,&quot;PATH2&quot;]</code> </li>
<li>这里的匿名卷可以将数据库的数据存储下来不至于丢失，但为了方便管理还是手动创建命名良好的卷再挂载，<code>docker run</code> + <code>-v volumename：/path</code></li>
</ul>
<p><strong>EXPOSE</strong> 声明端口</p>
<ul>
<li>格式类似与上面</li>
<li>该指令只是声明端口，不会实际开启这个端口提供服务，为<code>docker run</code>命令中指定了<code>-P</code> 的容器端口，然后映射为随机主机端口</li>
</ul>
<p><strong>WORKDIR</strong> 指明工作目录</p>
<ul>
<li>格式 <code>WORKDIR /PATH</code>，若目录会存在会自动创建</li>
<li>每一层镜像层都是一个独立环境，上一个切换目录的指令不会影响到下条指令，所以需要指定工作目录</li>
</ul>
<p><strong>USER</strong> 指定当前用户</p>
<ul>
<li>同上</li>
</ul>
<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p><del>咕咕咕,待更新</del></p>
<h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><p><a href="https://www.runoob.com/w3cnote/yaml-intro.html" target="_blank" rel="noopener">yaml入门</a></p>
<blockquote>
<p>基本语法</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
</blockquote>
<p>YAML 支持以下几种数据类型：</p>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>标量（scalars）：单个的、不可再分的值</li>
</ul>
<p>&amp; 用来建立锚点（defaults），&lt;&lt; 表示合并到当前数据，* 用来引用锚点<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">defaults</span>: &amp;defaults</span><br><span class="line">  <span class="attribute">adapter</span>:  postgres</span><br><span class="line">  <span class="attribute">host</span>:     localhost</span><br><span class="line"></span><br><span class="line"><span class="attribute">development:</span></span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line"><span class="attribute">test:</span></span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;&lt;: *defaults</code> == <code>adapter: postgres \n host: localhost</code></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下线程学习</title>
    <url>/2019/10/23/UNIX%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h1><p><img src="/images/20191024=3.png" alt></p>
<blockquote>
<p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
</blockquote>
<p>进程 = 一组线程 + 一组资源</p>
<p>内核线程: 在内核内部根据需要创建和销毁，负责执行一个特殊功能，耗费资源最多</p>
<p>轻量进程：由内核支持的用户进程，依赖于内核进程</p>
<p>用户进程：由库实现的进程，并不与内核交互，其库相当于微内核(管理者)，耗费资源最少</p>
<p><img src="/images/20191024=0.png" alt></p>
<p><img src="/images/20191024=1.png" alt></p>
<p><img src="/images/20191024=2.png" alt></p>
<hr>
<h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><p>而这里的线程都指用户线程<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pthread</span>库不是<span class="selector-tag">Linux</span>系统默认的库，连接时需要使用静态库</span><br><span class="line"><span class="selector-tag">libpthread</span><span class="selector-class">.a</span>，所以需要链接该库。在编译中要加 <span class="selector-tag">-lpthread</span>参数。</span><br></pre></td></tr></table></figure></p>
<h3 id="线程id"><a href="#线程id" class="headerlink" title="线程id"></a>线程id</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">返回调用线程的线程id</span><br></pre></td></tr></table></figure>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *<span class="variable">__restrict__</span> <span class="variable">__newthread</span>,</span><br><span class="line"> const pthread_attr_t *<span class="variable">__restrict__</span> <span class="variable">__attr</span>, </span><br><span class="line"> void *(*<span class="variable">__start_routine</span>)(void *), </span><br><span class="line"> void *<span class="variable">__restrict__</span> <span class="variable">__arg</span>)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>当成功返回时，新创建线程id被设置为__newthread 指向的内存单位</li>
<li>第二个参数为分配的属性</li>
<li>第三个参数为线程创建时执行的函数</li>
<li>最后一个参数为传递的参数</li>
</ul>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>进程的任一线程调用exit()、_Exit()、_exit()，那么整个进程都会结束</p>
<p>单个线程可以通过3种方式退出:</p>
<ol>
<li>简单的从启动例程(*__start_routine)返回，返回值为线程的退出码</li>
<li>被同一进程的其他线程取消</li>
<li>线程调用pthread_exit()</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *__retval)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>*__retval为一个无类型指针，与传递给启动例程的参数类似</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span><span class="string">"pthread.h"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_join(<span class="params">pthread_t</span> <span class="params">__th</span>, <span class="params">void</span> <span class="operator">**</span><span class="params">__thread_return</span>)</span></span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>调用线程将堵塞直至指定线程退出</li>
<li>__thread_return包含返回信息，如不需要可设为NULL</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span><span class="string">"pthread.h"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_cancel(<span class="params">pthread_t</span> <span class="params">__th</span>)</span></span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<p>进程 线程原语(系统调用)比较<br><img src="/images/20191024=4.png" alt></p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>当一个线程访问带有互斥锁状态的资源，会被堵塞</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener">死锁</a></p>
</blockquote>
<figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">典型</span><br><span class="line"></span><br><span class="line"><span class="keyword">P</span><span class="number">1</span>、<span class="keyword">P</span><span class="number">2</span>两个process都需要资源才能继续运行。<span class="keyword">P</span><span class="number">1</span>拥有资源<span class="keyword">R</span><span class="number">2</span>、还</span><br><span class="line">需要额外资源<span class="keyword">R</span><span class="number">1</span>才能运行；<span class="keyword">P</span><span class="number">2</span>拥有资源<span class="keyword">R</span><span class="number">1</span>、还需要额外资源<span class="keyword">R</span><span class="number">2</span>才能</span><br><span class="line">运行，两边都在互相等待而没有任何一个可执行。</span><br></pre></td></tr></table></figure>
<p>死锁的四个条件是：</p>
<ul>
<li>禁止抢占 (no preemption) - 系统资源不能被强制从一个进程中退出</li>
<li>持有和等待 (hold and wait) - 一个进程可以在等待时持有系统资源</li>
<li>互斥 (mutual exclusion) - 只有一个进程能持有一个资源</li>
<li>循环等待 (circular waiting) - 一系列进程互相持有其他进程所需要的资源</li>
</ul>
<p>死锁只有在这四个条件同时满足时出现。预防死锁就是至少破坏这四个条件其中一项，即破坏“禁止抢占”、破坏“持有等待”、破坏“资源互斥”和破坏“循环等待”。</p>
<h3 id="互斥量-互斥锁"><a href="#互斥量-互斥锁" class="headerlink" title="互斥量(互斥锁)"></a>互斥量(互斥锁)</h3><p>互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制，确保同一时间只有一个进程访问资源<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span><span class="string">"pthread.h"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_mutex_init(<span class="params">pthread_mutex_t</span> <span class="operator">*</span><span class="params">__mutex</span>, <span class="params">const</span> <span class="params">pthread_mutexattr_t</span> <span class="operator">*</span><span class="params">__mutexattr</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_mutex_destroy(<span class="params">pthread_mutex_t</span> <span class="operator">*</span><span class="params">__mutex</span>)</span></span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://www.zhihu.com/question/41653775" target="_blank" rel="noopener">如何理解C语言关键字restrict？</a></p>
<ul>
<li>静态分配互斥量需初始化，属性设为NULL为默认</li>
<li>在动态分配互斥量前需调用 pthread_mutex_destroy()</li>
</ul>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span><span class="string">"pthread.h"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_mutex_lock(<span class="params">pthread_mutex_t</span> <span class="operator">*</span><span class="params">__mutex</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_mutex_trylock(<span class="params">pthread_mutex_t</span> <span class="operator">*</span><span class="params">__mutex</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_mutex_unlock(<span class="params">pthread_mutex_t</span> <span class="operator">*</span><span class="params">__mutex</span>)</span></span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>lock时若已经加锁，则会堵塞至解锁</li>
<li>trylock时若已经加锁，不会堵塞至解锁</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单数据保护</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">include</span>&lt;stdio.h&gt;</span><br><span class="line">#<span class="keyword">include</span>&lt;stdlib.h&gt;</span><br><span class="line">#<span class="keyword">include</span>&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义被保护的数据结构</span></span><br><span class="line"> <span class="keyword">struct</span>  foo </span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">int</span> f_id;</span><br><span class="line">     pthread_mutex_t f_mutex;</span><br><span class="line">     <span class="built_in">int</span> f_count;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//数据分配</span></span><br><span class="line"> <span class="keyword">struct</span> foo *</span><br><span class="line"> foo<span class="constructor">_alloc()</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">struct</span> foo *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp=malloc(sizeof(<span class="keyword">struct</span>  foo)!=NULL))&#123;</span><br><span class="line">        fp-&gt;f_id=id;</span><br><span class="line">        fp-&gt;f_count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pthread<span class="constructor">_mutex_lock(<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            free(fp);</span><br><span class="line">            return(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加资源被引用量</span></span><br><span class="line"> void foo<span class="constructor">_hold(<span class="params">struct</span> <span class="params">foo</span> <span class="operator">*</span><span class="params">fp</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     pthread<span class="constructor">_mutex_lock(&amp;<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>;</span><br><span class="line">     fp-&gt;f_count++;</span><br><span class="line">     pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//减少资源被引用量</span></span><br><span class="line"> void foo<span class="constructor">_rele(<span class="params">struct</span> <span class="params">foo</span> <span class="operator">*</span><span class="params">fp</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     pthread<span class="constructor">_mutex_lock(&amp;<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>;</span><br><span class="line">     <span class="keyword">if</span>(&amp;fp-&gt;f_count==<span class="number">0</span>)&#123;<span class="comment">//当没有被引用时释放</span></span><br><span class="line">         pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>;</span><br><span class="line">         pthread<span class="constructor">_mutexattr_destroy(&amp;<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>;</span><br><span class="line">         free(fp);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    fp-&gt;f_count--;</span><br><span class="line"></span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">fp</span>-&gt;<span class="params">f_mutex</span>)</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>简单的互斥量，但它不是通过休眠时进程堵塞，而是在获取锁之前一直处于忙等状态。</p>
<p>常用于以下情况： 锁被持有的时间短，且线程不希望在进程调度时花太多时间</p>
<p>忙等时cpu不能做其他事情，这是用于锁被持有的时间短的原因</p>
<p>接口与互斥量类似，将<strong>mutex</strong>替换为<strong>spin</strong>即可</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量也类似，但提供了更好的并行量，也叫共享互斥锁</p>
<blockquote>
<p>并行是指实际并行执行程度，取决于cpu数目</p>
</blockquote>
<blockquote>
<p>并发是指没有cpu数目限制下，程序所达到最大的并行度，取决于程序编写方式及多线程的处理方式</p>
</blockquote>
<p>  并发分为系统并发和用户并发。</p>
<ul>
<li>内核提供的系统并发是通过识别进程里的控制线程(hot pthreads)并独立调用它们</li>
<li>应用程序是通过线程库来提供用户并发，这些用户线程或协同程序( coroutine)又叫cold pthread,无法被内核识别，由线程库管理调度</li>
</ul>
<p>读写锁状态：</p>
<ul>
<li>读模式加锁</li>
<li>写模式加锁</li>
<li>不加锁</li>
</ul>
<p>多个进程可在读模式加锁时拥有锁状态，写模式为独占</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line">int pthread_rwlock_init (pthread_rwlock_t *<span class="variable">__restrict</span> <span class="variable">__rwlock</span>,</span><br><span class="line">				const pthread_rwlockattr_t *<span class="variable">__restrict</span></span><br><span class="line">				<span class="variable">__attr</span>) <span class="variable">__THROW</span> <span class="variable">__nonnull</span> ((<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_destroy (pthread_rwlock_t *<span class="variable">__rwlock</span>)</span><br><span class="line">     <span class="variable">__THROW</span> <span class="variable">__nonnull</span> ((<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>与之前的锁一样，使用前初始化，释放内存前销毁</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>“pthread.h”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>也与之前锁类似，但细分了rdlock、wrlock，trylock若加锁不会堵塞<br>而是返回EBUSY</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量与互斥量一起使用时，允许线程以无竞争的方式等待某个条件的发生</p>
<p>条件变量本身由互斥量保护，改变条件变量前必须锁住互斥量</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_cond_init(<span class="params">pthread_cond_t</span> <span class="operator">*</span><span class="params">restrict</span> <span class="params">cond</span>,<span class="params">const</span> <span class="params">pthread_condattr_t</span> <span class="operator">*</span><span class="params">restrict</span> <span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_cond_destroy(<span class="params">pthread_cond_t</span> <span class="operator">*</span><span class="params">cond</span>)</span>;</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化与销毁与互斥量类似<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">静态初始化</span><br><span class="line">pthread_cond_t cond = PTHREAD_COND_INITIALIZER<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>调用者把锁住的互斥量传给函数，函数自动把调用线程放到等待条件的线程列表上，对互斥量解锁。pthread_cond_wati返回时，互斥量再次被锁住。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回错误编号</span><br></pre></td></tr></table></figure>
<ul>
<li>用于唤醒满足条件的线程</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;pthread.h&gt;</span><br><span class="line"><span class="keyword">struct</span> msg &#123;</span><br><span class="line"><span class="keyword">struct</span> msg *m_next;</span><br><span class="line"><span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> msg *workq;</span><br><span class="line">pthread_cond_t qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">void</span><br><span class="line">process<span class="constructor">_msg(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> msg *mp;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">qlock</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span> (workq<span class="operator"> == </span>NULL)</span><br><span class="line">        pthread<span class="constructor">_cond_wait(&amp;<span class="params">qready</span>, &amp;<span class="params">qlock</span>)</span>;</span><br><span class="line">    mp = workq;</span><br><span class="line">    workq = mp-&gt;m_next;</span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">qlock</span>)</span>;</span><br><span class="line">    <span class="comment">/* now process the message mp */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void</span><br><span class="line">enqueue<span class="constructor">_msg(<span class="params">struct</span> <span class="params">msg</span> <span class="operator">*</span><span class="params">mp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">qlock</span>)</span>;</span><br><span class="line">    mp-&gt;m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">qlock</span>)</span>;</span><br><span class="line">    pthread<span class="constructor">_cond_signal(&amp;<span class="params">qready</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一个计数器，用于为多个进程提供对公共资源的访问</p>
<p>常用的信号量形式为二元信号量，控制一个资源，初始值为1。一般来说，信号量的初值可以是任意正值，代表有多少资源单位可供共享</p>
<p>它支持两个原子性操作: p()、v()</p>
<ul>
<li>p()会减少信号量，若新值小于0，则会堵塞调用者</li>
<li>v()会增加信号量，若新值大于等于0，则唤醒一个等待的线程或进程</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的<strong>阅读习惯</strong>一致。</p>
<p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p>
<p>Big-Endian: 低地址存放高位，如下：<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">　　---------------</span><br><span class="line">　　buf[<span class="number">3</span>] (<span class="number">0x78</span>) -- 低位</span><br><span class="line">　　buf[<span class="number">2</span>] (<span class="number">0x56</span>)</span><br><span class="line">　　buf[<span class="number">1</span>] (<span class="number">0x34</span>)</span><br><span class="line">　　buf[<span class="number">0</span>] (<span class="number">0x12</span>) -- 高位</span><br><span class="line">　　--------------- </span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></p>
<p>Little-Endian: 低地址存放低位，如下：<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">　　---------------</span><br><span class="line">　　buf[<span class="number">3</span>] (<span class="number">0x12</span>) -- 高位</span><br><span class="line">　　buf[<span class="number">2</span>] (<span class="number">0x34</span>)</span><br><span class="line">　　buf[<span class="number">1</span>] (<span class="number">0x56</span>)</span><br><span class="line">　　buf[<span class="number">0</span>] (<span class="number">0x78</span>) -- 低位</span><br><span class="line">　　--------------</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></p>
<p>共用体与结构体大小</p>
<ul>
<li>结构体变量所占内存长度是其中最大字段大小的整数倍（参考：<a href="https://www.runoob.com/w3cnote/struct-size.html" target="_blank" rel="noopener">结构体大小的计算</a>）。</li>
<li>共用体变量所占的内存长度等于最长的成员变量的长度</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[<span class="number">20</span>];</span><br><span class="line">&#125; data;  </span><br><span class="line">/<span class="regexp">/占20个字节，而不是20+4+4</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>flatpak入门指南</title>
    <url>/2020/03/10/flatpak%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>之所以会用到<code>flatpak</code>主要是突然想学学GTK,刚好有个亲生的IDE<code>gnome-builder</code>,安装有点小坑</p>
<h1 id="flatpak"><a href="#flatpak" class="headerlink" title="flatpak"></a>flatpak</h1><blockquote>
<p><a href="https://docs.flatpak.org/en/latest/introduction.html" target="_blank" rel="noopener">Flatpak</a> is a framework for distributing desktop applications on Linux. It has been created by developers who have a long history of working on the Linux desktop, and is run as an independent open source project.</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>几个概念需要了解一下<br><img src="/images/20200310=0.png" alt></p>
<ul>
<li>最底层的是我们的操作系统,往上是由不同的仓库所提供的runtime,也就是打包好的依赖项加上软件,这样就能做到安装即使用,不依赖具体的发行版,这个概念类似与<code>snap</code>和<code>.appimage</code>了</li>
<li>仓库就类似与git里的远程仓库,自带版本控制,可自由升级降级</li>
<li>对于安装的应用本身是运行在应用独占的沙盒里的,很好的做到了权限的分离,也用不着<code>sudo apt *</code>一把嗦了</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在mint19.2 上已经自带安装了，但默认是不可用的<a href="https://flatpak.org/setup/" target="_blank" rel="noopener">setup</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>查看当前仓库情况<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flatpak remotes</span></span><br></pre></td></tr></table></figure></p>
<p>添加一个新的仓库<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">flatpak remote-<span class="built_in">add</span> --<span class="keyword">if</span>-not-<span class="built_in">exists</span> flathub http<span class="variable">s:</span>//<span class="keyword">dl</span>.flathub.org/repo/flathub.flatpakrepo</span><br></pre></td></tr></table></figure></p>
<ul>
<li>语法也与git相似,<code>flathub</code>为给仓库取的别名,后面接的是相应url</li>
<li><code>--if-not-exists</code>防止重复添加相同的仓库</li>
</ul>
<p>删除一个仓库<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">flatpak remote-<span class="keyword">delete</span> flathub</span><br></pre></td></tr></table></figure></p>
<p>搜索新的软件<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">flatpak <span class="keyword">search</span> <span class="type">name</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>将会返回<code>Application ID</code>,<code>Version Branch</code>, <code>Remotes</code>, <code>Description</code>,依次是应用的id(后面安装的时候会用到),版本,仓库别名,描述</li>
</ul>
<p>安装卸载新的软件<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flatpak <span class="keyword">install</span> flathub(仓库别名) Application <span class="keyword">ID</span></span><br><span class="line"></span><br><span class="line">flatpak <span class="keyword">uninstall</span> Application <span class="keyword">ID</span></span><br></pre></td></tr></table></figure></p>
<p>查看已安装软件<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flatpak lists</span></span><br></pre></td></tr></table></figure></p>
<p>更新软件<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flatpak update</span></span><br></pre></td></tr></table></figure></p>
<p>至此已经可以愉快的玩耍了</p>
<h1 id="gnome-builder"><a href="#gnome-builder" class="headerlink" title="gnome-builder"></a>gnome-builder</h1><p>抱着多学知识<del>瞎折腾</del>的心态一开始选择了编译源码</p>
<p>然后成功见识到meson和ninja这套跨平台编译工具<del>下篇见</del>,折腾了一晚上后最终倒在不知名错误上</p>
<p>尝试自带软件源的gnome-builder又是个半残废,最后使用flatpak安装成功</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">flatpak install flathub org<span class="selector-class">.gnome</span><span class="selector-class">.Builder</span></span><br></pre></td></tr></table></figure>
<h3 id="解决不能使用暗间模式的问题"><a href="#解决不能使用暗间模式的问题" class="headerlink" title="解决不能使用暗间模式的问题"></a>解决不能使用暗间模式的问题</h3><p>由于是基于沙箱运行的程序,导致不能正确识别到自身主题控件,需要单独安装相应黑暗主题</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看主题</span></span><br><span class="line"><span class="attr">neofetch</span> <span class="string">| grep Theme</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索主题</span></span><br><span class="line"><span class="attr">flatpak</span> <span class="string">search name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="attr">flatpak</span> <span class="string">install * *</span></span><br></pre></td></tr></table></figure>
<p>此时黑暗主题可用</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>flatpak</tag>
        <tag>gnome-builder</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/04/25/hello-world/</url>
    <content><![CDATA[<p><em>Hello world</em></p>
]]></content>
  </entry>
  <entry>
    <title>docker使用笔记</title>
    <url>/2019/09/04/docker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于docker for windows</p>
<hr>
<a id="more"></a>
<p><a href="/download/容器第一讲Intro to Docker.pdf">学习资料</a></p>
<h1 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h1><blockquote>
<p>Docker 属于 <em>Linux 容器</em>的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
</blockquote>
<blockquote>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
</blockquote>
<blockquote>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
</blockquote>
<h4 id="windows-container"><a href="#windows-container" class="headerlink" title="windows container"></a>windows container</h4><p>大致分为两种</p>
<ul>
<li>Window Server Contianer  </li>
<li>Hyper-V Container</li>
</ul>
<p>Windows Container 只能运行 Windows应用程序</p>
<h4 id="与传统虚机差别"><a href="#与传统虚机差别" class="headerlink" title="与传统虚机差别"></a>与传统虚机差别</h4><ul>
<li>基于进程隔离，而非os</li>
<li>体积小</li>
<li>启动速度快</li>
<li>资源占用少</li>
</ul>
<h2 id="but"><a href="#but" class="headerlink" title="but"></a>but</h2><hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">links</a></p>
<hr>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>命令有普通命令和管理命令两种，后者更长但分组更加明确<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker ps  ===</span><br><span class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure></p>
<h4 id="配置加速器"><a href="#配置加速器" class="headerlink" title="配置加速器"></a>配置加速器</h4><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 未配置前</span></span><br><span class="line"> Client.Timeout exceeded <span class="keyword">while</span> awaiting headers</span><br><span class="line"></span><br><span class="line"><span class="meta"># 配置后</span></span><br><span class="line"> 很快</span><br></pre></td></tr></table></figure>
<ul>
<li>上<a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">https://cr.console.aliyun.com</a> 注册一个账号，开通加速器服务，得到一个镜像地址</li>
<li>再至deamon中填入<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://****.mirror.aliyuncs.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker pull training/webapp </span><br><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -P training/webapp python app.py</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这将从远程仓库下载镜像 (training为用户名,webapp为该用户下的webapp镜像)</li>
<li><p>-d 为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">Run</span> container <span class="keyword">in</span> background <span class="keyword">and</span> <span class="builtin-name">print</span> container ID</span><br></pre></td></tr></table></figure>
<p>-P 为</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">Publish <span class="literal">all</span> exposed ports <span class="keyword">to</span> <span class="keyword">random</span> ports</span><br></pre></td></tr></table></figure>
<p> -p 为手动映射</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">4999</span>:<span class="number">5000</span> training/webapp python app.py</span><br><span class="line"></span><br><span class="line"># <span class="number">4999</span> 为映射后的端口</span><br><span class="line"># <span class="number">5000</span> 为映射前的端口</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查看容器<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure></p>
<p>查看容器logs<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">docker logs (容器id 或 名字<span class="string">[非镜像名字]</span>)</span><br></pre></td></tr></table></figure></p>
<p>查看容器底层信息<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker inspect (<span class="built_in">name</span> <span class="keyword">or</span> <span class="built_in">id</span>)</span><br></pre></td></tr></table></figure></p>
<p>停止重启<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">start </span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">stop </span></span><br><span class="line"><span class="attr">docker</span> <span class="string">kill</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>stop kill的差别在于kill是强制停止,类似于kill -9</li>
<li>restart 只用于正在运行的</li>
</ul>
<p>删除<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker rm</span></span><br></pre></td></tr></table></figure></p>
<h4 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看已下载的镜像</li>
</ul>
<p><strong>搜索</strong><br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker search docker</span></span><br></pre></td></tr></table></figure></p>
<p><strong>下载(pull)</strong><br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull docker </span><br><span class="line">~~<span class="regexp">~ </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">**删除**</span></span><br><span class="line"><span class="regexp">~~~</span> </span><br><span class="line">docker rmi -f id</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-f(force) 为强制删除</li>
</ul>
<p><strong>新建镜像</strong></p>
<ol>
<li>通过已有镜像修改<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">docker commit <span class="comment">[OPTIONS]</span> <span class="keyword">CONTAINER</span> <span class="comment">[REPOSITORY<span class="comment">[:TAG]</span>]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>-a 指定作者</li>
<li>-m 描述</li>
</ul>
<hr>
<ol start="2">
<li>通过Dockerfile构建<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>从ubuntu:18.04 docker映像创建一个层。<br>从Docker客户端的当前目录复制添加文件。<br>run使用make构建应用程序。<br>cmd指定要在容器中运行的命令。</li>
<li>FROM等必须大写</li>
<li>Dockerfile是一行一行执行的</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>常用命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>指定基础镜像(id或name)</td>
</tr>
<tr>
<td>LABEL</td>
<td>添加元数据(以键值对传入)</td>
</tr>
<tr>
<td>ADD</td>
<td>将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源</td>
</tr>
<tr>
<td>COPY</td>
<td>与ADD类似，没有解压和访问网络资源功能</td>
</tr>
<tr>
<td>ENV</td>
<td>添加环境变量</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>对外暴露端口</td>
</tr>
<tr>
<td>VOLUME</td>
<td>设置共享卷</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>设置工作目录</td>
</tr>
<tr>
<td>CMD</td>
<td>运行容器后会执行的命令</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">官方示例</a><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nginx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span>      ubuntu</span><br><span class="line">LABEL <span class="attribute">Description</span>=<span class="string">"This image is used to start the foobar executable"</span> Vendor= \</span><br><span class="line"> <span class="string">"ACME Products"</span> <span class="attribute">Version</span>=<span class="string">"1.0"</span></span><br><span class="line"><span class="builtin-name">RUN</span> apt-<span class="builtin-name">get</span> update &amp;&amp; apt-<span class="builtin-name">get</span> install -y \ </span><br><span class="line">inotify-tools nginx apache2 openssh-server</span><br></pre></td></tr></table></figure></p>
<p><strong>构建镜像</strong><br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>[OPTIONS] PATH <span class="title">| URL |</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">docker</span> <span class="keyword">built </span>-t Dockerfile .</span><br></pre></td></tr></table></figure></p>
<ul>
<li>指定从当前目录下的Dockerfile构建</li>
</ul>
<p><strong>上传镜像</strong><br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">login</span></span><br><span class="line"></span><br><span class="line">docker push [<span class="keyword">OPTIONS</span>] <span class="type">NAME</span>[:TAG]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>http学习之路</title>
    <url>/2019/05/25/http%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在获取知识的渠道太多，也过于碎片化，时间一久，就只知道见过查过单纯有印象了，就像目前我对<del>很多英语单词</del>的印象😭，现在有时间有机会将其串在一起吧</p>
<blockquote>
<p><a href="https://www.google.com/search?ei=WR7pXK-ZGNGFyAO49KDIDA&amp;q=http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97&amp;oq=http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97&amp;gs_l=psy-ab.3..35i39j0j0i12j0j0i12j0l5.8205.9618..9967...0.0..0.308.645.1j2j0j1....2..0....1..gws-wiz.......0i333.h_zabZXMgrY" target="_blank" rel="noopener">http权威指南</a> </p>
</blockquote>
<hr>
<h1 id="HTTP权威指南"><a href="#HTTP权威指南" class="headerlink" title="HTTP权威指南"></a>HTTP权威指南</h1><h6 id="文字部分仅做补充"><a href="#文字部分仅做补充" class="headerlink" title="文字部分仅做补充"></a>文字部分仅做补充</h6><h4 id="HTTP-Web的基础"><a href="#HTTP-Web的基础" class="headerlink" title="HTTP :Web的基础"></a>HTTP :Web的基础</h4><p><img src="/images/20190525=1.png" alt="http概述"></p>
 <a id="more"></a>
<p><img src="/images/20190525=2.png" alt="HTTP报文"> </p>
<blockquote>
<p>在报文中显示的时间是GMT标准时间，要换算成本地时间  如北京是在东八区，北京时间就是GMT+8</p>
</blockquote>
<p><div class="thetimenow-embeddable-clock" data-type="clock" data-font-color="#000000" data-border-color="#000000" data-background-color="#ffffff" data-font-size="60" data-location-type="timezone" data-location-id="17"> </div> </p>
<script type="text/javascript" src="http://zh.thetimenow.com/ttn-embed.min.js"></script>

<p><img src="/images/20190525=3.png" alt="连接管理"> </p>
<h4 id="HTTP-结构"><a href="#HTTP-结构" class="headerlink" title="HTTP 结构"></a>HTTP 结构</h4><p><img src="/images/20190525=4.png" alt="HTTP结构"><br><img src="/images/20190525=5.png" alt="HTTP结构"> </p>
<h4 id="识别认证和安全"><a href="#识别认证和安全" class="headerlink" title="识别认证和安全"></a>识别认证和安全</h4><p><img src="/images/20190525=6.png" alt="识别认证和安全"> </p>
<table>
<thead>
<tr>
<th style="text-align:center">OSI参考模型</th>
<th style="text-align:center">tcp/ip参考模型</th>
<th style="text-align:center">https安全层</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">安全层</td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">传输层</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">物理层</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="实体编码和国际化"><a href="#实体编码和国际化" class="headerlink" title="实体编码和国际化"></a>实体编码和国际化</h4><p><img src="/images/20190525=7.png" alt="实体编码和国际化"> </p>
<blockquote>
<p>有时候国际化(internationalization)简称i18n,18代表省略了18个字母</p>
</blockquote>
<h5 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h5><p><img src="/images/20190525=8.png" alt="报文实例分析"> </p>
<p>zh-hans 代表简体中文 ，包括香港使用的简中<br>zh-hans-CN 中国大陆使用的简体中文<br>0.0&lt;q(质量值)&lt;1.0 0.0表示不接受 1.0表示最乐意接受</p>
<h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><p><img src="/images/http权威指南.png" alt="HTTP权威指南"><br><a href="https://github.com/oneto1/oneto1.github.io/blob/master/images/http权威指南.png" target="_blank" rel="noopener">完整版链接</a></p>
<hr>
<p><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous"></p>
<body>

<p><i class="fas fa-vial"></i></p>
<body></body></body>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX下进程环境与控制学习</title>
    <url>/2019/10/01/UNIX%E4%B8%8B%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="built_in">argc</span>,char *<span class="built_in">argv</span>[])</span><br></pre></td></tr></table></figure>
<ul>
<li>c语言程序从main()开始执行</li>
<li>argc指命令行参数数目，argv指向命令行参数指针</li>
<li>argv[argc]为一个空指针</li>
</ul>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ol>
<li>正常终止</li>
</ol>
<ul>
<li>从main()返回</li>
<li>调用exit()</li>
<li>调用_exit()或_Exit()</li>
<li>最后一个线程从器其启动例程返回</li>
<li>从最后一个线程调用pthread_exit</li>
</ul>
<ol start="2">
<li>非正常终止</li>
</ol>
<ul>
<li>调用abort()</li>
<li>接到一个信号</li>
<li>最后一个线程响应取消请求</li>
</ul>
<blockquote>
<p>关于线程部分之后再写</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> __status)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> _<span class="title">Exit</span><span class="params">(<span class="keyword">int</span> __status)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> _<span class="title">exit</span><span class="params">(<span class="keyword">int</span> __status)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>_exit()和_Exit()立即进入内核,exit()则会先进行相关清理操作,如fclose、flush等</li>
<li>这三个函数都带一个整型参数，称作终止状态或退出状态</li>
<li>main()的返回类型是int，且main执行到最后一条语句隐式返回(没有用return或exit)，那么其终止状态为0</li>
<li>main()返回的整数值等同于用该值调用exit()，即exit(0) == return (0)</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> atexit(<span class="keyword">void</span> (*__func)(<span class="keyword">void</span>))</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>，失败返回非<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该函数用于登记终止处理函数(exit handler)，由exit()调用，其执行顺序与登记顺序相反<br><img src="/images/20191001=0.png" alt></li>
</ul>
<h3 id="存储空间布局"><a href="#存储空间布局" class="headerlink" title="存储空间布局"></a>存储空间布局</h3><p><img src="/images/20191001=1.png" alt></p>
<ul>
<li>正文段保存的是只读的机器指令</li>
<li>初始化数据段称为数据段，存放的是非函数任何形式的数据，形如 int num=1</li>
<li>未初始化数据段被称为bss段，存放的形如 char str[50] ,程序开始执行时被内核初始化为0或空指针</li>
<li>栈，自动变量及每次函数调用所需信息保存于此。</li>
<li>堆，用于动态存储分配</li>
</ul>
<h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include”stdlib.h"</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *malloc(size_t __size)</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *calloc(size_t __nmemb, size_t __size)</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *realloc(<span class="type">void</span> *__ptr, size_t __size)</span><br><span class="line"></span><br><span class="line">成功返回非<span class="number">0</span>指针，失败返回<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li>所返回的是  void * ，也叫通用指针</li>
<li>大部分实现其存储空间分配会比所要求空间稍大，额外的空用于记录管理信息————分配块长度、指向下一个分配块指针等</li>
<li>程序结束前记得用free()</li>
</ul>
<hr>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> getpid(<span class="keyword">void</span>)            返回pid</span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> getppid(<span class="keyword">void</span>)          返回父id</span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> getuid(<span class="keyword">void</span>)            返回进程的实际用户id</span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> geteuid(<span class="keyword">void</span>)           返回有效id</span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> getgid(<span class="keyword">void</span>)            返回实际组id</span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> getegid(<span class="keyword">void</span>)           返回有效组id</span><br></pre></td></tr></table></figure>
<ul>
<li>pid为0的被叫做调度进程也叫交换进程，该进程为内核的一部分，它不执行磁盘上的任何程序，为系统进程</li>
<li>pid为1的是init进程，它负责自举内核后启动UNIX系统，它会成为所有孤儿进程的父进程，称这些进程被init进程收养</li>
</ul>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">__pid_t</span> fork(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">成功子进程返回<span class="number">0</span>，父进程返回子进程id，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子进程是父进程的副本，拥有相同的数据段、堆、栈，但不是共享的,共享的是正文段</li>
<li>子进程与父进程的执行顺序取决于内核的调度算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hi\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i'm child!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i'm father\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this is a test%d\n"</span>,i++);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; gcc test.c &amp;&amp; ./a.out </span><br><span class="line"></span><br><span class="line">hi</span><br><span class="line">i'm father</span><br><span class="line">i'm child!</span><br><span class="line"><span class="keyword">this</span> is a test0</span><br><span class="line"><span class="keyword">this</span> is a test0</span><br><span class="line"></span><br><span class="line">&gt; gcc test.c &amp;&amp; ./a.out &gt; test &amp;&amp; cat test</span><br><span class="line"></span><br><span class="line">hi</span><br><span class="line">i'm father</span><br><span class="line"><span class="keyword">this</span> is a test0</span><br><span class="line">hi</span><br><span class="line">i'm child!</span><br><span class="line"><span class="keyword">this</span> is a test0</span><br></pre></td></tr></table></figure>
<ul>
<li>从这个实例可以看出父进程与子进程之间并不共享变量即数据段</li>
<li>子进程继承父进程的输出重定向</li>
<li><p>为什么之前hi只输出了一次？</p>
<ol>
<li>这是因为标准I/O默认是带缓冲的(默认为全缓冲 终端设备为行缓冲)而这里(指的是shell即终端)的\n 刷洗了缓冲，导致只输出了一次hi</li>
<li>flush有两种意思。在标准I/O库方面，flush以为这将缓冲区中的内容写到磁盘上。在终端驱动程序方面flush表示丢弃已存储在缓冲区中的数据</li>
<li>而第二个重定向至文本却有两个hi ，这是因为在fork()之前就已经被缓冲了，fork()之后便有两个带缓冲的程序输出被重定向至文件</li>
</ol>
</li>
</ul>
<p><img src="/images/20191001=2.png" alt></p>
<ul>
<li>这里fd0、1、2对应stdin、stdout、stderr</li>
</ul>
<p><img src="/images/20191001=3.png" alt></p>
<ul>
<li>父子进程完整继承关系</li>
</ul>
<p><em>fork()的两种常见用法</em></p>
<ol>
<li>fork()自身以完成不同的事情</li>
<li>fork()后执行exec()执行不同程序。如shell</li>
</ol>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>调用wait()、waitpid()可能会出现的情况：</p>
<ul>
<li>子进程还在运行，则发生堵塞</li>
<li>一个子进程已终止，正等待父进程获取其终止状态，则获得该子进程终止状态并返回</li>
<li><p>它没有任何子进程，则立即出错返回</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"sys/wait.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">__pid_t</span> wait(int *<span class="variable">__stat_loc</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">__pid_t</span> waitpid(<span class="variable">__pid_t</span> <span class="variable">__pid</span>, int *<span class="variable">__stat_loc</span>, int <span class="variable">__options</span>)</span><br><span class="line"></span><br><span class="line">成功返回进程id，失败返回<span class="number">0</span>或-<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__stat_loc为一个整型指针，用于存放退出状态，若不在意其退出状态，可设为NULL</p>
</li>
<li>在一个进程结束前，wait()使调用者堵塞，而waitpid()有一选项，可使其不堵塞</li>
<li>wait()是waitpid()的一种特殊情况</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">pid参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pid==-1</td>
<td style="text-align:center">等待任意一个子进程 ==wait()</td>
</tr>
<tr>
<td style="text-align:center">pid&gt;0</td>
<td style="text-align:center">等待进程id等于pid的子进程</td>
</tr>
<tr>
<td style="text-align:center">pid==0</td>
<td style="text-align:center">等待组id等于调用进程组id的任一子进程</td>
</tr>
<tr>
<td style="text-align:center">pid&lt;-1</td>
<td style="text-align:center">等待组id等于pid绝对值的任一子进程</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">__option(常量)</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WCONTINUED (0)</td>
<td style="text-align:center">若该实现支持作业控制，那么由pid指定的子进程在停止后已经继续，但其状态尚未报告，则返回状态   </td>
</tr>
<tr>
<td style="text-align:center">WNOHANG (1)</td>
<td style="text-align:center">若pid指定的子进程立即不可用，则waitpid不堵塞，而返回0</td>
</tr>
<tr>
<td style="text-align:center">WUNTRACEO (2)</td>
<td style="text-align:center">若该实现支持作业控制，那么由pid指定的子进程已在停止状态，且自停止以来没有报告过状态，则返回其状态  </td>
</tr>
</tbody>
</table>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="string">"sys/wait.h"</span>    </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="string">"unistd.h"</span>  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="string">"stdlib.h"</span>  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="string">"stdio.h"</span></span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">int</span> main()  </span><br><span class="line">      </span><br><span class="line">    &#123;  </span><br><span class="line">      </span><br><span class="line">    pid_t pc,pr<span class="comment">;  </span></span><br><span class="line">      </span><br><span class="line">    pc=fork()<span class="comment">;  </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)                   </span><br><span class="line">      </span><br><span class="line">        printf(<span class="string">"error ocurred!\n"</span>)<span class="comment">;  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc==<span class="number">0</span>)&#123;            </span><br><span class="line">      </span><br><span class="line">            printf(<span class="string">"This is child process with pid of %d\n"</span>,getpid())<span class="comment">;  </span></span><br><span class="line">      </span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>)<span class="comment">;        </span></span><br><span class="line">      </span><br><span class="line">                &#125;  </span><br><span class="line">      </span><br><span class="line">            <span class="keyword">else</span>&#123;                     </span><br><span class="line">      </span><br><span class="line">                pr=waitpid(pc,<span class="literal">NULL</span>,<span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line">      </span><br><span class="line">                printf(<span class="string">"I catched a child process with pid of %d\n"</span>,pr)<span class="comment">;</span></span><br><span class="line">      </span><br><span class="line">                &#125;                 </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; This is child process <span class="keyword">with</span> pid of <span class="number">2390</span></span><br><span class="line">I catched a child process <span class="keyword">with</span> pid of <span class="number">2390</span></span><br></pre></td></tr></table></figure>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">const</span> <span class="keyword">char</span> *arg0,... <span class="comment">/* (char *)0 */</span> )</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">const</span> <span class="keyword">char</span> *arg0,... <span class="comment">/* (char *)0, char *const envp[] */</span> )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename,<span class="keyword">const</span> <span class="keyword">char</span> *arg0,... <span class="comment">/* (char *)0 */</span> )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename,<span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line">成功不返回，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这七个函数统称exec函数，其调用不创建新进程，只是用一个新程序替换当前进程的正文段、数据段、堆、栈</li>
<li>指定filename时，若带/ 则被看作pathname，否则按PATH环境变量寻找程序</li>
<li>execl、execle、execlp说明最后一个参数后接一个空指针((char*)0),否则会出错</li>
<li>exec后的字母l表示list，v表示vector(矢量)，即关系到参数的传入方法，带l的用列表传入，带v的用指针数组传入</li>
<li>函数名末尾带e的与传递环境表有关，带e的可手动指定环境表，不带e的复制现有环境</li>
</ul>
<p><img src="/images/20191001=4.png" alt></p>
<ul>
<li>只有execve()是系统调用，其他6个都要调用该系统调用实现</li>
</ul>
<h3 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h3><p>解释器文件是文本文件，其形式是<br><figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! pathname[optinal-argument]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>对这种文件的识别是通过内核调用exec实现的</li>
<li>内核使调用exec函数的进程实际执行的不是解释器文本，而是第一行pathname指定的文件</li>
</ul>
<h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> system(<span class="keyword">const</span> <span class="keyword">char</span> *__command)</span><br><span class="line"></span><br><span class="line">返回值有多种情况</span><br></pre></td></tr></table></figure>
<ul>
<li>system()在其实现时调用了fork()、exec()、waitpid(),故有3种返回值<ol>
<li>fork()失败或waitpid()除了EINTR之外的错误，则返回-1,并设置errno指示错误类型</li>
<li>exec()失败(表示不能执行)，返回值为exit(127).   /bin/sh当在PATH系统变量中未找到给定命令且它不是内置的shell命令时，将返回值127。换句话说，系统不理解您的命令，因为它不知道在哪里找到您要调用的二进制文件</li>
<li>除非fork、exec、waitpid都成功，否则返回值为waitpid的返回值</li>
</ol>
</li>
</ul>
<p><img src="/images/20191001=5.png" alt></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下终端复用利器tmux使用</title>
    <url>/2019/05/30/linux-%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%88%A9%E5%99%A8tmux%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="tmux安装"><a href="#tmux安装" class="headerlink" title="tmux安装"></a>tmux安装</h2><h4 id="ubuntu下"><a href="#ubuntu下" class="headerlink" title="ubuntu下"></a>ubuntu下</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="centos6"><a href="#centos6" class="headerlink" title="centos6"></a>centos6</h4><p>centos6下需编译安装<del>当时不知道</del><br><a href="http://tmux.github.io/" target="_blank" rel="noopener">tmux官网</a></p>
<h4 id="centos7下"><a href="#centos7下" class="headerlink" title="centos7下"></a>centos7下</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="tmux-使用"><a href="#tmux-使用" class="headerlink" title="tmux 使用"></a>tmux 使用</h2><p>进入tmux<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tmux</span></span><br></pre></td></tr></table></figure></p>
<p>上下分屏<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="selector-tag">b</span> <span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>左右分屏<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ctrl</span>+<span class="keyword">b </span>%</span><br></pre></td></tr></table></figure></p>
<p>切换默认布局<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ctrl</span>+<span class="keyword">b </span><span class="meta">space</span></span><br></pre></td></tr></table></figure></p>
<p>退出对话(被缓存在后台)<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="selector-tag">b</span> d</span><br></pre></td></tr></table></figure></p>
<p>恢复对话<br><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ba<span class="symbol">sh:</span> tmux a -<span class="built_in">t</span> <span class="number">0</span>(会话名称)</span><br><span class="line">其中a字母是attach的头字母，表示附加， -<span class="built_in">t</span> 指定要进入已存在的会话名</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20190530=1.png" alt="示例"></p>
<p>退出tmux<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="keyword">b </span>&amp;   <span class="keyword">or </span> ctrl+<span class="keyword">b </span>: kill-session -t <span class="number">0</span></span><br><span class="line"><span class="keyword">bash: </span>tmux kill-session -t <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>查看tmux会话列表<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ctrl</span>+<span class="keyword">b </span>s</span><br><span class="line"><span class="keyword">bash: </span>tmux ls</span><br></pre></td></tr></table></figure></p>
<p>重命名会话<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ctrl</span>+<span class="keyword">b </span>$</span><br><span class="line"><span class="keyword">bash: </span>tmux rename -t old_session_name  new_session_name</span><br></pre></td></tr></table></figure></p>
<p>新建自定义名字会话<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">bash:</span> tmux <span class="keyword">new</span> -s <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<p>切换不同窗口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+方向键</span><br><span class="line">ctrl+窗口名</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20190530=2.png" alt="示例"></p>
<p>调整窗口大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+b+方向键</span><br></pre></td></tr></table></figure></p>
<p>增加鼠标支持, 可用鼠标选择调整窗口<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">在~下新建.tmux.conf</span><br><span class="line"><span class="keyword">set</span> -g mouse <span class="keyword">on</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>之前遇到某个命令耗时太长使用的是nohug 现在就可以直接ctrl+b d就好<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">nohup <span class="keyword">command</span> &amp;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>apt与apt-get区别？<br>apt-get先于apt，或apt比apt-get”先进”<br>apt-get的操作比apt更低级<br>apt-get 常用操作apt都有</p>
</li>
<li><p>查询软件版本</p>
<pre><code>rpm -qa | grep *    查询系统中安装的所有RPM软件包
dpkg -l *
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
        <tag>tmux</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 命令杂记</title>
    <url>/2020/04/01/linux-%E5%91%BD%E4%BB%A4%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>根据某个字符串，查询该字符串前后文本信息命令：grep-A|B n”key”file</p>
<p>其中：<br>    A：表示在字符串之后 after  context<br>    B：表示在字符串之前 before context<br>    n：要获取多少行文本 line number</p>
<p>实例：grep -A 100 -B 100 -i ‘111’ catalina.out</p>
<ul>
<li>-i表示忽略大小写。</li>
</ul>
<p>当然，如果我们想获取异常日志的前10行和后10行，不用加-A和-B，使用如下命令就可以了：</p>
<ul>
<li>实例：grep -10 -i ‘111’ catalina.out</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>mke2fs -t ext4 /dev/name</p>
<p>mkfs<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mkfs           mkfs<span class="selector-class">.cramfs</span>    mkfs<span class="selector-class">.ext3</span>      mkfs<span class="selector-class">.hfs</span>       mkfs<span class="selector-class">.minix</span>     mkfs.reiserfs</span><br><span class="line">mkfs<span class="selector-class">.bfs</span>       mkfs<span class="selector-class">.exfat</span>     mkfs<span class="selector-class">.ext4</span>      mkfs<span class="selector-class">.hfsplus</span>   mkfs<span class="selector-class">.msdos</span>     mkfs<span class="selector-class">.vfat</span>    </span><br><span class="line">mkfs<span class="selector-class">.btrfs</span>     mkfs<span class="selector-class">.ext2</span>      mkfs<span class="selector-class">.fat</span>       mkfs<span class="selector-class">.jfs</span>       mkfs<span class="selector-class">.ntfs</span>      mkfs.xfs</span><br></pre></td></tr></table></figure></p>
<h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p>rsync </p>
<blockquote>
<p>  Transfer files either to or from a remote host (not between two remote hosts).<br>  Can transfer single files, or multiple files matching a pattern.</p>
<ul>
<li>可用来转移数据,传输文件</li>
</ul>
</blockquote>
<p><code>rsync -av</code>原地址 目的地址</p>
<ul>
<li>a包含文件所有信息(This is equivalent to -rlptgoD),如原本权限,修改时间,子目录等等</li>
<li>v为显示传输过程,P为更为详细的信息输出</li>
</ul>
<p>既可以拉取数据,也可以发送数据<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Pull</span>: <span class="selector-tag">rsync</span> <span class="selector-attr">[OPTION...]</span> <span class="selector-attr">[USER@]</span><span class="selector-tag">HOST</span><span class="selector-pseudo">:SRC...</span> <span class="selector-attr">[DEST]</span></span><br><span class="line"><span class="selector-tag">Push</span>: <span class="selector-tag">rsync</span> <span class="selector-attr">[OPTION...]</span> <span class="selector-tag">SRC</span>... <span class="selector-attr">[USER@]</span><span class="selector-tag">HOST</span><span class="selector-pseudo">:DEST</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>查看分区信息<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">fdisk</span> <span class="string">-l</span></span><br><span class="line"></span><br><span class="line"><span class="attr">df</span> <span class="string">-h</span></span><br></pre></td></tr></table></figure></p>
<p>具体分区操作<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">fdisk /dev/设备名</span><br><span class="line"></span><br><span class="line"><span class="symbol">:p</span>  查看设备分区情况</span><br><span class="line"><span class="symbol">:F</span>  查看设备未分区的块</span><br><span class="line"><span class="symbol">:d</span>  删除一个分区</span><br><span class="line"><span class="symbol">:n</span>  建立一个分区</span><br></pre></td></tr></table></figure></p>
<ul>
<li>创建完分区记得创建文件系统</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>resize2fs   /dev/mapper/cl00-root  </p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><a href="https://www.cnblogs.com/FengGeBlog/p/10239067.html" target="_blank" rel="noopener">https://www.cnblogs.com/FengGeBlog/p/10239067.html</a></p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>开机自动挂载需修改<code>/etc/fstab</code></p>
<h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>blkid /dev/name</p>
<h1 id="grub"><a href="#grub" class="headerlink" title="grub"></a>grub</h1><p>quit 为简单输出<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">GRUB_CMDLINE_LINUX_DEFAULT</span>=<span class="string">"quiet splash"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>为默认启动内核参数,一直有效(包括救援模式)</li>
<li>splash 为显示linux发行版logo</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">GRUB_CMDLINE_LINUX</span>=</span><br></pre></td></tr></table></figure>
<ul>
<li>为救援模式的启动参数</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/</span><span class="keyword">default</span>/grub</span><br><span class="line">update-grub</span><br></pre></td></tr></table></figure>
<p>或在开机出现logo前按ESC再按e可修改启动参数(本次启动有效)</p>
<h1 id="brightness"><a href="#brightness" class="headerlink" title="brightness"></a>brightness</h1><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo </span><span class="string">systemctl </span><span class="built_in">list-units</span> | <span class="string">grep </span><span class="string">backlight</span></span><br></pre></td></tr></table></figure>
<ul>
<li>发现一个启动失败,可能是发生了冲突</li>
</ul>
<p>禁用其一<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sudo systemctl mask systemd-backlight<span class="meta">@backlight</span>:acpi_video0.service </span><br><span class="line">Created symlink <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>systemd-backlight<span class="meta">@backlight</span>:acpi_video0.service → <span class="regexp">/dev/</span></span><br><span class="line"><span class="literal">null</span>.</span><br></pre></td></tr></table></figure></p>
<p>重启另外一个<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart systemd-backlight<span class="variable">@backlight</span><span class="symbol">:nvidia_0</span>.service</span><br></pre></td></tr></table></figure></p>
<ul>
<li>重启机器发现亮度已经可以正常恢复</li>
</ul>
<h1 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">systemd-<span class="keyword">analyze</span>  </span><br><span class="line"></span><br><span class="line">systemd-<span class="keyword">analyze</span> blame</span><br><span class="line"></span><br><span class="line">systemd-<span class="keyword">analyze</span> <span class="keyword">critical</span>-<span class="keyword">chain</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以根据以上命令输出关闭一些不常用服务以加速开机 `systemctl mask(disable)</li>
<li>有些服务需要用但就是慢可以尝试手动修改 <code>服务名.service</code>文件,将其加上<code>After = graphical.target</code>,也就是在先等桌面加载玩再加载服务</li>
</ul>
<h1 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h1><h3 id="NAT转换"><a href="#NAT转换" class="headerlink" title="NAT转换"></a>NAT转换</h3><p>在虚拟机上部署zabbix时,虚拟机使用了NAT网桥,<code>telnet</code>能通,当server一直连不上</p>
<ul>
<li>最后在agent配置文件上server的地址加上网关地址<br><a href="https://sysadmin.xyz/main/2018/01/08/zabbix-nat-problem/" target="_blank" rel="noopener">https://sysadmin.xyz/main/2018/01/08/zabbix-nat-problem/</a></li>
</ul>
<h3 id="snmp"><a href="#snmp" class="headerlink" title="snmp"></a>snmp</h3><p>安装使用</p>
<ul>
<li><a href="http://www.net-snmp.org/wiki/index.php/Tutorials" target="_blank" rel="noopener">http://www.net-snmp.org/wiki/index.php/Tutorials</a></li>
<li><a href="https://blog.csdn.net/bbwangj/article/details/80981098" target="_blank" rel="noopener">https://blog.csdn.net/bbwangj/article/details/80981098</a></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.1 161<span class="built_in"> Connection </span>refused</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定用udp扫描端口161</span></span><br><span class="line">nmap -sU 192.168.1.1 -p161</span><br></pre></td></tr></table></figure>
<h1 id="lol安装"><a href="#lol安装" class="headerlink" title="lol安装"></a>lol安装</h1><p><a href="https://www.reddit.com/r/leagueoflinux/comments/alfbep/league_on_linux_mint_19/" target="_blank" rel="noopener">https://www.reddit.com/r/leagueoflinux/comments/alfbep/league_on_linux_mint_19/</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> snapd</span><br><span class="line"></span><br><span class="line">snap <span class="keyword">install</span> leagueoflegends <span class="comment">--edge --devmode</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>很简单粗暴,没有国服</p>
</li>
<li><p>Please consider using the Nouveau driver instead.<br><a href="https://askubuntu.com/questions/267936/how-do-i-get-rid-of-broken-nvidia-randr-detected-falling-back-to-randr-1-0" target="_blank" rel="noopener">https://askubuntu.com/questions/267936/how-do-i-get-rid-of-broken-nvidia-randr-detected-falling-back-to-randr-1-0</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>linxu</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro解决xbox手柄蓝牙问题</title>
    <url>/2020/05/01/manjaro%E4%B8%8B%E8%A7%A3%E5%86%B3%E8%93%9D%E7%89%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>安装依赖<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> pacman -S dkms linux-headers <span class="keyword">bluez </span><span class="keyword">bluez-utils</span></span><br></pre></td></tr></table></figure></p>
<p>查看内核是否加载了蓝牙模块<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">lsmod | grep btusb</span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">btusb                  <span class="number">65536</span>  <span class="number">0</span></span><br><span class="line">btrtl                  <span class="number">24576</span>  <span class="number">1</span> btusb</span><br><span class="line">btbcm                  <span class="number">16384</span>  <span class="number">1</span> btusb</span><br><span class="line">btintel                <span class="number">28672</span>  <span class="number">1</span> btusb</span><br><span class="line">bluetooth             <span class="number">671744</span>  <span class="number">39</span> btrtl,btintel,btbcm,bnep,btusb,rfcomm</span><br></pre></td></tr></table></figure></p>
<p>安装驱动<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/tmp</span></span><br><span class="line">git clone https:<span class="string">//github.com/atar-axis/xpadneo.git</span></span><br><span class="line"><span class="keyword">cd</span> xpadneo </span><br><span class="line">sudo <span class="string">.install.sh</span></span><br></pre></td></tr></table></figure></p>
<p>此时连接蓝牙<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">bluetoothctl</span><br><span class="line"></span><br><span class="line">&gt;scan</span><br><span class="line"><span class="comment"># 此时会出现新扫描出来的设备 </span></span><br><span class="line">[NEW] Device C8:3F:2A:7A:FB:4A Xbox<span class="built_in"> Wireless </span>Controller</span><br><span class="line"></span><br><span class="line">&gt;pair mac地址</span><br><span class="line">&gt;trust mac地址</span><br><span class="line">&gt;connect mac地址</span><br></pre></td></tr></table></figure></p>
<ul>
<li>当手柄震动且西瓜灯常亮就应经连接成功了</li>
</ul>
<hr>
<p>关于蓝牙耳机连接上了，但播放没有声音，重启一下服务可以解决<code>systemctl restart bluetooth</code></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>md+git+hexo简单使用</title>
    <url>/2019/04/27/md+git+hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h1 id="md篇"><a href="#md篇" class="headerlink" title="md篇"></a>md篇</h1><p>md全称markdown，一种纯文本标记语言</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">...</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>代码块用3个`包住</p>
<blockquote>
<p>单行代码用1个`包住</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p> <code>用&gt;开始，可多个&gt;嵌套，效果如上</code></p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">*<span class="strong">*加粗*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>斜体<span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>*<span class="strong">*斜体加粗*</span>*<span class="strong">*</span></span><br><span class="line"><span class="strong">~~删除线~~</span></span><br></pre></td></tr></table></figure>
<p><strong>加粗</strong>  <em>斜体</em>  <strong><em>斜体加粗</em></strong>  <del>~删除线</del>~ </p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">***或<span class="comment">---</span></span><br></pre></td></tr></table></figure>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="params">|2|</span><span class="number">3</span></span><br><span class="line"><span class="symbol">:---</span><span class="symbol">:|</span><span class="symbol">:---</span><span class="symbol">:|</span><span class="symbol">:---</span><span class="symbol">:</span></span><br><span class="line"><span class="number">4</span><span class="params">|5|</span><span class="number">6</span></span><br><span class="line">第<span class="number">2</span>行两个<span class="params">|之间的：用于格式对齐</span></span><br><span class="line"><span class="params">只有左边则靠左对齐，都有居中</span></span><br></pre></td></tr></table></figure>
<h3 id="超链接或图片"><a href="#超链接或图片" class="headerlink" title="超链接或图片"></a>超链接或图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名字</span>](<span class="link">"地址"</span>)</span><br><span class="line">[<span class="string">baidu</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line">![<span class="string">我是图</span>](<span class="link">/images/我是图.png</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">baidu</a><br><img src="/images/我是图.png" alt="我是图"></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">无序:-(+)(*) 内容</span><br><span class="line">有序:<span class="number">1.</span>内容</span><br><span class="line">     <span class="number">2.</span> 内容</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<ul>
<li>内容</li>
</ul>
<ol>
<li>内容</li>
<li>内容</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>可html嵌套</li>
<li>vscode大法好</li>
</ul>
<hr>
<h1 id="git篇"><a href="#git篇" class="headerlink" title="git篇"></a>git篇</h1><p>git 分布式版本控制系统 </p>
<blockquote>
<p><a href="https://www.runoob.com/manual/git-guide/" target="_blank" rel="noopener">git - 简明指南</a></p>
</blockquote>
<p>刚刚刚算是先入门吧</p>
<p>记录下简单常用的吧：</p>
<ul>
<li>1.git init 初始化新仓库<br>2.git add * 提交更改(到暂存区)<br>3.git commit 提交(到head)<br>4.git push origin master 正式提交 </li>
<li><p>git clone url </p>
<p>   <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">有空得多看看</a></p>
</li>
</ul>
<hr>
<h1 id="hexo篇"><a href="#hexo篇" class="headerlink" title="hexo篇"></a>hexo篇</h1><p>一款基于Node.js的静态博客框架</p>
<ul>
<li><p>常用命令<br>hexo init 初始化<br>hexo clean 清除生成的静态文件<br>hexo generate 生成静态文件<br>hexo s 开启本地服务端预览<br>hexo deploy 部署<br>npm install 插件名字 –save</p>
</li>
<li><p>小心得</p>
</li>
</ul>
<ol>
<li>主文件夹下_config.yml 全局配置</li>
<li>主题文件夹下_config.yml 具体配置</li>
<li>配置文件中:后要加一个空格</li>
<li>修改背景颜色到themes\next\source\css_schemes\Pisces 修改background: none(透明)</li>
<li>文章太长默认页面不好看 可在适当位置加<code>&lt;!-- more --&gt;</code></li>
</ol>
<ul>
<li><strong>如何理解分类与标签</strong><br>在source建立categories(分类)文件夹和tags(标签)文件夹，分别建立一个index.md<br>如分类图<img src="/images/分类文件实例.png" alt="实例图"><br>type: categories  或 type: tags</li>
</ul>
<p>之后写新文章时则将type替换成categouise或tags，表示给文章加上分类或标签,后面的: 则加具体的分类名或标签名<br>例如本文</p>
<blockquote>
<p>categories: 学习</p>
</blockquote>
<h3 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h3><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">参考的这个</a><br><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">github</a></p>
<hr>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p><del>比想象中要累</del> 时间总是这么的不够用，终归还算是有所收获</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>linux 软件安装踩坑记</title>
    <url>/2019/12/21/linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>终于在一个双眼朦胧头脑发胀的下午，将w10给格了，于是乎转入linux怀抱</p>
<p>考虑到Ubuntu有着良好的社区支持，于是乎选择了基于Ubuntu的Mint</p>
<p><a href="https://www.linuxmint.com/" target="_blank" rel="noopener">linuxmint</a></p>
<p><img src="/images/20191221=0.png" alt></p>
<p>经过简单设置其实感觉还不错，就是感受到对高分屏的深深恶意<del>字贼小</del><br>好在支持快捷键对应用进行缩放<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">ctrl + shift + + ( <span class="name">-</span> )</span><br></pre></td></tr></table></figure></p>
<h1 id="正常安装篇"><a href="#正常安装篇" class="headerlink" title="正常安装篇"></a>正常安装篇</h1><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>安装系统后，当然第一时间就是去换个本地源了</p>
<p><img src="/images/20191221=1.png" alt><br><img src="/images/20191221=2.png" alt><br>对于系统自带软件更新软件，好就好在可以不用自己去找源了，也可以方便找个速度快的</p>
<p>加上deepin的源，方便安装微信等<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//deepin-wine.i-<span class="keyword">m</span>.dev/setup.<span class="keyword">sh</span> | sudo <span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<p>最后<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a>安装输入法</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt <span class="keyword">install</span> fcitx fcitx-googlepinyin</span><br></pre></td></tr></table></figure>
<p>没有问题的话此时可用<code>ctrl + space</code>切换输入法了</p>
<h3 id="安装google浏览器"><a href="#安装google浏览器" class="headerlink" title="安装google浏览器"></a>安装google浏览器</h3><p>已经习惯了登录账号同步插件书签等，故选择了google家的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo apt install google-chrome-stable </span><br><span class="line"></span><br><span class="line">google-chrome-stable --proxy-server=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>将上边的ip和端口替换成自己的就好</p>
<p>或</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">sudo apt install proxychains</span><br><span class="line"></span><br><span class="line">sudo echo <span class="string">"http 127.0.0.1 1234"</span> <span class="meta">&gt;&gt; </span>/etc/proxychains.conf</span><br><span class="line"></span><br><span class="line">proxychains google-chrome-stable</span><br></pre></td></tr></table></figure>
<h3 id="微信，TIM"><a href="#微信，TIM" class="headerlink" title="微信，TIM"></a>微信，TIM</h3><p>由于已经加上deepin的源，就可以直接安装了<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sudo apt install deepin-winxin deepin<span class="selector-class">.com</span><span class="selector-class">.wechat</span> deepin<span class="selector-class">.com</span><span class="selector-class">.qq</span><span class="selector-class">.office</span></span><br></pre></td></tr></table></figure></p>
<h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh my zsh"></a>oh my zsh</h3><p>zsh的tab选择和<code>ctrl + r</code>搜索真香</p>
<blockquote>
<p>Oh My Zsh is an open source, community-driven framework for managing your zsh configuration. <a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">oh my zsh </a></p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt install -<span class="keyword">y</span> git zsh</span><br><span class="line"></span><br><span class="line"><span class="keyword">sh</span> -<span class="keyword">c</span> <span class="comment">"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh</span></span><br><span class="line">/ohmyzsh/master/tools/install.<span class="keyword">sh</span>)<span class="comment">"</span></span><br></pre></td></tr></table></figure>
<p>安装好之后再去修改<code>~/.zshrc</code><br><a href="https://github.com/ohmyzsh/ohmyzsh/wiki" target="_blank" rel="noopener">wiki</a></p>
<h3 id="vscodium"><a href="#vscodium" class="headerlink" title="vscodium"></a>vscodium</h3><p><a href="https://github.com/VSCodium/vscodium/releases" target="_blank" rel="noopener">项目地址</a></p>
<p>好就好在几乎不用配置</p>
<h3 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware-Workstation"></a>VMware-Workstation</h3><p>这个直接去官网下载就好了<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">this</a></p>
<ul>
<li>*.bundle文件在linux下是可执行文件格式之一啊</li>
<li>elf也是一种啊</li>
</ul>
<h3 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h3><p>这也是选类Ubuntu的好处之一，软件多啊</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> steam</span><br></pre></td></tr></table></figure>
<ul>
<li>试了几个游戏,虽然在菜单时帧数比windows下高些,但打起来莫名卡顿,爱不起来啊</li>
</ul>
<h1 id="踩坑篇"><a href="#踩坑篇" class="headerlink" title="踩坑篇"></a>踩坑篇</h1><h3 id="vim-篇"><a href="#vim-篇" class="headerlink" title="vim 篇"></a>vim 篇</h3><p>最开始发现在编辑模式下按方向键会出现奇怪的转义现象</p>
<p>好在比较简单</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">" set nocp"</span> &gt;&gt; ~<span class="string">/.vimrc</span></span><br></pre></td></tr></table></figure>
<p>然后呵听说vim可以安装插件，于是想折腾的心就又来了</p>
<p>左选右选决定先装个插件管理器Vundle</p>
<blockquote>
<p><a href="https://github.com/VundleVim/Vundle.vim/blob/master/README_ZH_CN.md" target="_blank" rel="noopener">README</a></p>
</blockquote>
<p>可能还是想要个自动补全的插件,于是有看上了<a href="https://github.com/ycm-core/YouCompleteMe" target="_blank" rel="noopener">YouCompleteMe</a></p>
<p>在插件管理器中安装失败,于是手动安装参考</p>
<ul>
<li><a href="https://github.com/ycm-core/YouCompleteMe" target="_blank" rel="noopener">https://github.com/ycm-core/YouCompleteMe</a></li>
<li>(<a href="https://www.cnblogs.com/YMaster/p/11209813.html" target="_blank" rel="noopener">https://www.cnblogs.com/YMaster/p/11209813.html</a>)</li>
</ul>
<p>最开始没有挂代理,各种红叉,ERROR真的是令人怀疑人生</p>
<p>最后遇到一个路径错误<a href="https://github.com/ycm-core/YouCompleteMe/issues/2249" target="_blank" rel="noopener">issue</a></p>
<p><img src="/images/20191221=3.png" alt></p>
<p>装上了发现还是没有ide香,虽然装ide时就是在装插件失败多次的时候装的，也是个大坑</p>
<h3 id="codeblocks"><a href="#codeblocks" class="headerlink" title="codeblocks"></a>codeblocks</h3><p><a href="http://www.codeblocks.org/downloads" target="_blank" rel="noopener">links</a></p>
<p>最开始下载完成时，包管理器告诉我<code>我的仓库有啊,直接来安装吧</code></p>
<p>解开压缩包一看,全是<code>.deb</code>包,人一懒就想者一键安装吧</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> codeblocks</span><br></pre></td></tr></table></figure>
<p>新建工程、console、helloword,最后发现压根编译不起来,一直error[-1],搜遍引擎翻遍设置<br>也不知道为什么</p>
<p>好吧我还是手动安装吧</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">codeblocks</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-xJvf   codeblocks_17.12-1_amd64_stable.tar.xz -C codeblocks/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tar 的J参数时是指定xz来解压 等同于 xd-d file</span></span><br><span class="line"><span class="comment"># -C 为解压到指定文件夹 ，必须存在才能成功</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cd</span> <span class="string">codeblocks/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i <span class="class"><span class="keyword">lib</span>*</span></span><br><span class="line">sudo dpkg -i wxsmith*</span><br><span class="line">sudo dpkg -i codeblocks*</span><br></pre></td></tr></table></figure>
<p>会出现下列错误<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">dpkg: 依赖关系问题使得 codeblocks-contrib 的配置工作不能继续：</span><br><span class="line">codeblocks-contrib 依赖于 libboost-system1<span class="number">.62</span><span class="number">.0</span>；然而：</span><br><span class="line">未安装软件包 libboost-system1<span class="number">.62</span><span class="number">.0</span>。</span><br><span class="line">codeblocks-contrib 依赖于 libgamin0；然而：</span><br><span class="line">未安装软件包 libgamin0。</span><br><span class="line">codeblocks-contrib 依赖于 libhunspell<span class="number">-1.4</span><span class="number">-0</span>；然而：</span><br><span class="line">未安装软件包 libhunspell<span class="number">-1.4</span><span class="number">-0</span>。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>[<a href="https://askubuntu.com/questions/599802/cant-install-codeblocks-plugin-wxsmith]" target="_blank" rel="noopener">https://askubuntu.com/questions/599802/cant-install-codeblocks-plugin-wxsmith]</a><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="builtin-name">remove</span> codeblocks-contrib</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>会提示需要安装xterm<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">apt install xterm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo</span> <span class="string">dpkg -i codeblocks*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这次不再报错</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20191221=4.png" alt></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><code>PrtSc</code> – 获取整个屏幕的截图并保存到 Pictures 目录。</li>
<li><code>Shift + PrtSc</code> – 获取屏幕的某个区域截图并保存到 Pictures 目录。</li>
<li>开机自动挂载硬盘<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 查看当前挂载情况</span></span><br><span class="line">df </span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看硬盘信息</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#Device          Start        End    Sectors   Size Type</span></span><br><span class="line"><span class="meta">#/dev/sdb1      409664 1046793400 1046383737   499G Microsoft basic data</span></span><br><span class="line"><span class="meta">#/dev/sdb2  1140332496 1549930447  409597952 195.3G Microsoft basic data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># 修改开机挂载参数</span></span><br><span class="line">sudo echo <span class="string">"/dev/sdb1 /media/cc/ssd ntfs defaults 0 0"</span> &gt;&gt; /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="meta"># 简单参数说明</span></span><br><span class="line"><span class="meta"># 设备位置(uuid等 )             将挂载的位置　　　文件系统　    配置文件      参数      参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 具体参见</span></span><br><span class="line">man fstab</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python 爬虫学习笔记(1)</title>
    <url>/2019/08/01/python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>看到的一个较简明的关于类属性方法的说明</p>
<p>比如我们定义所有的猫为一类那么我们就有了代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 猫</span>&#123;</span><br><span class="line">      颜色</span><br><span class="line">      品种</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们想获得一只猫来养那么需要一句代码：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">猫 小白 = <span class="keyword">new</span> <span class="type"></span>猫（）；</span><br></pre></td></tr></table></figure></p>
<p>我们养的猫肯定有颜色和花纹之分，比如雪白：<br><figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">小白.颜色 </span>=<span class="string"> 白；</span></span><br></pre></td></tr></table></figure></p>
<p>刚养的猫一般都怕生且爱叫唤：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小白.叫（）；</span><br></pre></td></tr></table></figure></p>
<p><strong>上面的 猫就是类 小白是猫这个类的实例也叫对象 小白的颜色就是属性 而叫（）就是猫的方法</strong></p>
<blockquote>
<p><a href="https://zhidao.baidu.com/question/1802107627262558507.html" target="_blank" rel="noopener">link</a></p>
</blockquote>
<hr>
<h1 id="urllib的使用"><a href="#urllib的使用" class="headerlink" title="urllib的使用"></a>urllib的使用</h1><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>提供了最基本的http请求方法，利用它可以模拟浏览器的一个请求发起过程</p>
<h5 id="1-urlopen"><a href="#1-urlopen" class="headerlink" title="1.urlopen()"></a>1.urlopen()</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">urlopen</span><span class="params">(url, data=None, timeout)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="url"><a href="#url" class="headerlink" title="url"></a>url</h6><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">a=urllib.request.<span class="built_in">urlopen</span>(<span class="string">"http://www.python.org"</span>)</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(a)) <span class="meta">#输出类型</span></span><br><span class="line"><span class="keyword">print</span>(a.<span class="built_in">read</span>().<span class="built_in">decode</span>(<span class="string">"utf-8"</span>))   <span class="meta">#其网页源代码</span></span><br><span class="line"><span class="keyword">print</span>(a.status) <span class="meta"># 返回结果的代码</span></span><br><span class="line"><span class="keyword">print</span>(a.getheaders) <span class="meta">#返回请求头部</span></span><br><span class="line"><span class="keyword">print</span>(a.<span class="built_in">getheader</span>('<span class="built_in">Date</span>')) <span class="meta">#返回请求的时间</span></span><br><span class="line"><span class="keyword">print</span>(a.<span class="built_in">__dir__</span>()) <span class="meta">#通过 __dir__ 查看当前实例的所有的方法和属性。</span></span><br></pre></td></tr></table></figure>
<h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">data=bytes(urllib<span class="selector-class">.parse</span><span class="selector-class">.urlencode</span>(&#123;<span class="string">"hi"</span>:<span class="string">"hi"</span>&#125;),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">a=urllib<span class="selector-class">.request</span><span class="selector-class">.urlopen</span>(<span class="string">"http://www.httpbin.org/post"</span>,data=data)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a.read()</span></span>)</span><br></pre></td></tr></table></figure>
<h6 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h6><p>用于设置超时时间，超过则抛出异常</p>
<h5 id="2-Ruquest"><a href="#2-Ruquest" class="headerlink" title="2.Ruquest"></a>2.Ruquest</h5><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Request(<span class="keyword">self</span>, url, data=None, headers=<span class="comment">&#123;&#125;</span>,</span><br><span class="line">origin_req_host=None, unverifiable=<span class="keyword">False</span>,<span class="function"><span class="keyword">method</span>=<span class="title">None</span>)</span></span><br></pre></td></tr></table></figure>
<p>从定义可见Ruquest又比openurl强大，使用方法同上,<strong>传data时必须将str转化为bytes</strong><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import urllib<span class="selector-class">.request</span>,urllib.parse</span><br><span class="line"></span><br><span class="line">data_str=&#123;</span><br><span class="line">    <span class="string">'123'</span>:<span class="string">'123'</span></span><br><span class="line">&#125;</span><br><span class="line">data=bytes(urllib<span class="selector-class">.parse</span><span class="selector-class">.encode</span>(data_str),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">url= <span class="string">"http://www.httpbin.org/post"</span></span><br><span class="line">headers= &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20120101 Firefox/33.0'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">method= <span class="string">'POST'</span></span><br><span class="line">b=urllib<span class="selector-class">.request</span><span class="selector-class">.Request</span>(url=url,data=data,headers=headers,method=method)</span><br><span class="line">response=urllib<span class="selector-class">.request</span><span class="selector-class">.urlopen</span>(b)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(response.read()</span></span>.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>代理的使用</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler,build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler= ProxyHandler(&#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'127.0.0.1:1080'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'127.0.0.1:1080'</span></span><br><span class="line">&#125;)</span><br><span class="line">opener= build_opener(proxy_handler)</span><br><span class="line">respense= opener.<span class="keyword">open</span>(<span class="string">'http://httpbin.org'</span>)</span><br><span class="line">print(respense.<span class="keyword">read</span>().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>cookie获取及使用</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存</span></span><br><span class="line">import http.cookiejar,urllib.request</span><br><span class="line"></span><br><span class="line">filename='cookie.txt'</span><br><span class="line">cookie=http.cookiejar.MozillaCookieJar(filename)         <span class="comment">##</span></span><br><span class="line">handle=urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener=urllib.request.build_opener(handle)</span><br><span class="line">response=opener.open('http://a.jd.com')</span><br><span class="line">cookie.save(ignore_discard=True,ignore_expires=True)       <span class="comment">## </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">import http.cookiejar,urllib.request</span><br><span class="line"></span><br><span class="line">cookie=http.cookiejar.MozillaCookieJar()</span><br><span class="line">cookie.load('cookie.txt')                       <span class="comment">##</span></span><br><span class="line">handle=urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener=urllib.request.build_opener(handle)</span><br><span class="line">response=opener.open('http://a.jd.com')</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理可使程序报错时不退出程序<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> error,request</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    a=request.urlopen(<span class="string">'http://4399.com/qaz.htm'</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> b:</span><br><span class="line">    print(b.reason)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Not</span> <span class="built_in">Found</span></span><br></pre></td></tr></table></figure>
<p>HTTPerror是URLerror的子类<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">from urllib import error,request</span><br><span class="line"></span><br><span class="line">try: </span><br><span class="line">    a=request.urlopen(<span class="string">'http://4399.com/qaz.htm'</span>)</span><br><span class="line">except error<span class="selector-class">.HTTPError</span> as <span class="selector-tag">b</span>:</span><br><span class="line">    print(<span class="selector-tag">b</span><span class="selector-class">.reason</span>,<span class="selector-tag">b</span><span class="selector-class">.url</span>,<span class="selector-tag">b</span>.code)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Not</span> Found http:<span class="comment">//www.4399.com/qaz.htm 404</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h5 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse()"></a>urlparse()</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">urlparse(url, <span class="attribute">scheme</span>=<span class="string">''</span>, <span class="attribute">allow_fragments</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">a=urllib<span class="selector-class">.parse</span><span class="selector-class">.urlparse</span>(<span class="string">'http://4399.com/index.html;user?id=1#comment'</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ParseResult(<span class="attribute">scheme</span>=<span class="string">'http'</span>, <span class="attribute">netloc</span>=<span class="string">'4399.com'</span>, <span class="attribute">path</span>=<span class="string">'/index.html'</span></span><br><span class="line">, <span class="attribute">params</span>=<span class="string">'user'</span>, <span class="attribute">query</span>=<span class="string">'id=1'</span>, <span class="attribute">fragment</span>=<span class="string">'comment'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse()"></a>urlunparse()</h5><p>与urlparse()对立的方法，传入参数必须为6个</p>
<h5 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode()"></a>urlencode()</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">p=&#123;</span><br><span class="line">    <span class="string">'aa'</span>:<span class="string">'aa'</span>,</span><br><span class="line">    <span class="string">'bb'</span>:<span class="string">'bb'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'http://4399.com?'</span>+urllib.parse.urlencode(p)</span></span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>//<span class="number">4399.</span><span class="keyword">com</span>?aa=aa&amp;bb=bb</span><br></pre></td></tr></table></figure>
<p>可以用字典来生成get的参数</p>
<h5 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs()"></a>parse_qs()</h5><p>与urlencode()相反，将参数转化为字典</p>
<h5 id="quote"><a href="#quote" class="headerlink" title="quote()"></a>quote()</h5><p>将内容转化为url编码<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">a=<span class="string">'紫电'</span></span><br><span class="line">b=urllib<span class="selector-class">.parse</span><span class="selector-class">.quote</span>(a)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(b)</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span>E<span class="number">7</span><span class="meta">%</span>B<span class="number">4</span><span class="meta">%</span>AB<span class="meta">%</span>E<span class="number">7</span><span class="meta">%</span><span class="number">94</span><span class="meta">%</span>B<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h5 id="unpuote"><a href="#unpuote" class="headerlink" title="unpuote()"></a>unpuote()</h5><p>与quote()相反</p>
<hr>
<h2 id="requests使用"><a href="#requests使用" class="headerlink" title="requests使用"></a>requests使用</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def <span class="builtin-name">get</span>(url, <span class="attribute">params</span>=None, **kwargs)</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">a=requests.<span class="built_in">get</span>(<span class="string">'http://4399.com'</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">text</span>)</span><br></pre></td></tr></table></figure>
<p>若想用post、put、del则直接将get置换之</p>
<p>json()可将json格式的数据转换为字典<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 简易ip地址查看</span></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>=requests.<span class="built_in">get</span>(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">print(<span class="keyword">a</span>.json()[<span class="string">'origin'</span>])</span><br></pre></td></tr></table></figure></p>
<p>params参数则是传入一个字典转化为参数<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">a=&#123;</span><br><span class="line">    <span class="string">'as'</span>:<span class="string">'sa'</span></span><br><span class="line">&#125;</span><br><span class="line">a=requests.<span class="built_in">get</span>(<span class="string">'http://httpbin.org/get'</span>,params=a)</span><br><span class="line"><span class="built_in">print</span>(a.json()[<span class="string">'url'</span>])</span><br></pre></td></tr></table></figure></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">http</span>://httpbin.org/<span class="built_in">get</span>?<span class="keyword">as</span>=sa</span><br></pre></td></tr></table></figure>
<p>添加header与urllib.request.Request()一样,传data不需将其转为bytes</p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>=requests.<span class="built_in">get</span>(<span class="string">'http://github.com/favicon.ico'</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.<span class="built_in">write</span>(<span class="keyword">a</span>.content)</span><br></pre></td></tr></table></figure>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>=&#123;</span><br><span class="line">    <span class="string">'file'</span>: <span class="keyword">open</span>(<span class="string">'favicon.ico'</span>,<span class="string">'rb'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">a</span>=requests.post(<span class="string">'http://httpbin.org/post'</span>,<span class="keyword">files</span>=<span class="keyword">file</span>)</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">a</span>.text)</span><br></pre></td></tr></table></figure>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>将cookie添加入头部引用即可<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">headers</span>=&#123;</span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">'cookie'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="requests下cookie保存"><a href="#requests下cookie保存" class="headerlink" title="requests下cookie保存"></a>requests下cookie保存</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>=requests.<span class="built_in">get</span>(<span class="string">'http://a.jd.com'</span>)</span><br><span class="line">b=requests.utils.dict_from_cookiejar(<span class="keyword">a</span>.cookies)    <span class="comment"># cookiejar转dict</span></span><br><span class="line">c=str(b)         <span class="comment"># dict转str</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"cookies.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> d:</span><br><span class="line">    d.<span class="built_in">write</span>(c)</span><br></pre></td></tr></table></figure>
<h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">a=requests.Session()</span><br><span class="line"><span class="selector-tag">a</span>.get(<span class="string">'http://httpbin.org/cookies/set/number/99965'</span>)</span><br><span class="line">r=<span class="selector-tag">a</span>.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(r.text)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cookies"</span>: &#123;</span><br><span class="line">    <span class="attr">"number"</span>: <span class="string">"99965"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://www.cnblogs.com/khaha/p/8629565.html" target="_blank" rel="noopener">dict字典与str字符串互转</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python-爬虫学习笔记(2)</title>
    <url>/2019/08/10/python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>解析篇</p>
<a id="more"></a>
<hr>
<h1 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h1><p>XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。</p>
<p>所依赖库为lxml</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nodename</td>
<td style="text-align:center">选取此节点的所有子节点。</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">从根节点选取。</td>
</tr>
<tr>
<td style="text-align:center">//</td>
<td style="text-align:center">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">选取当前节点。</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:center">选取当前节点的父节点。</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">选取属性。</td>
</tr>
</tbody>
</table>
<h2 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h2><table>
<thead>
<tr>
<th style="text-align:center">路径表达式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bookstore</td>
<td style="text-align:center">选取 bookstore 元素的所有子节点。</td>
</tr>
<tr>
<td style="text-align:center">/bookstore</td>
<td style="text-align:center">选取根元素 bookstore。</td>
</tr>
<tr>
<td style="text-align:center">bookstore/book</td>
<td style="text-align:center">选取属于 bookstore 的子元素的所有 book 元素。</td>
</tr>
<tr>
<td style="text-align:center">//book</td>
<td style="text-align:center">选取所有 book 子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td style="text-align:center">bookstore//book</td>
<td style="text-align:center">选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>
<tr>
<td style="text-align:center">//@lang</td>
<td style="text-align:center">选取名为 lang 的所有属性。</td>
</tr>
</tbody>
</table>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html='''</span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">"theme-next pisces use-motion"</span> <span class="attr">hi</span> <span class="attr">lang</span>=<span class="string">"zh-Hans"</span>&gt;</span>     ！！</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"generator"</span> <span class="attr">content</span>=<span class="string">"Hexo 3.8.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"#222"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-transform"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-siteapp"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">'''</span><br><span class="line"></span><br><span class="line">h2=etree.HTML(html)</span><br><span class="line">result=h2.xpath('//html[@lang="zh-Hans"]')</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; [<span class="tag">&lt;<span class="name">Element</span> <span class="attr">html</span> <span class="attr">at</span> <span class="attr">0x2b242e055c8</span>&gt;</span>]</span><br></pre></td></tr></table></figure>
<p>可见成功匹配</p>
<ul>
<li>html文本声明后需对其调用HTML类进行xpath对象的初始化</li>
<li>本地调用html文件需用<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">html</span>=etree.parse(<span class="string">'./test.html'</span>,etree.HTMLParser())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="进阶实例"><a href="#进阶实例" class="headerlink" title="进阶实例"></a>进阶实例</h2><table>
<thead>
<tr>
<th style="text-align:center">路径表达式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/bookstore/book[1]</td>
<td style="text-align:center">选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>
<tr>
<td style="text-align:center">/bookstore/book[last()]</td>
<td style="text-align:center">选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>
<tr>
<td style="text-align:center">/bookstore/book[last()-1]</td>
<td style="text-align:center">选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>
<tr>
<td style="text-align:center">/bookstore/book[position()&lt;3]</td>
<td style="text-align:center">选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>
</tr>
<tr>
<td style="text-align:center">//title[@lang]</td>
<td style="text-align:center">选取所有拥有名为 lang 的属性的 title 元素。</td>
</tr>
<tr>
<td style="text-align:center">//title[@lang=’eng’]</td>
<td style="text-align:center">选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>
</tr>
<tr>
<td style="text-align:center">/bookstore/book[price&gt;35.00]</td>
<td style="text-align:center">选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
<tr>
<td style="text-align:center">/bookstore/book[price&gt;35.00]/title</td>
<td style="text-align:center">选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h1><ul>
<li>Beautiful Soup提供了一些简单的方法和Pythonic习语，用于导航，搜索和修改解析树：用于剖析文档和提取所需内容的工具包。编写应用程序不需要太多代码</li>
<li>Beautiful Soup会自动将传入的文档转换为Unicode，将传出的文档转换为UTF-8。您不必考虑编码，除非文档未指定编码且Beautiful Soup无法检测到编码。然后你只需要指定原始编码。</li>
<li>Beautiful Soup位于流行的Python解析器之上，如lxml和html5lib，允许您尝试不同的解析策略或交易速度以获得灵活性。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> beautifulsoup4</span><br></pre></td></tr></table></figure>
<h2 id="从简单开始"><a href="#从简单开始" class="headerlink" title="从简单开始"></a>从简单开始</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup </span><br><span class="line"></span><br><span class="line">html_doc = """</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>The Dormouse's story<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>The Dormouse's story<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>Once upon a time there were three little sisters; and their names were</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com/elsie"</span> <span class="attr">class</span>=<span class="string">"sister"</span> <span class="attr">id</span>=<span class="string">"link1"</span>&gt;</span>Elsie<span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com/lacie"</span> <span class="attr">class</span>=<span class="string">"sister"</span> <span class="attr">id</span>=<span class="string">"link2"</span>&gt;</span>Lacie<span class="tag">&lt;/<span class="name">a</span>&gt;</span> and</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com/tillie"</span> <span class="attr">class</span>=<span class="string">"sister"</span> <span class="attr">id</span>=<span class="string">"link3"</span>&gt;</span>Tillie<span class="tag">&lt;/<span class="name">a</span>&gt;</span>;</span><br><span class="line">and they lived at the bottom of a well.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">html=BeautifulSoup(html_doc,'lxml')</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>The Dormouse's story<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>The Dormouse's story<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>Once upon a time there were three little sisters; and their names were</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"sister"</span> <span class="attr">href</span>=<span class="string">"http://example.com/elsie"</span> <span class="attr">id</span>=<span class="string">"link1"</span>&gt;</span>Elsie<span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"sister"</span> <span class="attr">href</span>=<span class="string">"http://example.com/lacie"</span> <span class="attr">id</span>=<span class="string">"link2"</span>&gt;</span>Lacie<span class="tag">&lt;/<span class="name">a</span>&gt;</span> and</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"sister"</span> <span class="attr">href</span>=<span class="string">"http://example.com/tillie"</span> <span class="attr">id</span>=<span class="string">"link3"</span>&gt;</span>Tillie<span class="tag">&lt;/<span class="name">a</span>&gt;</span>;</span><br><span class="line">and they lived at the bottom of a well.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"story"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可见初始化对象后会将缺失的标签自动补全</li>
<li><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">html=BeautifulSoup(html<span class="number">_</span><span class="meta">doc</span>,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="string">'lxml'</span>为手动选择的解释器</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">soup.title</span><br><span class="line"># &lt;title&gt;The Dormous<span class="string">e's story&lt;/title&gt;  提取title节点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.title.name</span></span><br><span class="line"><span class="string"># u'</span>titl<span class="string">e'  提取title节点名字</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.title.string</span></span><br><span class="line"><span class="string"># u'</span>The Dormous<span class="string">e's story'</span>   提取titlenei文字</span><br><span class="line"></span><br><span class="line">soup.title.parent.name </span><br><span class="line"># u<span class="string">'head'</span>  title父节点名字</span><br><span class="line"></span><br><span class="line">soup.p</span><br><span class="line"># &lt;p <span class="keyword">class</span>="title"&gt;&lt;b&gt;The Dormous<span class="string">e's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7.  soup.p['</span><span class="keyword">class</span><span class="string">']</span></span><br><span class="line"><span class="string">    # u'</span>titl<span class="string">e'  提取p节点属性class的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.a</span></span><br><span class="line"><span class="string"># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.find_all('</span>a<span class="string">')</span></span><br><span class="line"><span class="string"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.find(id="link3")</span></span><br><span class="line"><span class="string"># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.get_text()</span></span><br><span class="line"><span class="string">#  从文档中获取所有文字内容</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前7种方法只能找到匹配的第一条，要搜索全部需用find_all</li>
</ul>
<h1 id="python相关补充"><a href="#python相关补充" class="headerlink" title="python相关补充"></a>python相关补充</h1><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">get</span>(url, <span class="attribute">params</span>=None, **kwargs)</span><br></pre></td></tr></table></figure>
<p>函数定义中参数前的<em>表示的是将调用时的多个参数放入元组中,\</em>*则表示将调用函数时的关键字参数放入一个字典中<br>2**4 代表2的4次方</p>
<h3 id="2-对for语句的理解"><a href="#2-对for语句的理解" class="headerlink" title="2. 对for语句的理解"></a>2. 对for语句的理解</h3><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">for</span> <span class="variable">apple</span> <span class="variable"><span class="keyword">in</span></span> <span class="function"><span class="title">range</span>(<span class="number">10</span>):</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="variable">apple</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>这里的apple代表的是一个可以迭代[dié dài]的叫apple的对象</strong>，range(10)则是一个最先被计算的表达式</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python 爬虫学习笔记(3)</title>
    <url>/2019/08/22/python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>数据存储篇</p>
<a id="more"></a>
<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>依赖库<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure></p>
<p>json对象基本格式<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">data=[&#123;</span><br><span class="line">    <span class="string">"hi"</span>: <span class="string">"hi"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<h4 id="dumps"><a href="#dumps" class="headerlink" title="dumps"></a>dumps</h4><p> 可将json对象转换为str<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span>=[&#123;</span><br><span class="line">    <span class="string">"hi"</span>:<span class="string">"hi"</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.json'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(json.dumps(<span class="keyword">data</span>))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">'test</span>.json',<span class="string">'w'</span>) as <span class="keyword">file</span>:</span><br><span class="line">    <span class="keyword">file</span>.write(json.dumps(data))</span><br><span class="line"></span><br><span class="line"># 等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>=<span class="keyword">open</span>(<span class="symbol">'test</span>.json,<span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">file</span>.write(josn.dumps(data))</span><br><span class="line"><span class="keyword">file</span>.close()</span><br></pre></td></tr></table></figure>
<p>文件打开模式</p>
<ul>
<li>w(b)(+)</li>
<li>r(b)(+)</li>
<li>a(b)(+)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:left">+</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">追加模式</td>
<td style="text-align:center">二进制</td>
<td style="text-align:left">读写</td>
</tr>
</tbody>
</table>
<h4 id="loads"><a href="#loads" class="headerlink" title="loads"></a>loads</h4> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Deserialize s (a str, bytes <span class="keyword">or</span> bytearray<span class="built_in"> instance </span>containing a JSON document) <span class="keyword">to</span> a Python object.</span><br><span class="line">将json字符串转化为对象</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data=<span class="string">'''</span></span><br><span class="line"><span class="string">[&#123;</span></span><br><span class="line"><span class="string">    "hi":"hihi",</span></span><br><span class="line"><span class="string">    "nohi":"nohi"</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">    &#123;"123": "123123"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file=json.loads(data)</span><br><span class="line">print(file[<span class="number">0</span>].get(<span class="string">'hi'</span>))</span><br><span class="line">print(flie[<span class="number">1</span>][<span class="number">123</span>])</span><br><span class="line"></span><br><span class="line">&gt; hihi</span><br><span class="line">  <span class="number">123123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以上data最外面由[]包住，所以返回的为列表类型</li>
<li>列表可以用引索和键名查询数据</li>
</ul>
<hr>
<h1 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h1><p>CSV (Comma Separated Vaules) 格式是电子表格和数据库中最常见的输入、输出文件格式。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import csv </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'test.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    <span class="built_in">file</span>.writelines([<span class="string">'123,212'</span>])</span><br><span class="line">    <span class="built_in">file</span>.<span class="built_in">write</span>(<span class="string">'\n'</span>+<span class="string">'321'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>writelines()为写入一行<br>white()为写入字符，不会自动换行</li>
</ul>
<h4 id="写入字典"><a href="#写入字典" class="headerlink" title="写入字典"></a>写入字典</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv </span><br><span class="line"></span><br><span class="line">dict=&#123;</span><br><span class="line">    <span class="string">"123"</span>: <span class="string">"66"</span>,</span><br><span class="line">    <span class="string">'num2'</span>: <span class="string">"32166"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    fieldnames=[<span class="string">'123'</span>,<span class="string">'num2'</span>]   # 表头名字</span><br><span class="line">    file1=csv.DictWriter(file,fieldnames=fieldnames)</span><br><span class="line">    file1.writeheader()   # 写入表头</span><br><span class="line">    file1.writerow(dict)</span><br></pre></td></tr></table></figure>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">import csv </span><br><span class="line"></span><br><span class="line">dict=&#123;</span><br><span class="line">    <span class="string">"123"</span>: <span class="string">"66"</span>,</span><br><span class="line">    <span class="string">'num2'</span>: <span class="string">"32166"</span></span><br><span class="line">&#125;</span><br><span class="line">with<span class="meta"> open(</span><span class="string">'test.csv'</span>,<span class="string">'w'</span>) <span class="meta">as</span> <span class="meta">file</span>:</span><br><span class="line">    file1=csv.writer(<span class="meta">file</span>)</span><br><span class="line"></span><br><span class="line">    file1.writerow([<span class="string">'123'</span>,<span class="string">'num2'</span>])</span><br><span class="line">    file1.writerow([<span class="string">'66'</span>,<span class="string">'32166'</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>第二个为用基础方法写入字典格式的数据，虽效果一样，但随数据一多会很麻烦</li>
<li>照此示例代码写入的数据每两行会有一个换行，若去除则需修改open()<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">'test.csv'</span>,<span class="string">'w'</span>,newline=<span class="string">''</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import csv </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'test.csv'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    file1=csv.reader(<span class="built_in">file</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> bow <span class="keyword">in</span> file1:</span><br><span class="line">        print(bow)</span><br></pre></td></tr></table></figure>
<ul>
<li>若读取文件出现乱码，则考虑指定编码<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">'test.csv'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="关系型数据库-mysql"><a href="#关系型数据库-mysql" class="headerlink" title="关系型数据库(mysql)"></a>关系型数据库(mysql)</h3><p>依赖库为pymysql</p>
<h5 id="连接sql"><a href="#连接sql" class="headerlink" title="连接sql"></a>连接sql</h5><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">sql</span>=pymysql.<span class="keyword">connect</span>(host=<span class="string">'127.0.0.1'</span>,<span class="keyword">user</span>=<span class="string">'root'</span>,<span class="keyword">password</span>=<span class="string">'123456'</span>,port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"># 获取操作指针</span><br><span class="line">db=<span class="keyword">sql</span>.<span class="keyword">cursor</span>()</span><br><span class="line"></span><br><span class="line">db.<span class="keyword">execute</span>(<span class="string">'select version()'</span>)</span><br><span class="line">data=db.fetchall()</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<ul>
<li>connect()传入的是登录参数</li>
<li>execute()用于执行命令</li>
<li>fetchall()为获取所有的输出<br>fetchone()为获取下一行的输出</li>
</ul>
<h5 id="事务之增删更新"><a href="#事务之增删更新" class="headerlink" title="事务之增删更新"></a>事务之增删更新</h5><p>事务机制可以确保数据一致性。</p>
<p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<ul>
<li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db=pymysql.<span class="built_in">connect</span>(host=<span class="string">'127.0.0.1'</span>,user=<span class="string">'root'</span>,password=<span class="string">'123456'</span>,port=<span class="number">3306</span>,db=<span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line">id=<span class="number">1</span></span><br><span class="line">name=<span class="string">'bob'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cursor</span>=db.<span class="built_in">cursor</span>()</span><br><span class="line">sql=<span class="string">'insert into test(id,name) values(%s,%s)'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">try</span>:</span><br><span class="line">   <span class="built_in">cursor</span>.execute(sql,(id,name))</span><br><span class="line">   db.commit()</span><br><span class="line">except:</span><br><span class="line">   db.rollback()</span><br><span class="line"></span><br><span class="line">db.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>try相关语句就为事务的具体表现，要么做完成功提交，要么失败回滚</li>
<li>commit()提交更改至数据库</li>
<li>rollback()是回滚</li>
<li>这里插入数据采用的是用元组传入数据，具有一定可利用性，但面对复杂数据就相形见绌了</li>
</ul>
<p><strong>运用字典传入数据</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">data=&#123;</span><br><span class="line">   <span class="string">'id'</span>: <span class="string">'222'</span>,</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'1424'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造sq'l语句</span></span><br><span class="line">table_n=<span class="string">'test'</span></span><br><span class="line">q=<span class="string">','</span>.join(data.keys())</span><br><span class="line">vaules=<span class="string">','</span>.join([<span class="string">'%s'</span>]*(len(data)))</span><br><span class="line">sql=<span class="string">'insert into &#123;table_n&#125;(&#123;q&#125;) values (&#123;abc&#125;)'</span>.format(table_n=table_n,q=q,abc=vaules)</span><br><span class="line"></span><br><span class="line">db=pymysql.connect(host=<span class="string">'127.0.0.1'</span>,user=<span class="string">'root'</span>,password=<span class="string">'123456'</span>,db=<span class="string">'test'</span>,port=<span class="number">3306</span>)</span><br><span class="line">cursor=db.cursor()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   cursor.execute(sql,tuple(data.values()))</span><br><span class="line">   print(<span class="string">'success!'</span>)</span><br><span class="line">   db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">   db.rollback()</span><br><span class="line">   print(<span class="string">'error!'</span>)</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>values ({abc})这最初用的是values ({values})，但不知为何会报KeyError<br>所以以后<strong>变量名尽量不要用关键字</strong></li>
<li>tuple()是将列表转换为元组</li>
</ul>
<h5 id="sql语法回顾"><a href="#sql语法回顾" class="headerlink" title="sql语法回顾"></a>sql语法回顾</h5><p>这里是插入的方法，删除更新的方法也大同小异</p>
<ul>
<li>复习下语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">updata from test <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'pl'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">222</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># 实现爬取微博树洞微博并存储至mysql</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">from urllib.parse import urlencode</span><br><span class="line">from pyquery import PyQuery <span class="keyword">as</span> pq</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'m.weibo.cn'</span>,</span><br><span class="line">    <span class="string">'Referer'</span>: <span class="string">'https://m.weibo.cn/u/2830678474'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">&#125;</span><br><span class="line"># mongo相关</span><br><span class="line"># client = MongoClient()</span><br><span class="line"># db = client[<span class="string">'weibo'</span>]</span><br><span class="line"># collection = db[<span class="string">'weibo'</span>]</span><br><span class="line">max_page = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_page(page):</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'containerid'</span>: <span class="string">'1076035103578591'</span>,</span><br><span class="line">        <span class="string">'page'</span>: page</span><br><span class="line">    &#125;</span><br><span class="line">    url = base_url + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.<span class="built_in">get</span>(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json(), page</span><br><span class="line">    except requests.ConnectionError <span class="keyword">as</span> <span class="keyword">e</span>:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">'Error'</span>, <span class="keyword">e</span>.<span class="keyword">args</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def parse_page(json, page: <span class="keyword">int</span>):</span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        <span class="built_in">items</span> = json.<span class="built_in">get</span>(<span class="string">'data'</span>).<span class="built_in">get</span>(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">index</span>, item in enumerate(<span class="built_in">items</span>):</span><br><span class="line">            <span class="keyword">if</span> page == <span class="number">1</span> <span class="built_in">and</span> <span class="built_in">index</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item = item.<span class="built_in">get</span>(<span class="string">'mblog'</span>, &#123;&#125;)</span><br><span class="line">                weibo = &#123;&#125;</span><br><span class="line">                weibo[<span class="string">'id'</span>] = item.<span class="built_in">get</span>(<span class="string">'id'</span>)</span><br><span class="line">                weibo[<span class="string">'text'</span>] = pq(item.<span class="built_in">get</span>(<span class="string">'text'</span>)).text()</span><br><span class="line">               # weibo[<span class="string">'attitudes'</span>] = item.<span class="built_in">get</span>(<span class="string">'attitudes_count'</span>)</span><br><span class="line">               # weibo[<span class="string">'comments'</span>] = item.<span class="built_in">get</span>(<span class="string">'comments_count'</span>)</span><br><span class="line">               # weibo[<span class="string">'reposts'</span>] = item.<span class="built_in">get</span>(<span class="string">'reposts_count'</span>)</span><br><span class="line">                yield weibo</span><br><span class="line"></span><br><span class="line"># 存储至mongo</span><br><span class="line"># def save_to_mongo(result):</span><br><span class="line">#     <span class="keyword">if</span> collection.<span class="keyword">insert</span>(result):</span><br><span class="line">#         <span class="keyword">print</span>(<span class="string">'Saved to Mongo'</span>)</span><br><span class="line"></span><br><span class="line">def sql(result):</span><br><span class="line">    table_n=<span class="string">'weibo'</span></span><br><span class="line">    q=<span class="string">','</span>.<span class="keyword">join</span>(result.<span class="built_in">keys</span>())</span><br><span class="line">    vaules=<span class="string">','</span>.<span class="keyword">join</span>([<span class="string">'%s'</span>]*(<span class="built_in">len</span>(result)))</span><br><span class="line">    sql=<span class="string">'insert into &#123;table_n&#125;(&#123;q&#125;) values (&#123;abc&#125;)'</span>.format(table_n=table_n,q=q,<span class="keyword">abc</span>=vaules)</span><br><span class="line"></span><br><span class="line">    db=pymysql.connect(host=<span class="string">'127.0.0.1'</span>,user=<span class="string">'root'</span>,password=<span class="string">'123456'</span>,db=<span class="string">'test'</span>,port=<span class="number">3306</span>)</span><br><span class="line">    <span class="built_in">cursor</span>=db.<span class="built_in">cursor</span>()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql,tuple(result.<span class="built_in">values</span>()))</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">'succesful!'</span>)</span><br><span class="line">        db.commit()</span><br><span class="line">    excep<span class="variable">t:</span></span><br><span class="line">        db.rollback()</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">'error!'</span>)</span><br><span class="line"></span><br><span class="line">    db.<span class="keyword">close</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> page in <span class="built_in">range</span>(<span class="number">1</span>, max_page + <span class="number">1</span>):</span><br><span class="line">        json = get_page(page)</span><br><span class="line">        results = parse_page(*json)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> result in result<span class="variable">s:</span></span><br><span class="line">            <span class="keyword">print</span>(result)</span><br><span class="line">            # save_to_mongo(result)</span><br><span class="line">            sql(result)</span><br></pre></td></tr></table></figure>
<ul>
<li>运行前需提前建立好表格信息</li>
<li>参数前加*是指接受一个元组，**为字典</li>
<li>该实例模拟了ajax过程</li>
<li><del>NOSQL(mongo)就留给下次了</del></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>python-爬虫学习笔记(4)</title>
    <url>/2019/08/26/python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<p>Mondb and selenium</p>
<hr>
<a id="more"></a>
<h2 id="mongodb使用"><a href="#mongodb使用" class="headerlink" title="mongodb使用"></a>mongodb使用</h2><p>依赖库为pymongo</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span><span class="type"></span>=pymongo.mongo_client(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line">db=<span class="keyword">new</span><span class="type"></span>[<span class="string">'test'</span>]</span><br><span class="line"><span class="meta"># == db=new.test</span></span><br><span class="line"></span><br><span class="line">coll=db.test</span><br><span class="line"><span class="meta"># == coll=db['test']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认为直接连接，无需账号密码</li>
<li>mongo中有数据库集合的概念，集合(collection)类似于mysql的表</li>
</ul>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">dict_test=&#123;</span><br><span class="line">    <span class="string">'hello'</span>:<span class="string">'hi'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span>=pymongo.MongoClient(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line">db=<span class="built_in">new</span>[<span class="string">'test'</span>]</span><br><span class="line"># == db=<span class="built_in">new</span>.test</span><br><span class="line"></span><br><span class="line">coll=db.test</span><br><span class="line"># == coll=db[<span class="string">'test'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coll.insert(dict_test))</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">5d</span>6cd95073c60d291b004534</span><br></pre></td></tr></table></figure>
<ul>
<li><p>插入时可同时插入多个字典，传入时用列表如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">coll</span><span class="selector-class">.inert</span>(<span class="selector-attr">[dict1,dict2]</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完inert()会自动输出一个id值用于标识</p>
</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入字典查询</span></span><br><span class="line"><span class="built_in">print</span>(coll.find_one(&#123;<span class="string">'hello'</span>:<span class="string">'hi'</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据对象id查询</span></span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coll.find_one(&#123;<span class="string">'_id'</span>:ObjectId(<span class="string">'5d6cd95073c60d291b004534'</span>)&#125;))</span><br></pre></td></tr></table></figure>
<ul>
<li>find()也可查询数据，不过返回的是一个生成器对象，用于查询多个数据<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">res=coll.<span class="built_in">find</span>(&#123;'*':'*"&#125;)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> res:</span><br><span class="line">   <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=coll.find_one(&#123;<span class="string">'hello'</span>:<span class="string">'hi'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>[<span class="string">'hello'</span>]=<span class="string">'bye'</span></span><br><span class="line"></span><br><span class="line">coll.update(dict_test,<span class="built_in">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">test</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(coll.remove(&#123;<span class="string">'hello'</span>:<span class="string">'hi'</span>&#125;)</span></span>)</span><br><span class="line"></span><br><span class="line">&gt; &#123;<span class="string">'n'</span>: <span class="number">0</span>, <span class="string">'ok'</span>: <span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 排序</span></span><br><span class="line">sort()</span><br><span class="line"></span><br><span class="line"><span class="meta"># 计数</span></span><br><span class="line">count()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><ul>
<li><p>selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。</p>
</li>
<li><p>selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。</p>
</li>
</ul>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> selenium</span><br></pre></td></tr></table></figure>
<ul>
<li>下载相应浏览器驱动<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">chrome</a>并添加至环境path</li>
</ul>
<h3 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">brower= selenium<span class="selector-class">.webdriver</span><span class="selector-class">.Chrome</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>此时会自动打开一个chrome窗口</li>
</ul>
<h3 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">brower.get(<span class="string">'http://baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(brower.page_source)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>属性page_source为输出渲染后的源代码</li>
</ul>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># eg</span><br><span class="line">'''</span><br><span class="line">&lt;<span class="keyword">input</span> autocomplete=<span class="string">"off"</span> name=<span class="string">"k"</span> value=<span class="string">"搜索小游戏"</span> onclick=<span class="string">"document.charset='gb2312';chkSosmart()"</span> <span class="keyword">class</span>=<span class="string">"sh text clicked"</span> id=<span class="string">"smart_input"</span> placeholder=<span class="string">"完美漂移"</span>&gt;</span><br><span class="line">import selenium</span><br><span class="line">'''</span><br><span class="line"></span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line"></span><br><span class="line"><span class="keyword">bro</span>=selenium.webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="keyword">bro</span>.<span class="built_in">get</span>('http:<span class="comment">//4399.com')</span></span><br><span class="line"></span><br><span class="line"># xpath</span><br><span class="line"><span class="keyword">input</span>=<span class="keyword">bro</span>.find_element_by_xpath('<span class="comment">//*[@id="smart_input"]')</span></span><br><span class="line"></span><br><span class="line"># class_name</span><br><span class="line"><span class="keyword">input</span>=<span class="keyword">bro</span>.find_element_by_class_name('<span class="keyword">sh</span> text clicked')</span><br><span class="line"></span><br><span class="line"># name </span><br><span class="line"><span class="keyword">input</span>=<span class="keyword">bro</span>.find_element_by_name('k')</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>.send_keys('双人')</span><br><span class="line"><span class="keyword">input</span>.send_keys(Keys.ENTER)</span><br></pre></td></tr></table></figure>
<ul>
<li>其中xpath可以从chrome开发者工具在Elements手动找到该节点再右键复制为Xpath</li>
<li>据实践还是直接复制xpath最方便,代码一长节点名字什么的一下子重复了都不知道</li>
<li>find_elements()为寻找所有匹配节点</li>
</ul>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">input=bro.find<span class="constructor">_element_by_xpath('<span class="operator">/</span><span class="operator">/</span><span class="operator">*</span>[@<span class="params">id</span>=<span class="string">"smart_input"</span>]')</span></span><br><span class="line">input.send<span class="constructor">_keys('双人')</span></span><br><span class="line"></span><br><span class="line"># 获取按钮节点</span><br><span class="line">botton=bro.find<span class="constructor">_element_by_xpath('<span class="operator">/</span><span class="operator">/</span><span class="operator">*</span>[@<span class="params">id</span>=<span class="string">"skinbody"</span>]<span class="operator">/</span><span class="params">div</span>[2]<span class="operator">/</span><span class="params">div</span><span class="operator">/</span><span class="params">div</span><span class="operator">/</span><span class="params">div</span>[1]<span class="operator">/</span><span class="params">form</span><span class="operator">/</span><span class="params">div</span>[2]<span class="operator">/</span><span class="params">input</span>')</span></span><br><span class="line">botton.click<span class="literal">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>input.send_keys(Keys.ENTER) == botton.click()</li>
<li>botton.clear()为清空文字</li>
</ul>
<h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 获取属性</span></span><br><span class="line">input.get_attribute</span><br><span class="line"></span><br><span class="line"><span class="meta"># 获取文本值</span></span><br><span class="line">input.text</span><br><span class="line"></span><br><span class="line"><span class="meta"># id,location,tag_name,siza</span></span><br><span class="line">input.id</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h3 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h3><h4 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">ff = webdriver.Chrome()</span><br><span class="line">ff.implicitly_wait(10) <span class="comment"># seconds</span></span><br><span class="line"><span class="section">ff.get("http://4399.com")</span></span><br><span class="line">Element = ff.find_element_by_id(<span class="string">"myDynamicElement"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>隐式等待是指在尝试查找一个或多个元素（如果它们不是立即可用）时，WebDriver轮询DOM一段时间。默认设置为0。设置后，将为WebDriver对象实例的生命周期设置隐式等待。</li>
</ul>
<h4 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium<span class="selector-class">.webdriver</span><span class="selector-class">.common</span><span class="selector-class">.by</span> import By</span><br><span class="line">from selenium<span class="selector-class">.webdriver</span><span class="selector-class">.support</span><span class="selector-class">.ui</span> import WebDriverWait</span><br><span class="line">from selenium<span class="selector-class">.webdriver</span><span class="selector-class">.support</span> import expected_conditions as EC </span><br><span class="line"></span><br><span class="line">ff = webdriver.Chrome()</span><br><span class="line">ff.get(<span class="string">"http://4399.com"</span>)</span><br><span class="line">try:</span><br><span class="line">    element = WebDriverWait(ff, <span class="number">10</span>).until(EC.presence_of_element_located((By<span class="selector-class">.ID</span>, <span class="string">"myDynamicElement"</span>)))</span><br><span class="line">finally:</span><br><span class="line">    ff.quit()</span><br></pre></td></tr></table></figure>
<ul>
<li>显式等待是自己定义的代码，用于在继续执行代码之前等待某个条件发生</li>
<li>这会尝试在10秒内找到并返回元素。如果在此之后没有找到任何内容，则抛出<code>timesoutException</code>。默认情况下，每500毫秒WebDriverWait调用ExpectedCondition一次，直到成功返回。ExpectedCondition函数类型的成功返回值是布尔值true或非null对象。</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>sysV、sysD学习笔记</title>
    <url>/2019/07/15/sysV%E3%80%81sysD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="sys-V简介"><a href="#sys-V简介" class="headerlink" title="sys V简介"></a>sys V简介</h2><blockquote>
<blockquote>
<p>System V是Unix操作系统众多版本中的一支。它最初由AT&amp;T开发，在1983年第一次发布，因此也被称为AT&amp;T System V。一共发行了4个System V的主要版本：版本1、2、3和4。System V Release 4，或者称为SVR4，是最成功的版本，成为一些UNIX共同特性的源头，例如“SysV 初始化脚本”（/etc/init.d），用来控制系统启动和关闭，System V Interface Definition（SVID）是一个System V如何工作的标准定义。</p>
</blockquote>
</blockquote>
<p>sysV可以说是代表着一类linux风格，相对应的是BSD风格</p>
<p>&lt;<a id="more"></a>&gt;</p>
<p><img src="/images/20190715=0.png" alt="tu"></p>
<p>linux开启过程:</p>
<ol>
<li>开电进入BIOS或UEFI(通用可拓展固件接口)</li>
<li>初始化引导程序</li>
<li>加载内核入内存</li>
<li>开启pid为1 的init</li>
</ol>
<p>其init运行级别</p>
<ol start="0">
<li>系统停机状态</li>
<li>单用户模式，用于维护</li>
<li>多用户模式，无nfs</li>
<li>完整多用户模式</li>
<li>未使用的</li>
<li>图形</li>
<li>系统关机并重启</li>
</ol>
<p>服务相关<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ssh start/restart/stop/stop/status</span><br><span class="line">service ssh start/restart/stop/stop/status</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="sysD"><a href="#sysD" class="headerlink" title="sysD"></a>sysD</h2><p>Systemd的核心是取代老旧的SysV init。init用来初始化你的操作系统，当你启动系统时，init负责加载需要的驱动，激活你的网络链接，启动众多的系统服务，最后进入图形登陆界面。而SysV init 是一个老旧的系统，它基本上仅运行/etc/init.d目录下的一些脚本。</p>
<p>在systemd的管理体系里面，以前的运行级别（runlevel）的概念被新的运行目标（target）所取代。tartget的命名类似于multi-user.target等这种形式，比如原来的运行级别3（runlevel3）就对应新的多用户目标（multi-user.target），run level 5就相当于graphical.target。 </p>
<p>systemctl是systemd中常用的一个命令</p>
<p>使用systemctl命令需事先将xxx.service脚本放入/etc/systemd/system目录中<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">使服务自启动 systemctl enable xxx.service</span><br><span class="line">使服务自动禁止 systemctl disable xxx.service</span><br><span class="line">检查服务状态 systemctl status xxx.service</span><br><span class="line">启动某服务 systemctl start xxx.service</span><br><span class="line">停止某服务 systemctl stop xxx.service</span><br><span class="line">重启某服务 systemctl restart xxx.service</span><br></pre></td></tr></table></figure></p>
<p>hostnamectl 可方便查看系统信息<br><img src="/images/20190715=1.png" alt="tu"></p>
<p><a href="http://blog.jorgenschaefer.de/2014/07/why-systemd.html" target="_blank" rel="noopener">why-systemd?</a></p>
<h2 id="补充linxu笔记"><a href="#补充linxu笔记" class="headerlink" title="补充linxu笔记"></a>补充linxu笔记</h2><ul>
<li>一般ssh禁止root登陆，需到/etc/ssh/sshd_conf修改</li>
<li>若发现执行二进制文件失败，多是指令集版本选错</li>
<li>修改更新源在/etc/apt/sources.list</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记</title>
    <url>/2020/02/22/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h1><blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/NoSQL" target="_blank" rel="noopener">NoSQL</a>是对不同于传统的关系数据库的数据库管理系统的统称。<br>    两者存在许多显著的不同点，其中最重要的是NoSQL不使用SQL作为查询语言。其数据存储可以不需要固定的表格模式，也经常会避免使用SQL的JOIN操作，一般有水平可扩展性的特征。</p>
</blockquote>
<p>关系数据库遵循事务的ACID特性</p>
<ol>
<li>原子性(Atomicity): 事务要么全部成功,要么全部失败回滚</li>
<li>一致性(Consistency): 事务的提交只会让数据库的一致性状态转变到另一个一致性状态.如两个人银行转账,总金额不变</li>
<li>隔离性(Isolation): 一个事务在提交前对其他事务不可见</li>
<li>持久性(Durability): 事务提交后会永久保存在数据库中,不会因数据库故障而失效</li>
</ol>
<p>其中原子性和隔离性是一致性的前提,代表着事务的正确提交<br>而持久性是为了防止数据库的高可用性</p>
<p>分布式系统</p>
<blockquote>
<p>分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。</p>
</blockquote>
<p> 分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。</p>
<p> 因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。</p>
<ul>
<li>CAP定理（CAP theorem）<br>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</li>
</ul>
<ol>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ol>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。</p>
<p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency – 最终一致性， 也是是 ACID 的最终目的。</li>
</ul>
<p>NoSQL的优点/缺点<br>优点:</p>
<ul>
<li>高可扩展性</li>
<li>分布式计算</li>
<li>低成本</li>
<li>架构的灵活性，半结构化数据</li>
<li>没有复杂的关系</li>
</ul>
<p>缺点:</p>
<ul>
<li>没有标准化</li>
<li>有限的查询功能</li>
<li>最终一致是不直观的程序</li>
</ul>
<hr>
<h1 id="resdis"><a href="#resdis" class="headerlink" title="resdis"></a>resdis</h1><p>redis是属于nosql的一种</p>
<blockquote>
<p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库</p>
</blockquote>
<p>键（key）是二进制安全的，意味着可以存放任意二进制数据，最大为512MB</p>
<p>其基本数据类型有string、list、hash、set、sorted set</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是最简单的数据结构，键为字符串，值也为字符串</p>
<p>基本操作<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">添加键</span><br><span class="line"><span class="keyword">set</span> <span class="number">123</span>(<span class="keyword">key</span>) <span class="number">123</span>(<span class="keyword">value</span>)</span><br><span class="line">mset <span class="keyword">key</span> <span class="keyword">value</span> [<span class="keyword">key</span> <span class="keyword">value</span> ...]    <span class="comment"># 同时设置多个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">添加设置有效时间的键,过期则删除</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">key</span> <span class="keyword">value</span> [expiration EX <span class="keyword">seconds</span>|PX milliseconds] [NXXX]</span><br><span class="line"><span class="keyword">set</span> <span class="number">123</span> <span class="number">123</span> ex <span class="number">1</span>    <span class="comment"># 设置一秒有效时间</span></span><br><span class="line">setex <span class="number">123</span> <span class="number">123</span>        <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line">查看键过期时间</span><br><span class="line">ttl <span class="keyword">key</span></span><br><span class="line"></span><br><span class="line">获取键</span><br><span class="line"><span class="keyword">get</span> <span class="number">123</span>(<span class="keyword">key</span>) </span><br><span class="line">mget <span class="keyword">key</span> [<span class="keyword">key</span>  ...]    <span class="comment"># 同时获取多个</span></span><br><span class="line"></span><br><span class="line">删除键</span><br><span class="line">del <span class="number">123</span>(<span class="keyword">key</span>)            <span class="comment"># get del 的返回为1是成功,0相反</span></span><br><span class="line"></span><br><span class="line">对键的值自增(自减)<span class="number">1</span></span><br><span class="line">incr <span class="number">123</span>(<span class="keyword">key</span>)</span><br><span class="line">decr <span class="number">123</span></span><br><span class="line"></span><br><span class="line">对键的值指定增加(减少)数值</span><br><span class="line">incrby <span class="keyword">key</span> <span class="keyword">increment</span></span><br><span class="line">decrby <span class="keyword">key</span> <span class="keyword">increment</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>利用string的可以设置过期时间的特性,可以在数据库自身实现例如倒计时、cookies到期与否,而非应用程序中实现</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是由链表实现的双向队列,意味着同样拥有双向队列的基本操作<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">添加<span class="keyword">push</span></span><br><span class="line">lpush <span class="built_in">key</span> value   [value ...]    <span class="meta"># 从左边添加</span></span><br><span class="line">rpush <span class="built_in">key</span> value   [value ...]   <span class="meta"># 从右边添加</span></span><br><span class="line"></span><br><span class="line">删除<span class="keyword">pop</span></span><br><span class="line">lpop <span class="built_in">key</span></span><br><span class="line">rpop <span class="built_in">key</span></span><br><span class="line">del <span class="built_in">key</span>    <span class="meta"># 删除整个list</span></span><br><span class="line"></span><br><span class="line">堵塞版删除</span><br><span class="line">brpop <span class="built_in">key</span> [<span class="built_in">key</span> ...] timeout    <span class="meta"># 正常删除若为空会返回nil,这个则会堵塞到超时</span></span><br><span class="line"></span><br><span class="line">查看</span><br><span class="line">lrange <span class="built_in">key</span> start <span class="keyword">stop</span>   <span class="meta"># start下标从0开始,stop为负数则为从倒数开始数</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>单单这几个命令,就可以实现记住用户访问时间、生产者消费者模型(一边进,一边出)</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">查看<span class="type">list</span>长度</span><br><span class="line">llen <span class="type">key</span></span><br><span class="line"></span><br><span class="line">检查<span class="type">key</span>是否存在</span><br><span class="line">exists <span class="type">key</span></span><br></pre></td></tr></table></figure>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">主要方法与<span class="built_in">string</span>形似,(hash)hset</span><br><span class="line">hset <span class="built_in">key</span> field <span class="built_in">value</span></span><br><span class="line"></span><br><span class="line">field可以理解为属性,<span class="built_in">value</span> 为属性的值</span><br><span class="line"></span><br><span class="line">获取一个属性值</span><br><span class="line">hget <span class="built_in">key</span> field</span><br><span class="line"></span><br><span class="line">获取所有属性值</span><br><span class="line">hkeys <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line"><span class="built_in">hdel</span> <span class="built_in">key</span> field</span><br><span class="line"></span><br><span class="line">得到长度</span><br><span class="line">hlen <span class="built_in">key</span></span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 是字符串的无序集合,意味着对可以集合执行一些其他操作，比如测试给定的元素是否已经存在，执行多个集合之间的交集、并集或差集</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">添加</span><br><span class="line">sadd <span class="built_in">key</span> <span class="built_in">member</span> [<span class="built_in">member</span> ...]    # 加入顺序为随机的,若<span class="built_in">member</span>重复会失败</span><br><span class="line"></span><br><span class="line">获取</span><br><span class="line">spop <span class="built_in">key</span>    # 从最后获取一个并删除,类似于栈,先进后出</span><br><span class="line"></span><br><span class="line">获取全部成员</span><br><span class="line">smembers <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">对第一个<span class="built_in">key</span>求差集</span><br><span class="line">sdiff <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line"></span><br><span class="line">对第一个<span class="built_in">key</span>求交集</span><br><span class="line">sinter <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line"></span><br><span class="line">对第一个<span class="built_in">key</span>求并集</span><br><span class="line">sunion <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br></pre></td></tr></table></figure>
<h3 id="sorts-set"><a href="#sorts-set" class="headerlink" title="sorts set"></a>sorts set</h3><p>与集合类似，排序集合由唯一的、不重复的字符串元素组成，因此在某种意义上，排序集合也是一个集合。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">增加</span><br><span class="line">zadd <span class="built_in">key</span> [NX|XX] [CH] [INCR] score <span class="built_in">member</span> [score <span class="built_in">member</span> ...]</span><br><span class="line"></span><br><span class="line">查看一个范围内的<span class="built_in">member</span> </span><br><span class="line">zrange <span class="built_in">key</span> start stop [WITHSCORES]    # 以score排序</span><br><span class="line"></span><br><span class="line">倒序查看一个范围内的<span class="built_in">member</span> </span><br><span class="line">zrevrange <span class="built_in">key</span> start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">zrem <span class="built_in">key</span> <span class="built_in">member</span> [<span class="built_in">member</span> ...]</span><br></pre></td></tr></table></figure>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis 事务可以一次执行多个命令,并且带有以下三个重要的保证:</p>
<ol>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ol>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<p>以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令</p>
<p>redis单个指令是原子性的,由事务打包的多个指令总体来说不是原子性的,其中一个失败只是单独这一个失败,不会导致前面的回滚</p>
<ul>
<li>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：<ol>
<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ol>
</li>
<li>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应,可以提高操作效率</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>怎么配置主从关系?<br>  再从数据库上配置 SLAVEOF host port,这里的host和port(默认6379)都为主数据库的,从数据库会自动同步主数据库的数据  </li>
<li>Redis是单线程的，但是为什么这么高效?<br> 虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>sql初探</title>
    <url>/2019/08/15/sql%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>主流关系数据库<br>目前，主流的关系数据库主要分为以下几类：</p>
<ul>
<li>商用数据库，例如：Oracle，SQL Server，DB2等；</li>
<li>开源数据库，例如：MySQL，PostgreSQL等；</li>
<li>桌面数据库，以微软Access为代表，适合桌面应用程序使用；</li>
<li>嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。</li>
</ul>
<p>SQL = Structured Query Language</p>
<p>各数据库厂商还会支持特定的数据类型，例如JSON。</p>
<p>数据模型分为层次模型、网状模型、关系模型</p>
<p>BIGINT\VARCHAR(N)是日常用于最广泛的数据类型</p>
<p>DDL-定义数据（增删表，修改表结构）、DML-管理数据（增删改数据）、DQL-查询数据</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">sql安装</a></p>
<h1 id="小本本"><a href="#小本本" class="headerlink" title="小本本"></a>小本本</h1><p>刚刚安装完以 mysql -u root -p 登录<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">ERROR</span> 1820 (HY000): You must reset your password using ALTER<span class="built_in"> USER </span>statement before executing this statement.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span> <span class="keyword">PASSWORD</span> <span class="keyword">EXPIRE</span> <span class="keyword">NEVER</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>语句后都要加一个 ；</li>
<li>出现ERROR 2003 (HY000)  ，服务打开后也无效重装一遍就好</li>
<li>-&gt;代表的是一行还没结束 结束符为 ；</li>
<li>命令不区分大小写</li>
</ul>
<hr>
<h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。</p>
<p>可以使用多个列作为联合主键，但联合主键并不常用。</p>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>与主键类似，外键也是也是用于唯一标识数据的关系，只不过它标记的是数据与另一张表的关系，可以是1对1，1对多，多对多</p>
<hr>
<h1 id="常用标准命令"><a href="#常用标准命令" class="headerlink" title="常用标准命令"></a>常用标准命令</h1><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 名字;</span><br></pre></td></tr></table></figure>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 名字;</span><br></pre></td></tr></table></figure>
<h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> 名字;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc </span></span><br><span class="line"></span><br><span class="line">create table test3(</span><br><span class="line">    name varchar(100) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">   <span class="built_in"> address </span>varchar(100) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    number int ,</span><br><span class="line">    primary key (number)</span><br><span class="line">    )<span class="built_in"> default </span>charset utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li>在操作数据库时如果输入该字段的数据为NULL ，就会报错。</li>
<li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li>
<li>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li>
<li>ENGINE 设置存储引擎，CHARSET 设置编码。</li>
</ul>
<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">drop <span class="keyword">table</span> 名字</span><br></pre></td></tr></table></figure>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> (<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line">    vules</span><br><span class="line">    (<span class="number">123</span>,<span class="string">'bob'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 查询全部数据</span></span><br><span class="line"></span><br><span class="line">select * from table_name；</span><br><span class="line"></span><br><span class="line"><span class="section"># 完整语法</span></span><br><span class="line">SELECT column<span class="emphasis">_name,column_</span>name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[<span class="string">LIMIT N</span>][<span class="symbol"> OFFSET M</span>]</span><br></pre></td></tr></table></figure>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> column_name=<span class="string">'**'</span> <span class="keyword">where</span> *** ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> ***;</span><br><span class="line"></span><br><span class="line"><span class="comment"># etc </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span>  <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>至最后应该是已经删除了test表中所有数据，不信查查看</p>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>sed的应用</title>
    <url>/2019/12/03/sed%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>sed每次处理的单位是一行</p>
<p>sed默认并不修改实际文件，若需修改加上参数 -i 或加上重定向</p>
<table>
<thead>
<tr>
<th style="text-align:center">替换</th>
<th style="text-align:center">删除</th>
<th style="text-align:center">新增</th>
<th style="text-align:center">打印</th>
<th style="text-align:center">插入</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s/old/new/</td>
<td style="text-align:center">nd(n为行号)</td>
<td style="text-align:center">a</td>
<td style="text-align:center">1，5p</td>
<td style="text-align:center">i </td>
</tr>
</tbody>
</table>
<p>替换指定内容<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$  echo <span class="string">"123 123 123"</span> &gt; <span class="number">123</span></span><br><span class="line"><span class="number">123</span> <span class="number">123</span> <span class="number">123</span> </span><br><span class="line"></span><br><span class="line">sed -e 's/<span class="number">123</span>/!/  <span class="number">123</span></span><br><span class="line">$ ! <span class="number">123</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">sed 's/<span class="number">123</span>/!/g  <span class="number">123</span></span><br><span class="line">$ ! ! !</span><br><span class="line"></span><br><span class="line">可见末尾加g是全匹配的</span><br></pre></td></tr></table></figure></p>
<p>参数 -e 后面接的是要处理的表达式<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第一第二行</span></span><br><span class="line">sed -e <span class="string">"1d"</span> -e <span class="string">"2d"</span></span><br></pre></td></tr></table></figure></p>
<p>删除首部为字母的行<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/^[A-Z]/d'</span></span><br><span class="line"></span><br><span class="line">^为锚点的一种，意思是从最开始匹配，而另一种是<span class="variable">$，</span>是末尾匹配</span><br></pre></td></tr></table></figure></p>
<p>删除末尾n个字符<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">sed  's/<span class="symbol">\(</span>.*<span class="symbol">\)</span><span class="symbol">\(</span>.<span class="symbol">\&#123;</span>7<span class="symbol">\&#125;</span><span class="symbol">\)</span>/<span class="symbol">\1</span>/g'</span><br><span class="line"></span><br><span class="line">()为分组，<span class="symbol">\1</span>为一分组，<span class="symbol">\2</span>为二分组，上句为将字符</span><br><span class="line">分为两组（一组为要保留的，另一组为要删除的，s/ 则是将</span><br><span class="line">原先字符替换为 <span class="symbol">\1</span>分组内的内容 （要保留的）</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意在grep 、sed内 使用正则时特殊符号要加转义，或加上参数 -r</li>
<li>需要加转义的符号：<br>（ ） { }  \ </li>
<li>曾经付出惨痛代价，一度怀疑我用的是假的</li>
</ul>
<p>也可以在一个表达式中执行多个命令,用；分开<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">sed -e 's/<span class="number">123</span>/!/;p'</span><br><span class="line"></span><br><span class="line">$ ! <span class="number">123</span> <span class="number">123</span></span><br><span class="line">$ ! <span class="number">123</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>样例分析<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">原始数据:</span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7<span class="number">-53</span><span class="number">-8</span>A-A4 NY6<span class="number">-416</span><span class="number">-538</span>AA4       ap6522   v4022                <span class="number">6</span> days, <span class="number">0</span>:<span class="number">30</span>:<span class="number">23</span></span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7-BE-C5<span class="number">-38</span> BJ9<span class="number">-510</span>-BEC538       ap6522   v4018                <span class="number">2</span> days, <span class="number">1</span>:<span class="number">15</span>:<span class="number">39</span></span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7-AC-BA-BC BJ8<span class="number">-523</span>-ACBABC       ap6522   v4017                unknown              None</span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7<span class="number">-52</span><span class="number">-3</span>E-F8 NY6<span class="number">-406</span><span class="number">-523</span>EF8       ap6522   v4022                <span class="number">6</span> days, <span class="number">0</span>:<span class="number">29</span>:<span class="number">38</span></span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7-B7-C1<span class="number">-8</span>C BJ9<span class="number">-421</span>-B7C18C       ap6522   v4018                <span class="number">2</span> days, <span class="number">1</span>:<span class="number">15</span>:<span class="number">39</span></span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7-AF-B2-C4 BJ8<span class="number">-508</span>-AFB2C4       ap6522   v4017                unknown              None</span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7<span class="number">-53</span><span class="number">-87</span><span class="number">-28</span> NY6<span class="number">-402</span><span class="number">-538728</span>       ap6522   v4022                <span class="number">6</span> days, <span class="number">0</span>:<span class="number">30</span>:<span class="number">08</span></span><br><span class="line"><span class="number">74</span><span class="number">-67</span>-F7<span class="number">-52</span>-CC<span class="number">-98</span> NY6<span class="number">-407</span><span class="number">-52</span>CC98       ap6522   v4022                <span class="number">6</span> days, <span class="number">0</span>:<span class="number">30</span>:<span class="number">23</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>刚开始干这个的时候需要复制到word里一个一个查找出需要的信息并手动排版，虽然不难，但心累啊</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'NY'</span>  sedtest \                 ## grep 用于筛选  </span><br><span class="line">|  sed <span class="string">'s/^.*NY//'</span>  \                ## 删除 NY之前的字符</span><br><span class="line">|  sed <span class="string">'s/ap.*//'</span> \                  ## 由于ap 前的mac地址为随机的，故先删除ap后面的</span><br><span class="line">|  sed <span class="string">'s/\(.*\)\(.\&#123;6\&#125;\)/\1/g'</span>     ## 删除最后面<span class="number">6</span>个空格</span><br><span class="line">|  sed <span class="string">'/^[A-Z]/d'</span> |sed <span class="string">'s/ //'</span> \    ## 删除字母开头的行</span><br><span class="line">|  sed <span class="string">'s/\(.*\)\(.\&#123;7\&#125;\)/\1/'</span> \    ## 去掉数字后的mac地址</span><br><span class="line">|  sed <span class="string">'$!N;s/\n/\t/'</span>\               ## 将每两行合并为一行</span><br><span class="line">|  sed <span class="string">'$!N;s/\n/\t/'</span> \              ## 将每两行合并为一行</span><br><span class="line">|  sed <span class="string">'1s/^/南院: \n/'</span> \            ## 在开头添加字样</span><br></pre></td></tr></table></figure>
<p><a href="https://askubuntu.com/questions/461191/what-is-the-meaning-of-an-in-a-sed-command" target="_blank" rel="noopener">What is the meaning of :a;$!N; in a sed command?</a><br><a href="https://blog.51cto.com/goome/1749171" target="_blank" rel="noopener">关于合并两行为什么是 sed ‘$!N;s/\n/\t/‘</a><br><a href="https://www.cnblogs.com/jjzd/p/6892891.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">sed行处理详解(交换行,合并行,删除行等)</a></p>
<ul>
<li>nl 命令可在每一行前加序号</li>
</ul>
<p>回顾下正则<br><img src="/images/20191208=0.png" alt></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>为多个代理设置反向代理</title>
    <url>/2020/04/19/%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="为web设置反向代理"><a href="#为web设置反向代理" class="headerlink" title="为web设置反向代理"></a>为web设置反向代理</h1><p>首先在http下加上upstream字段<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">upstream webserver &#123;</span><br><span class="line">   <span class="built_in"> server </span>127.0.0.1:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再在<code>server</code>加上location<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">    proxy_pass</span> http://webserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此简单反向代理完成<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> web &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:80</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://web;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>为的就是实现优化资源利用率,增大吞吐量,减少访问延迟及一定的容错策略</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>轮询(round-robin) – 对应用程序服务器的请求以轮询方式分发，</li>
<li>最少的连接(least-connected) – 下一个请求分配给连接最少的服务器</li>
<li>ip-hash – 根据ip来决定由哪一台服务器</li>
</ul>
<p>就上一节来说,当<code>upstram</code>里出现多个<code>server</code>时,默认就为轮询<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在这里加上关键字`weight`可为轮询加上权重</span></span><br><span class="line">    upstream web &#123;</span><br><span class="line">       <span class="built_in"> server </span>127.0.0.1:80 weight = 1;</span><br><span class="line">       <span class="built_in"> server </span>127.0.0.1:81 weight = 10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>意思为11个连接中10个分给81端口,剩下1个给80</li>
</ul>
<p>设置<code>least-connected</code>加上<code>minimum_conn</code>即可</p>
<p>设置<code>ip-hash</code>可实现会话的持久性,以避免重复建立不必要的连接,加上<code>ip_hash</code>即可</p>
<p><code>upstream</code>的一些高级字段:</p>
<ul>
<li>down：表示单前的server暂时不参与负载.</li>
<li>max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</li>
<li>fail_timeout : max_fails次失败后，暂停的时间。</li>
<li>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。</li>
</ul>
<p><a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/load_balancing.html</a></p>
<h1 id="为多个代理设置反向代理"><a href="#为多个代理设置反向代理" class="headerlink" title="为多个代理设置反向代理"></a>为多个代理设置反向代理</h1><blockquote>
<p>为什么需要这个?总有些代理不够稳定,这样就需要频繁更改应用的代理端口,如果能设置一个反向代理代理它们,就能以一个固定端口访问了</p>
</blockquote>
<p>这里用到的是<code>stream</code>模块而不是<code>http</code><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream proxys &#123;</span><br><span class="line">       <span class="built_in"> server </span>127.0.0.1:1234 <span class="attribute">max_fails</span>=2 <span class="attribute">fail_timeout</span>=1s;</span><br><span class="line">       <span class="built_in"> server </span>127.0.0.1:12345 backup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> server </span>&#123;</span><br><span class="line">        listen 127.0.0.1:12666;</span><br><span class="line">        # 不能出现server_name字段和其余默认http相关字段</span><br><span class="line"></span><br><span class="line">        proxy_pass proxys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样就ok了,默认优先提供1234端口服务,除非服务不可用超时</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇短篇</title>
    <url>/2019/09/08/%E4%B8%80%E7%AF%87%E7%9F%AD%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>某天，你无端想起一个人，她曾让你对明天有所期许，但是却完全没有出现在你的明天里。  ——《再见金华站》</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=532413954&auto=0&height=66">「我还是成为了那个我不想成为的烂人」</iframe>

<blockquote>
<p>楼下一个男人病得要死，那间隔壁的一家唱着留声机，对面是弄孩子。楼上有两人狂笑；还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只觉得他们吵闹。   ——鲁迅《而已集·小杂感》</p>
</blockquote>
<p><del>「我还是成为了那个我不想成为的烂人」</del></p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker搭建apue.h 环境 </title>
    <url>/2019/09/10/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAapue-h-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>既是回顾也是实战</p>
<a id="more"></a>
<p>apue.h为《UNIX高级环境编程》所用的自定义头文件</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br><span class="line">docker run -itd ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> apt update</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> apt install -y gcc wget vim </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /home </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> wget http://www.apuebook.com/src.3e.tar.gz</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tar -zxvf src.3e.tar.gz</span></span><br></pre></td></tr></table></figure>
<ul>
<li>-d 使容器在后台运行</li>
</ul>
<hr>
<h1 id="配置头文件"><a href="#配置头文件" class="headerlink" title="配置头文件"></a>配置头文件</h1><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">&gt; cd ./src.<span class="number">3e</span>/apue.<span class="number">3e</span></span><br><span class="line">&gt; cp ./<span class="keyword">include</span>/apue.h /usr/<span class="keyword">include</span>/</span><br><span class="line">&gt; cp ./<span class="class"><span class="keyword">lib</span>/<span class="title">error</span>.<span class="title">c</span> /<span class="title">usr</span>/<span class="title">include</span>/</span></span><br><span class="line">&gt; vim /usr/<span class="keyword">include</span>/apue.h</span><br></pre></td></tr></table></figure>
<ul>
<li>光标移动到文件最后一行”#endif”的前面，然后添加如下代码<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"error.h"</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/dd734b0e8cb9" target="_blank" rel="noopener">links</a></p>
</blockquote>
<hr>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; make</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vim test.c</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;  include <span class="string">"apue.h"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;  include <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;  </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;  void <span class="function"><span class="title">main</span></span>()&#123;</span></span><br><span class="line">    printf("this is a test!");</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> gcc tset.c</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ./a.out</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> this is a <span class="built_in">test</span>!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时应该是没有错误的</li>
</ul>
<hr>
<h1 id="打包收工"><a href="#打包收工" class="headerlink" title="打包收工"></a>打包收工</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&gt; cd ~</span><br><span class="line">&gt; rm -rf *</span><br><span class="line">&gt; <span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">docker commit -m=<span class="string">"add apue.h"</span> CONTAINER [REPOSITORY[:TAG]] </span><br><span class="line">docker push</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="docker补充"><a href="#docker补充" class="headerlink" title="docker补充"></a>docker补充</h1><p>进入后台运行的容器</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">name</span> bash</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix折腾记-安装篇</title>
    <url>/2020/03/26/zabbix%E6%8A%98%E8%85%BE%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p>要想服务跑起来看得见,就得安装自身服务端,MySQL,前端</p>
<h3 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h3><p><a href="https://www.zabbix.com/documentation/current/manual/installation/install" target="_blank" rel="noopener">添加用户组</a><br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">addgroup --system --quiet zabbix</span><br><span class="line">adduser --quiet --system --disabled-login --ingroup zabbix --home /var/<span class="class"><span class="keyword">lib</span>/<span class="title">zabbix</span> --<span class="title">no</span>-<span class="title">create</span>-<span class="title">home</span> <span class="title">zabbix</span></span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.zabbix.com/cn/download_sources#tab:40LTS" target="_blank" rel="noopener">下载地址</a><br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看编译的一些功能选项</span></span><br><span class="line"><span class="string">./configure</span> <span class="params">--help</span></span><br><span class="line"></span><br><span class="line"><span class="string">./configure</span> <span class="params">--prefix=/usr/local/zabbix</span> <span class="params">--enable-server</span> <span class="params">--enable-agent</span> <span class="params">--enable-java</span> </span><br><span class="line"><span class="params">--with-mysql</span> <span class="params">--with-libxml2</span> <span class="params">--with-unixodbc</span> <span class="params">--with-net-snmp</span> <span class="params">--with-ssh2</span>  <span class="params">--with-libcurl</span> <span class="params">--with-iconv</span></span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h5 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h5><ul>
<li>MySQL library not found <code>sudo apt install libmysqlclient-dev</code></li>
<li>unixODBC <code>sudo apt install unixodbc-dev</code></li>
<li>configure error: Invalid Net-SNMP directory - unable to find net-snmp-config <code>sudo apt install libsnmp-dev</code></li>
<li>error: SSH2 library not found  <code>sudo apt install libssh2-1-dev</code></li>
<li>Unable to find “javac” executable in path <code>sudo apt install openjdk-11-jdk</code></li>
</ul>
<p>经过大量搜索貌似找到了解决依赖的一个好办法</p>
<ul>
<li><code>apt search &#39;*软件名*&#39;</code></li>
<li>一般安装那个带<code>-dev</code>的就OK了 </li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>不知道为什么自带软件源安装的mysql、httpd、nginx都用不了，可能是因为用着ubuntu的源，而issue里写的是mint没直接写上基于ubuntu了 ┑(￣Д ￣)┍</p>
<p>这里还是直接用了docker<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -id -name mysql -p3306:3306 -e  <span class="attribute">MYSQL_ROOT_PASSWORD</span>=111111 mysql</span><br></pre></td></tr></table></figure></p>
<ul>
<li>不加MYSQL_ROOT_PASSWORD=111111 的话容器都不会开启</li>
</ul>
<p><a href="https://www.zabbix.com/documentation/current/manual/appendix/install/db_scripts" target="_blank" rel="noopener">创建数据库</a><br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql -uroot -p&lt;<span class="keyword">password</span>&gt;</span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">database</span> zabbix <span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_bin;</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'zabbix'</span>@<span class="string">'%'</span> identified <span class="keyword">by</span> <span class="string">'&lt;password&gt;'</span>;</span><br><span class="line">mysql&gt; <span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'zabbix'</span>@<span class="string">'%'</span>;#需要加上这条授权参考下面第一个错误</span><br><span class="line"></span><br><span class="line">shell&gt; cd <span class="keyword">database</span>/mysql</span><br><span class="line">shell&gt; mysql -uzabbix -p&lt;<span class="keyword">password</span>&gt; zabbix &lt; <span class="keyword">schema</span>.<span class="keyword">sql</span></span><br><span class="line"># stop here <span class="keyword">if</span> you are creating <span class="keyword">database</span> <span class="keyword">for</span> Zabbix proxy</span><br><span class="line">shell&gt; mysql -uzabbix -p&lt;<span class="keyword">password</span>&gt; zabbix &lt; images.<span class="keyword">sql</span></span><br><span class="line">shell&gt; mysql -uzabbix -p&lt;<span class="keyword">password</span>&gt; zabbix &lt; data.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><a href="https://www.cnblogs.com/B1ackWall/p/11643136.html" target="_blank" rel="noopener">ERROR 1410 (42000): You are not allowed to create a user with GRANT</a></li>
</ul>
<ul>
<li><a href="https://stackoverflow.com/questions/10299148/mysql-error-1045-28000-access-denied-for-user-billlocalhost-using-passw" target="_blank" rel="noopener">MySQL ERROR 1045 (28000): Access denied for user ‘bill‘@’localhost’ (using password: YES)</a></li>
</ul>
<ul>
<li>[Error connecting to database: The server requested authentication method unknow]<br>(<a href="https://learnku.com/articles/10736/some-craters-in-mysql-8011" target="_blank" rel="noopener">https://learnku.com/articles/10736/some-craters-in-mysql-8011</a>)</li>
</ul>
<h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><p>前端拿php写的,故需要安装php<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo apt install php7<span class="number">.2</span>-fpm</span><br></pre></td></tr></table></figure></p>
<p>需要修改默认配置文件以满足zabbix需求<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/php/7.2/fpm/php.ini </span><br><span class="line"></span><br><span class="line">max_execution_time = 300 <span class="comment">##368行（执行时间）</span></span><br><span class="line">max_input_time = 300 <span class="comment">##378行（接收数据等待时间）</span></span><br><span class="line">memory_limit = 128M <span class="comment">##389行（每个脚本占用内存）</span></span><br><span class="line">post_max_size = 16M <span class="comment">##656行（POST数据大小）</span></span><br><span class="line">upload_max_filesize = 2M <span class="comment">##799行（下载文件大小）</span></span><br><span class="line">always_populate_raw_post_data = -1 <span class="comment">##800行</span></span><br><span class="line">date.timezone = Asia/Shanghai <span class="comment">##877行（时区</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>不改的话,后面也不会成功</li>
</ul>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">下载</a></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<ul>
<li><del>配置不太熟还需仔细研究</del></li>
</ul>
<p>遇到的一个错误<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[error]</span> <span class="number">16119</span>#<span class="number">0</span>: *<span class="number">75</span> FastCGI sent in stderr: <span class="string">"Primary script unknown"</span> </span><br><span class="line">while reading response header from upstream, client: <span class="number">127.0.0.1</span>, server: localhost, request:</span><br><span class="line"> <span class="string">"<span class="keyword">GET</span> / HTTP/1.1"</span>, upstream: <span class="string">"fastcgi://unix:/run/php/php7.2-fpm.sock:"</span>, host: <span class="string">"127.0.0.1"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>参考<a href="https://serverfault.com/questions/517190/nginx-1-fastcgi-sent-in-stderr-primary-script-unknown" target="_blank" rel="noopener">这里</a> . 犯了两个错误 :</li>
</ul>
<ol>
<li><code>/etc/php/7.2/fpm/pool.d/www.conf</code>   里设置的用户名和用户组与ngnix运行的不一致</li>
<li>复制php前端文件时用的是root</li>
</ol>
<p>附上简单丑陋的配置<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  localhost;</span><br><span class="line">     index index.php;</span><br><span class="line">     root /<span class="keyword">var</span>/www/php/;</span><br><span class="line"></span><br><span class="line">     location ~* \.php$ &#123;</span><br><span class="line">         <span class="keyword">include</span> fastcgi_params;</span><br><span class="line">         fastcgi_index  index.php;</span><br><span class="line">                     <span class="keyword">include</span>      fastcgi_params;</span><br><span class="line">         <span class="keyword">set</span> <span class="variable">$path_info</span> <span class="string">""</span>; </span><br><span class="line">         <span class="keyword">set</span> <span class="variable">$real_script_name</span> <span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="variable">$fastcgi_script_name</span> ~ <span class="string">"^(.+?\.php)(/.+)$"</span>) &#123;</span><br><span class="line">                 <span class="keyword">set</span> <span class="variable">$real_script_name</span> <span class="variable">$1</span>; </span><br><span class="line">                 <span class="keyword">set</span> <span class="variable">$path_info</span> <span class="variable">$2</span>; </span><br><span class="line">         &#125;</span><br><span class="line">         fastcgi_param SCRIPT_FILENAME /<span class="keyword">var</span>/www/php/<span class="variable">$real_script_name</span>;</span><br><span class="line">         fastcgi_param SCRIPT_NAME <span class="variable">$real_script_name</span>;</span><br><span class="line">         fastcgi_param PATH_INFO <span class="variable">$path_info</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//这里默认是127.0.0.1:9000;</span></span><br><span class="line">         <span class="comment">//需要到/etc/php/7.2/fpm/pool.d/www.conf查看监听的地址</span></span><br><span class="line">         fastcgi_pass unix:/<span class="keyword">run</span>/php/php7.2-fpm.sock;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>查看error日志可以快速定位问题</li>
</ul>
<h1 id="docker-install"><a href="#docker-install" class="headerlink" title="docker install"></a>docker install</h1><p><a href="https://www.zabbix.com/documentation/current/manual/installation/containers" target="_blank" rel="noopener">源自这里</a><br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"># docker run --name zabbix-appliance -t \</span><br><span class="line">      -<span class="ruby">p <span class="number">10051</span><span class="symbol">:</span><span class="number">10051</span> \</span></span><br><span class="line"><span class="ruby">      -p <span class="number">80</span><span class="symbol">:</span><span class="number">80</span> \</span></span><br><span class="line"><span class="ruby">      --restart <span class="keyword">unless</span>-stopped \</span></span><br><span class="line"><span class="ruby">      -d zabbix/zabbix-<span class="symbol">appliance:</span>latest</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>开箱可用,十分方便</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>都安装好之后,需要检查/etc/zabbix/zabbix_server.conf里的数据库账号名密码地址是否正确</p>
<p>需要检查/etc/zabbix/zabbix_agent.conf里server名字地址是否正确</p>
<p>真香<img src="/images/20200326=0.png" alt></p>
<p>太香了<img src="/images/20200326=1.png" alt></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>zabbix</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>vagrant学习</title>
    <url>/2020/05/06/vagrant%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="什么是vagrant"><a href="#什么是vagrant" class="headerlink" title="什么是vagrant"></a>什么是vagrant</h1><blockquote>
<p>Vagrant is a tool for building and managing virtual machine environments in a single workflow. With an easy-to-use workflow and focus on automation, Vagrant lowers development environment setup time, increases production parity, and makes the “works on my machine” excuse a relic of the past.</p>
<ul>
<li>简而言之，即是一次打包，随处使用</li>
</ul>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>vagrant 支持多种虚拟化软件</p>
<ul>
<li>VirualBox</li>
<li>Vmware(付费)</li>
<li>KVM</li>
<li>Hyper-v</li>
</ul>
<p>这里用到的是 virtualbox（默认支持），注意需先安装 virtualbox，再安装 vagrant，否则会出现找不到 virualbox 的错误，需重新安装</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo pacman -S virualbox</span></span><br></pre></td></tr></table></figure>
<ul>
<li>安装后还需加载相应内核模块<code>modprobe -a vboxdrv</code></li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo pacman -S vagrant</span></span><br></pre></td></tr></table></figure>
<h1 id="什么是box"><a href="#什么是box" class="headerlink" title="什么是box"></a>什么是box</h1><p>box 是vagrant环境的一种打包格式，在所有vagrant支持的操作系统上是通用的，而后面所有进行的操作都与box息息相关（类似于docker中的镜像）</p>
<p>这是box商店 —&gt; <a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">door</a></p>
<ul>
<li>在这里可以找到各种想要发行版或服务</li>
</ul>
<p>每个box以 <code>作者名/box名</code>加以区分</p>
<p>添加一个box<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">vagrant</span> <span class="keyword">box </span><span class="keyword">add </span>ubuntu/trusty64</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>可以是本地文件，也可以是一个下载地址</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">vagrant <span class="type">box</span> <span class="keyword">add</span> \</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/<span class="keyword">current</span>/bionic-<span class="keyword">server</span>-cloudimg-amd64-vagrant.box \</span><br><span class="line"><span class="comment">--name ubuntu/bionic</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>就像这样</p>
</li>
</ul>
<p>查看刚刚添加的box<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">vagrant box <span class="built_in">list</span></span><br></pre></td></tr></table></figure></p>
<p>删除<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">vagrant <span class="built_in">box</span> <span class="built_in">remove</span> name</span><br></pre></td></tr></table></figure></p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>了解了box，就可以正式开始了</p>
<p>先新建一个文件夹，作为本次的大本营,初始化<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">my</span>-vagrant</span><br><span class="line">cd <span class="keyword">my</span>-vagrant</span><br><span class="line"></span><br><span class="line">vagrant init ubuntu/trusty64</span><br></pre></td></tr></table></figure></p>
<ul>
<li>init 指定一个box，也可以是一个url</li>
</ul>
<p>这样在当前目录就生成了一个Vagrantfile，作为我们的初始配置文件<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># All Vagrant configuration is done below. The "2" in Vagrant.configure</span></span><br><span class="line"><span class="comment"># configures the configuration version (we support older styles for</span></span><br><span class="line"><span class="comment"># backwards compatibility). Please don't change it unless you know what</span></span><br><span class="line"><span class="comment"># you're doing.</span></span><br><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  <span class="comment"># The most common configuration options are documented and commented below.</span></span><br><span class="line">  <span class="comment"># For a complete reference, please see the online documentation at</span></span><br><span class="line">  <span class="comment"># https://docs.vagrantup.com.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Every Vagrant development environment requires a box. You can search for</span></span><br><span class="line">  <span class="comment"># boxes at https://vagrantcloud.com/search.</span></span><br><span class="line">  config.vm.box = <span class="string">"ubuntu/trusty64"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Disable automatic box update checking. If you disable this, then</span></span><br><span class="line">  <span class="comment"># boxes will only be checked for updates when the user runs</span></span><br><span class="line">  <span class="comment"># `vagrant box outdated`. This is not recommended.</span></span><br><span class="line">  <span class="comment"># config.vm.box_check_update = false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a forwarded port mapping which allows access to a specific port</span></span><br><span class="line">  <span class="comment"># within the machine from a port on the host machine. In the example below,</span></span><br><span class="line">  <span class="comment"># accessing "localhost:8080" will access port 80 on the guest machine.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">NOTE:</span> This will enable public access to the opened port</span></span><br><span class="line">  <span class="comment"># config.vm.network "forwarded_port", guest: 80, host: 8080</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a forwarded port mapping which allows access to a specific port</span></span><br><span class="line">  <span class="comment"># within the machine from a port on the host machine and only allow access</span></span><br><span class="line">  <span class="comment"># via 127.0.0.1 to disable public access</span></span><br><span class="line">  <span class="comment"># config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a private network, which allows host-only access to the machine</span></span><br><span class="line">  <span class="comment"># using a specific IP.</span></span><br><span class="line">  <span class="comment"># config.vm.network "private_network", ip: "192.168.33.10"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a public network, which generally matched to bridged network.</span></span><br><span class="line">  <span class="comment"># Bridged networks make the machine appear as another physical device on</span></span><br><span class="line">  <span class="comment"># your network.</span></span><br><span class="line">  <span class="comment"># config.vm.network "public_network"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Share an additional folder to the guest VM. The first argument is</span></span><br><span class="line">  <span class="comment"># the path on the host to the actual folder. The second argument is</span></span><br><span class="line">  <span class="comment"># the path on the guest to mount the folder. And the optional third</span></span><br><span class="line">  <span class="comment"># argument is a set of non-required options.</span></span><br><span class="line">  <span class="comment"># config.vm.synced_folder "../data", "/vagrant_data"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Provider-specific configuration so you can fine-tune various</span></span><br><span class="line">  <span class="comment"># backing providers for Vagrant. These expose provider-specific options.</span></span><br><span class="line">  <span class="comment"># Example for VirtualBox:</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># config.vm.provider "virtualbox" do |vb|</span></span><br><span class="line">  <span class="comment">#   # Display the VirtualBox GUI when booting the machine</span></span><br><span class="line">  <span class="comment">#   vb.gui = true</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#   # Customize the amount of memory on the VM:</span></span><br><span class="line">  <span class="comment">#   vb.memory = "1024"</span></span><br><span class="line">  <span class="comment"># end</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># View the documentation for the provider you are using for more</span></span><br><span class="line">  <span class="comment"># information on available options.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable provisioning with a shell script. Additional provisioners such as</span></span><br><span class="line">  <span class="comment"># Ansible, Chef, Docker, Puppet and Salt are also available. Please see the</span></span><br><span class="line">  <span class="comment"># documentation for more information about their specific syntax and use.</span></span><br><span class="line">  <span class="comment"># config.vm.provision "shell", inline: &lt;&lt;-SHELL</span></span><br><span class="line">  <span class="comment">#   apt-get update</span></span><br><span class="line">  <span class="comment">#   apt-get install -y apache2</span></span><br><span class="line">  <span class="comment"># SHELL</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>配置文件的语法格式为ruby</li>
</ul>
<p>相关配置块共有5种：</p>
<ul>
<li>config.vm 与虚拟机相关配置</li>
<li>config.ssh 与ssh相关配置</li>
<li>config.vagrant 与vagrant自身相关配置</li>
<li>config.winrm 与Windows远程管理相关配置</li>
<li>config.winssh 与Windows平台上ssh相关配置</li>
</ul>
<p>最常用的还是config.vm</p>
<table>
<thead>
<tr>
<th style="text-align:center">config.vm.box</th>
<th style="text-align:center">指定一个box（初始化时就已经自动填好）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">config.vm.box_version</td>
<td style="text-align:center">指定一个box的版本</td>
</tr>
<tr>
<td style="text-align:center">comfig.vm.define</td>
<td style="text-align:center">为这个虚拟机取个名（默认为default）</td>
</tr>
</tbody>
</table>
<p><a href="https://www.vagrantup.com/docs/vagrantfile/machine_settings.html" target="_blank" rel="noopener">更多设置</a></p>
<p>开始启动<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant up</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样过一会虚拟机就会启动完成了</li>
</ul>
<p>关机、重启<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">vagrant</span> <span class="string">halt</span></span><br><span class="line"></span><br><span class="line"><span class="attr">vagrant</span> <span class="string">reload</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ssh管理"><a href="#ssh管理" class="headerlink" title="ssh管理"></a>ssh管理</h1><p>创建完成后已经自动设置好了ssh，查看配置<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">vagrant ssh-config</span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">Host default</span><br><span class="line">HostName 127.0.0.1</span><br><span class="line">User vagrant</span><br><span class="line">Port 2222</span><br><span class="line">UserKnownHostsFile /dev/<span class="literal">null</span></span><br><span class="line">StrictHostKeyChecking <span class="literal">no</span></span><br><span class="line">PasswordAuthentication <span class="literal">no</span></span><br><span class="line">IdentityFile /home/test/my-vagrant/.vagrant/machines/default/virtualbox/private_key</span><br><span class="line">IdentitiesOnly <span class="literal">yes</span></span><br><span class="line">LogLevel FATAL</span><br></pre></td></tr></table></figure></p>
<ul>
<li>可以得到几个重要信息：ip、端口、用户名、密钥地址</li>
</ul>
<p>连接虚拟机<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">vagrant ssh </span><br><span class="line"></span><br><span class="line"># 等同于 ssh <span class="symbol">vagrant@</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">2222</span> -i ~/my—vagrant/.vagrant/machines/<span class="keyword">default</span>/virtualbox/private_key</span><br></pre></td></tr></table></figure></p>
<ul>
<li>若有多个虚拟机，则在ssh 后接名字即可</li>
</ul>
<h1 id="Provisioning-预配置"><a href="#Provisioning-预配置" class="headerlink" title="Provisioning 预配置"></a>Provisioning 预配置</h1><p>要使用Preovision 须在Vagrantfile里配置，这样在在虚拟机开启时会自动运行这些预先配置</p>
<p>配置语法其一为内联<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">config<span class="selector-class">.vm</span><span class="selector-class">.provision</span> <span class="string">"shell"</span>, inline: <span class="string">"echo hello"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>config.vm.provision</code> 后接的是预配置的提供者类型 </li>
</ul>
<p>其二以配置块的方式出现<br><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">config.vm.provision <span class="string">"shell"</span> <span class="built_in">do</span> |<span class="type">s</span>|<span class="type"></span></span><br><span class="line"><span class="type">  s</span>.inline = <span class="string">"echo hello"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">或先为其起个名字</span><br><span class="line"> config.vm.provision <span class="string">"ansibbbble"</span>,type: <span class="string">"ansible"</span>  <span class="built_in">do</span> |<span class="type">ansible</span>|<span class="type"></span></span><br><span class="line"><span class="type">  ansible</span>.playbook = <span class="string">"./playbook.yml"</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>后者的”ansibbbble” 则为预配置的一个名字，这样的话输出会更加直白</li>
</ul>
<p>若是在启动后还想再次运行预配置<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant provision</span></span><br></pre></td></tr></table></figure></p>
<h1 id="同步文件"><a href="#同步文件" class="headerlink" title="同步文件"></a>同步文件</h1><p>在虚拟机开启时，会自动将当前目录与虚拟机中的 <code>/vagrant</code> 文件夹进行同步，实则自动将当前目录挂载了</p>
<hr>
<p><a href="https://www.vagrantup.com/docs/" target="_blank" rel="noopener">更多文档</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ufw配置防火墙</title>
    <url>/2020/04/06/%E4%BD%BF%E7%94%A8ufw%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<blockquote>
<p>iptables 是一个命令行实用工具，用于配置 Netfilter 项目中实现的 Linux 内核防火墙。 术语 iptables 也通常用来指这种内核级别的防火墙。 它可以直接用 iptables 进行配置，或者使用许多控制台和图形前端之一进行配置。</p>
</blockquote>
<p>这次要讲到的ufw是 Uncomplicated Firewall 的缩写，是一个管理 netfilter 防火墙的程序。 它提供了一个命令行界面，目的是简单易用</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>为命令行模式<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pacman -S ufw</span></span><br></pre></td></tr></table></figure></p>
<p>也有图形的<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pacman -S gufw</span></span><br></pre></td></tr></table></figure></p>
<h1 id="状态查询"><a href="#状态查询" class="headerlink" title="状态查询"></a>状态查询</h1><p>启用它<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样就会开机启动了</li>
<li>注意不能和<code>iptables.service</code>同时启用</li>
</ul>
<p>关闭    <code>ufw disable</code></p>
<p>查看状态    <code>ufw status</code></p>
<p>查看状态，规则以数字标号    <code>ufw status numbered</code></p>
<ul>
<li>后面删除规则就会用到规则号码</li>
</ul>
<h1 id="规则语法"><a href="#规则语法" class="headerlink" title="规则语法"></a>规则语法</h1><h3 id="具体的地址端口"><a href="#具体的地址端口" class="headerlink" title="具体的地址端口"></a>具体的地址端口</h3><p>允许任意来源任意协议放开53端口  <code>ufw allow 53</code></p>
<ul>
<li>会增加两条规则，分别对应v4、v6</li>
<li>在端口号后可指定协议，如<code>53/tcp</code></li>
</ul>
<p>而对应完整版应为<code>来源/目的+端口</code>    </p>
<ul>
<li><code>ufw allow proto tcp from any to any port 53</code></li>
<li><code>ufw allow proto udp from any to any port 53</code></li>
</ul>
<p>前面的语句默认是放开、拒绝双向连接，也可以指定单向</p>
<ul>
<li><code>ufw allow in 53</code></li>
<li><code>ufw allow out 53</code></li>
</ul>
<p>可以同时指定多个端口    <code>ufw allow proto tcp from any to any port 80,443,8080:8090</code></p>
<ul>
<li>不能单独删除一个端口</li>
<li>端口间不能接空格</li>
</ul>
<p>any指带的即是网络号，也可以是设备</p>
<ul>
<li>如<code>ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 53</code></li>
<li>拒绝来自10.0.0.0/8域的tcp协议指向192.168.0.1端口53的数据进入本机</li>
<li><code>ufw route allow in on eth1 out on eth2</code></li>
<li>允许经eth1进入，eth2发出的数据经本机路由</li>
</ul>
<p>删除规则    <code>ufw delete allow 53</code></p>
<ul>
<li>或者通过规则序号删除  <code>ufw delete num</code></li>
</ul>
<h3 id="app-profiles"><a href="#app-profiles" class="headerlink" title="app profiles"></a>app profiles</h3><p>默认自带app配置在<code>/etc/ufw/applications.d/</code></p>
<ul>
<li>或通过<code>ufw app list</code>查看名字，再<code>ufw app info name</code><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ufw app <span class="builtin-name">info</span> WWW</span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">Profile: WWW</span><br><span class="line">Title: Web Server</span><br><span class="line">Description: Web server</span><br><span class="line"></span><br><span class="line">Port:</span><br><span class="line">80/tcp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>添加删除规则直接用app名字来进行</p>
<ul>
<li>添加  <code>ufw allow WWW</code></li>
<li>删除  <code>ufw delete allow WWW</code></li>
</ul>
<p>添加一个新的app配置<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">vi /etc/ufw/applications.d/ufw-kde-connect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字全部加上缺一不可</span></span><br><span class="line">[kde-connect]   <span class="comment">#app配置名</span></span><br><span class="line">title=kde-connect</span><br><span class="line">description=kde-connect</span><br><span class="line">ports=1716  <span class="comment">#规则</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>更新使其生效  <code>ufw app update kde-connect</code></li>
<li>这样通过app名管理更加直观</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在测试时发现通过docker暴露出来的端口不受ufw控制</p>
<ul>
<li><a href="https://blog.csdn.net/sinat_33384251/article/details/94409846" target="_blank" rel="noopener">解决方案</a></li>
</ul>
<hr>
<p>ref:<br><a href="https://wiki.manjaro.org/index.php?title=Firewalls" target="_blank" rel="noopener">https://wiki.manjaro.org/index.php?title=Firewalls</a><br><a href="https://wiki.ubuntu.org.cn/Ufw%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">https://wiki.ubuntu.org.cn/Ufw%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ufw</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>利用privoxy实现http代理转sock</title>
    <url>/2019/05/11/%E5%88%A9%E7%94%A8privoxy%E5%AE%9E%E7%8E%B0http%E4%BB%A3%E7%90%86%E8%BD%ACsock/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于最近接触到Resilio Sync这款软件，但因为特殊原因，使用体验不太好，其本身不支持http代理，通过搜索发现了privoxy这款神器</p>
<p>简单介绍一下Resilio Sync，一个基于p2p技术的分布式文件同步(当网盘用也行)软件</p>
<blockquote>
<p>Resilio Sync is a fast, reliable, and simple file sync and share solution, powered by P2P technology</p>
</blockquote>
<hr>
<h1 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h1><blockquote>
<p>Privoxy是一款不进行网页缓存且自带过滤功能的代理服务器，针对HTTP、HTTPS协议。通过其过滤功能，用户可以保护隐私、对网页内容进行过滤、管理Cookie，以及拦阻各种广告等。</p>
<blockquote>
<p><a href="https://www.privoxy.org/" target="_blank" rel="noopener">官网</a></p>
</blockquote>
</blockquote>
<p>安装完成后将代理设置指向为127.0.0.1:8118 ,通过浏览器访问<a href="http://p.p" target="_blank" rel="noopener">http://p.p</a>,<br>不出意外的话会显示已成功开启，在其上可查看配置等</p>
<p>在windows下主配置文件是config.txt,设置代理转发也不难<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">forward-sock5 / <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1234</span> .</span><br><span class="line">forward-sock4 / <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1234</span> .</span><br></pre></td></tr></table></figure></p>
<p>这代表的将收到的http请求转发到127.0.0.1的1234端口上的socks5(4)去，/代表匹配所有，可写具体的网址,最后一个点代表不再转发到http代理</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">forward-socks5</span>   <span class="selector-tag">target_pattern</span>  <span class="selector-tag">socks_proxy</span><span class="selector-pseudo">:port</span>  <span class="selector-tag">http_proxy</span><span class="selector-pseudo">:port</span></span><br></pre></td></tr></table></figure>
<p>这表示的是将收到的http转发到socks再转发到http</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>关于c语言中一些疑难点的复习</title>
    <url>/2020/03/07/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%96%91%E9%9A%BE%E7%82%B9%E7%9A%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><table>
<thead>
<tr>
<th style="text-align:center">声明</th>
<th style="text-align:center">描述对象的类型,用于指代其他地方定义的对象,如<code>extern int i;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">确定对象的类型并分配类型,用于创建新的对象,如<code>int i ;</code></td>
</tr>
</tbody>
</table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;  <span class="comment">// 既是声明也是定义</span></span><br><span class="line">extern <span class="built_in">int</span> i; <span class="comment">// 为声明,表示在其他地方有定义</span></span><br><span class="line">extern <span class="built_in">int</span> i = <span class="number">0</span>; <span class="comment">// 既是声明也是定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于函数,结构体同样适用</li>
</ul>
<hr>
<h1 id="指针和数组名一样么"><a href="#指针和数组名一样么" class="headerlink" title="指针和数组名一样么"></a>指针和数组名一样么</h1><p>首先看一个例子<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pp[]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> * p = pp ;</span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%d %d"</span>,pp[<span class="number">0</span>],p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>毫无疑问,这是没有问题的</li>
</ul>
<p>但是如果是这样的呢<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">extern <span class="built_in">int</span> pp[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//假设在文件A</span></span><br><span class="line">extern <span class="built_in">int</span> *pp;  <span class="comment">//假设在文件B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在文件B中</span></span><br><span class="line">printf(<span class="string">"%d"</span>,pp[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>能正确输出<code>1</code>吗,答案是<strong>不能</strong></li>
<li><code>int pp[]</code>是一个数组,<code>int *pp</code>是一个指针,不能因为变量名一样而将指针和数组名混为一谈</li>
<li>在<code>int pp[]</code>中,pp代表的是pp这个数组的真实地址,但在<code>int *pp</code>中,pp只是个指针变量,变量的值才为真正所需要访问的地址,在这里犯了类型不匹配的错误</li>
</ul>
<p>若要正确使用,在文件B中应该改为<code>extern int pp[]</code></p>
<p>什么时候数组等同于指针</p>
<ul>
<li>出现表达式中时,数组名会被转换为一个指针,如<code>int pp[3] = {0};  *(pp+1) ;</code></li>
<li>把数组下标作为指针的偏移量,<code>int *p =pp ; *(篇+1);</code></li>
<li>作为函数的参数</li>
</ul>
<hr>
<h1 id="如何在-main-执行之前先运行其它函数"><a href="#如何在-main-执行之前先运行其它函数" class="headerlink" title="如何在 main() 执行之前先运行其它函数"></a>如何在 main() 执行之前先运行其它函数</h1><p>刚学c语言的时候,相信对main()函数的印象都是它是程序运行时第一个运行的函数,其实不然</p>
<p>先写个简单小程序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> agrc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>运行编译毫无疑问是<code>Hello world!</code></li>
</ul>
<p>先了解一下可执行文件格式<br><img src="/images/20200307=0.png" alt></p>
<p>其中的<code>.text</code> <code>.data</code> <code>.bss</code> 是不是像极了c语言程序运行时存储空间布局中所对应的</p>
<ul>
<li><code>text</code> 保存的是编译后得到的机器码</li>
<li><code>.rodata</code> 保存是只读数据,如<code>char *buf = &quot;hi&quot;</code>这里的<code>hi</code>为只读的字符串常量</li>
<li><code>data</code> 保存的是被初始化的全局变量和静态变量</li>
<li><code>bss</code> 保存的是未初始化的保存的是未被初始化额全局变量和静态变量，及被初始化为0的初始变量</li>
</ul>
<p>而这里想看是<code>.systab</code>保存的是在程序中定义或者引用的函数、全局变量<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># readelf - Displays information about ELF files.</span></span><br><span class="line"></span><br><span class="line">readelf -s a.out</span><br><span class="line"></span><br><span class="line"> &gt;    2: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND puts@GLIBC_2.2.5 (2)</span><br><span class="line">     3: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND __libc_start_main@GLIBC_2.2.5 (2)</span><br><span class="line">     6: 0000000000000000     0 FUNC    WEAK  <span class="built_in"> DEFAULT </span> UND __cxa_finalize@GLIBC_2.2.5 (2)</span><br><span class="line">    27: 0000000000000560     0 FUNC    LOCAL <span class="built_in"> DEFAULT </span>  14 deregister_tm_clones</span><br><span class="line">    28: 00000000000005a0     0 FUNC    LOCAL <span class="built_in"> DEFAULT </span>  14 register_tm_clones</span><br><span class="line">    29: 00000000000005f0     0 FUNC    LOCAL <span class="built_in"> DEFAULT </span>  14 __do_global_dtors_aux</span><br><span class="line">    32: 0000000000000630     0 FUNC    LOCAL <span class="built_in"> DEFAULT </span>  14 frame_dummy</span><br><span class="line">    43: 00000000000006d0     2 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  14 __libc_csu_fini</span><br><span class="line">    46: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND puts@@GLIBC_2.2.5</span><br><span class="line">    48: 00000000000006d4     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  15 _fini</span><br><span class="line">    49: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND __libc_start_main@@GLIBC_</span><br><span class="line">    54: 0000000000000660   101 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  14 __libc_csu_init</span><br><span class="line">    56: 0000000000000530    43 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  14 _start</span><br><span class="line">    58: 000000000000063a    34 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  14 main</span><br><span class="line">    61: 0000000000000000     0 FUNC    WEAK  <span class="built_in"> DEFAULT </span> UND __cxa_finalize@@GLIBC_2.2</span><br><span class="line">    62: 00000000000004e8     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  11 _init</span><br></pre></td></tr></table></figure></p>
<ul>
<li>从这里看我们所写的main函数排在了58位,可见实际在mian()运行前确实运行了很多函数</li>
<li>在编译链接时,第一个入口函数地址是<code>_start</code></li>
</ul>
<p>借此我们可以编写一个自己的<code>_start</code>函数<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//m</span>ain()放前面是因为入口函数为自己定义的_start,这里的main()相当于一个子函数</span><br><span class="line">int main(void )</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">"hello world 1 !\n"</span>);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 这里必须调用<span class="keyword">exit</span>()来善后,否则会core dump</span><br><span class="line">int _start(void) </span><br><span class="line">&#123; </span><br><span class="line">    printf(<span class="string">"hello world 2 !\n"</span>);</span><br><span class="line">	main();</span><br><span class="line">	<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译链接时不使用标准开始文件,而是使用自己写的<code>_start</code><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*gcc        -nostartfiles</span></span><br><span class="line"><span class="comment">                    Do not use the standard system startup files when linking.  The standard system</span></span><br><span class="line"><span class="comment">                    libraries are used normally, unless -nostdlib or -nodefaultlibs is used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gcc test<span class="selector-class">.c</span> -nostartfiles  &amp;&amp; ./<span class="selector-tag">a</span>.out</span><br><span class="line"></span><br><span class="line">&gt;   hello world <span class="number">2</span> !</span><br><span class="line">     hello world <span class="number">1</span> !</span><br></pre></td></tr></table></figure></p>
<p>再查看二进制文件<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">readelf -s a.out | grep FUNC</span><br><span class="line">   </span><br><span class="line">&gt;   1: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND puts@GLIBC_2.2.5 (2)</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND exit@GLIBC_2.2.5 (2)</span><br><span class="line">    22: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND puts@@GLIBC_2.2.5</span><br><span class="line">    25: 00000000000003a7    31 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  10 _start</span><br><span class="line">    27: 0000000000000390    23 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>  10 main</span><br><span class="line">    28: 0000000000000000     0 FUNC    GLOBAL<span class="built_in"> DEFAULT </span> UND exit@@GLIBC_2.2.5</span><br></pre></td></tr></table></figure></p>
<ul>
<li>相对比使用标准开始文件这里少了很多函数</li>
<li>由于链接时还是使用了系统库,所以程序还是能跑起来的</li>
</ul>
<p>另外一种方法是使用GNU特色之gcc关键字</p>
<blockquote>
<p>关键字<code>__attribute__</code>可以为函数（Function Attributes），变量（Variable Attributes）和结构成员（Type Attributes）赋属性。具体可以查看gcc手册（<a href="http://gcc.gnu.org/onlinedocs/）" target="_blank" rel="noopener">http://gcc.gnu.org/onlinedocs/）</a></p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键字需要在定义之前</span></span><br><span class="line"></span><br><span class="line"> __attribute__((<span class="function"><span class="keyword">constructor</span>))<span class="title">void</span> <span class="title">before</span><span class="params">()</span>;</span></span><br><span class="line"></span><br><span class="line">__attribute__((<span class="function"><span class="keyword">destructor</span>))<span class="title">void</span> <span class="title">after</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span>__<span class="title">attribute__</span><span class="params">((constructor))</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world  !\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*int _start(void) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void m()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	printf("%d ",666);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; 666 hello world  !</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/4912a1dc8a50" target="_blank" rel="noopener">可执行文件格式说明</a><br><a href="https://www.jianshu.com/p/dda61084f9b5" target="_blank" rel="noopener">c语言中<strong>attribute</strong>的意义</a><br><a href="https://www.jb51.net/article/62360.htm" target="_blank" rel="noopener">C语言之没有main函数的helloworld示例</a><br><a href="https://bbs.csdn.net/topics/300103318#r_78088969" target="_blank" rel="noopener">一个c程序在执行main函数之前和main之后都做了那些事情啊？</a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>利用systemd添加开机自启服务</title>
    <url>/2020/01/31/%E5%88%A9%E7%94%A8systemd%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>不知为何,mint开机时默认开机亮度为100%,虽然近着看也无大碍,但从远处看发觉屏幕真刺眼啊,想着开机自动可以调节,便有了此文</p>
<h1 id="之前用过的开机自启方法"><a href="#之前用过的开机自启方法" class="headerlink" title="之前用过的开机自启方法"></a>之前用过的开机自启方法</h1><p>随着系统越来越新,对之前sysV的管理方式支持也越来越少了,人也是需要与时渐进的</p>
<h3 id="etc-rc-local"><a href="#etc-rc-local" class="headerlink" title="/etc/rc.local"></a>/etc/rc.local</h3><p>在较老的Ubuntu16.04上还可以发现<code>/etc/rc.local</code>的身影<br><img src="/images/20200131=0.png" alt></p>
<ul>
<li>可以看出该脚本在每个运行级别启动(如init 5)时被执行</li>
<li>要注意添加文件的执行位</li>
</ul>
<h3 id="etc-init-d"><a href="#etc-init-d" class="headerlink" title="/etc/init.d"></a>/etc/init.d</h3><p><code>/etc/init.d/</code>目录下存放的是各种可执行文件,可直接运行关闭</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Usage</span>: /etc/init.d/dbus &#123;start|stop|reload|restart|force-reload|status&#125;</span><br><span class="line"></span><br><span class="line"># 等同于</span><br><span class="line"></span><br><span class="line">service dbus &#123;start|stop|reload|restart|force-reload|status&#125;</span><br></pre></td></tr></table></figure>
<p>需要新建自己的启动项也不难<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要写成符合LSB规范</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">vi /etc/init.d/mysh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo</span> <span class="string">chmod +x /etc/init.d/mysh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># centos </span></span><br><span class="line"> <span class="attr">sudo</span> <span class="string">chkconfig --add(--remove) mysh</span></span><br><span class="line"><span class="comment"># debian</span></span><br><span class="line"> <span class="attr">sudo</span> <span class="string">sudo update-rc.d mysh defaults 5</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>update-rc.d</code>类似于<code>chkconfig</code>,具体见<code>man update-rc.d</code><br><a href="https://zh.opensuse.org/openSUSE:Packaging_init_scripts" target="_blank" rel="noopener">openSUSE:How to write a sysvinit script</a><br><a href="https://blog.csdn.net/gu_87_2008/article/details/47185767" target="_blank" rel="noopener">LSB参考资料</a></li>
</ul>
<h3 id="zshrc"><a href="#zshrc" class="headerlink" title="~/.zshrc"></a>~/.zshrc</h3><p>这种只适用于终端模式</p>
<h1 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h1><p>先了解一下什么是systemd</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/Systemd" target="_blank" rel="noopener">systemd</a>是Linux电脑操作系统之下的一套中央化系统及设置管理程序（init），包括有守护进程、程序库以及应用软件，由Lennart Poettering带头开发。其开发目标是提供更优秀的框架以表示系统服务间的依赖关系，并依此实现系统初始化时服务的并行启动，同时达到降低Shell的系统开销的效果，最终代替现在常用的System V与BSD风格init程序。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 查看当前系统是以哪种启动方式启动的</span><br><span class="line">ps -p1 </span><br><span class="line"></span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">    <span class="number">1</span>  ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> systemd</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可见当前系统是以systemd启动的,而不是sysV风格的init</p>
<h3 id="什么是-Systemd-service？"><a href="#什么是-Systemd-service？" class="headerlink" title="什么是 Systemd service？"></a>什么是 Systemd service？</h3><blockquote>
<p>是一种以 .service 结尾的单元（unit）配置文件，用于控制由 systemd 控制或监视的进程。简单说，用于后台以守护精灵（daemon）的形式运行程序。</p>
</blockquote>
</li>
<li><p>systemd service 文件在/etc/systemd/system</p>
</li>
</ul>
<p>而总体来说,一个systemd service 分为3个部分</p>
<ol>
<li>unit(控制单元)定义</li>
<li>service的定义</li>
<li>install 的定义</li>
</ol>
<h3 id="unit部分"><a href="#unit部分" class="headerlink" title="unit部分"></a>unit部分</h3><p>在 Systemd 中，所有引导过程中 Systemd 要控制的东西都是一个单元</p>
<p>单元文件后缀有.serivce、.target、.path,作为普通用户,一般接触的最多是.service</p>
<p>单元类型有很多:</p>
<ul>
<li>系统服务</li>
<li>系统服务</li>
<li>套接字（socket）</li>
<li>设备</li>
<li>挂载点</li>
<li>自动挂载点</li>
<li>等等</li>
</ul>
<p>那么在我们编写的这个.service单元,就应该最先申明这个单元<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Set brightness</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Description就是描述信息啦</li>
</ul>
<p>一些重要的关键字:</p>
<ul>
<li>Requires: 这个单元启动了，那么它「需要」的单元也会被启动; 它「需要」的单元被停止了，它自己也活不了。[就类似于安装软件时的依赖关系]</li>
<li>Wants：本单元启动了，它「想要」的单元也会被启动。但是启动不成功，对本单元没有影响</li>
<li>Before/After: 用于控制启动顺序</li>
</ul>
<p>现在就可以写出一个相对完整的[Unit]定义了<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Ｕnit]</span></span><br><span class="line"><span class="attr">Description</span> = unit demo</span><br><span class="line"><span class="attr">After</span> = x11-common.service</span><br></pre></td></tr></table></figure></p>
<h3 id="service部分"><a href="#service部分" class="headerlink" title="service部分"></a>service部分</h3><p>[Unit]用于识别单元，那么[Service]就是定义服务自身了</p>
<p>Tpye为设置进程的启动类型</p>
<ul>
<li>simple : 为默认的启动方式,systemd 会认为在创建了该服务的主服务进程之后，该服务就已经启动完成。</li>
<li>oneshot :与 simple 类似，不同之处在于， 只有在该服务的主服务进程退出之后，systemd 才会认为该服务启动完成，才会开始启动后继单元。适用于那些被一次性执行的任务或者命令</li>
<li>forking : 用于守护进程,即调用fork(),父进程退出</li>
</ul>
<p>ExecStart为在启动该服务时需要执行的 命令行(命令+参数)</p>
<ul>
<li>除非 Type=oneshot ，否则必须且只能设置一个命令行。 仅在Type=oneshot 的情况下，才可以设置任意个命令行(包括零个)， 多个命令行既可以在同一个 ExecStart= 中设置，也可以通过设置多个 ExecStart= 来达到相同的效果。多行用<code>;\</code>分开</li>
<li>命令必须是绝对路经或不含斜线的文件名</li>
</ul>
<p>ExecStop、ExecReload等与ExecStart类似</p>
<ul>
<li>但ExecStart和ExecStop必须至少存在一个</li>
</ul>
<p>好了，现在可以完善[Service]部分了<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Tpye</span>=<span class="literal">on</span>eshot</span><br><span class="line"><span class="attr">ExecStart</span>=/home/user/brightness.sh</span><br></pre></td></tr></table></figure></p>
<p>brightness.sh部分，记得加可执行权限<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash </span></span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 75 &gt; /sys/class/backlight/nvidia_0/brightness</span><br><span class="line"><span class="comment"># 这里我的显卡是nvdia的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="install部分"><a href="#install部分" class="headerlink" title="install部分"></a>install部分</h3><p>[Install]用于解释systemd怎么装载服务</p>
<ul>
<li>WantedBy：设置服务被谁装载，一般设置为multi-user.target</li>
<li>Alias：为service设置一个别名，可以使用多个名字来操作服务。</li>
<li>Also：在安装这个服务时候还需要的其他服务</li>
</ul>
<p>至此一个完整的开机调节屏幕亮度就出现了<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span> = set brightness</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span> = <span class="literal">on</span>eshot</span><br><span class="line"><span class="attr">ExecStart</span> = /etc/brightness.sh</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span> = multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>Ref:<a href="https://segmentfault.com/a/1190000014740871" target="_blank" rel="noopener">如何编写一个Systemd Service</a><br><a href="https://zh.opensuse.org/openSUSE:How_to_write_a_systemd_service" target="_blank" rel="noopener">openSUSE：如何编写 Systemd 服务文件</a><br><a href="http://www.jinbuguo.com/systemd/systemd.service.html" target="_blank" rel="noopener">systemd.service 中文手册</a><br><a href="https://wiki.ubuntu.com/SystemdForUpstartUsers" target="_blank" rel="noopener">SystemdForUpstartUsers</a></p>
<p>更多复杂细节的参数就请翻看man了</p>
<h3 id="最后添加启动项"><a href="#最后添加启动项" class="headerlink" title="最后添加启动项"></a>最后添加启动项</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加启动项</span></span><br><span class="line">sudo systemdctl <span class="builtin-name">enable</span> brightness.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除启动项</span></span><br><span class="line">sudo systemdctl <span class="builtin-name">disable</span> brightness.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于在这里并没有在service文件中写ExecStop、ExecReload等</span></span><br><span class="line"><span class="comment"># 所以 systemdctl stop(reload) brightness.service  自然是无效的</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小总结之二分搜索</title>
    <url>/2019/12/01/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%80%BB%E7%BB%93%E4%B9%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>在计算机科学中，<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二分查找算法</a>（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p>二分查找算法在情况下的复杂度是对数时间，进行 <strong>O(log n)</strong> 次比较操作(n在此处是数组的元素数量，O是大O记号，log 是对数）。二分查找算法使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。</p>
<h1 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#define numSize <span class="number">6</span></span><br><span class="line">                                                    <span class="comment">// l   r   mid     </span></span><br><span class="line"><span class="built_in">int</span> l = <span class="number">0</span>;                                          <span class="comment">// 0   6   3</span></span><br><span class="line"><span class="built_in">int</span> r = numSize;                                    <span class="comment">// 4   6   5</span></span><br><span class="line">                                                    <span class="comment">// 4   5   4    return</span></span><br><span class="line"><span class="built_in">int</span> nums[numSize] = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">64</span>,<span class="number">132</span>,<span class="number">1322</span>&#125;;                   </span><br><span class="line"><span class="built_in">int</span> t = <span class="number">132</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> mid = l+(r-l)/<span class="number">2</span>; <span class="comment">//防止 mid = (l+r)/2 溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t == nums[mid])</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t &gt; nums[mid])</span><br><span class="line">        l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; nums[mid])</span><br><span class="line">            r = mid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">// 此时 l == r</span></span><br></pre></td></tr></table></figure>
<h1 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#define numSize <span class="number">6</span></span><br><span class="line">                                                    <span class="comment">// l    r   mid</span></span><br><span class="line"><span class="built_in">int</span> l = <span class="number">0</span>;                                          <span class="comment">// 0    5   2</span></span><br><span class="line"><span class="built_in">int</span> r = numSize<span class="number">-1</span>;                                  <span class="comment">// 3    5   4   </span></span><br><span class="line">                                                    <span class="comment">// 4    5   4   return</span></span><br><span class="line"><span class="built_in">int</span> nums[numSize] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">61</span>,<span class="number">311</span>,<span class="number">455</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> t = <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(t == nums[mid])</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t &gt; nums[mid])</span><br><span class="line">        l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; nums[mid])</span><br><span class="line">            r = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>  l; <span class="comment">// 此时需要根据实际情况返回 l或r</span></span><br></pre></td></tr></table></figure>
<h1 id="寻找边界"><a href="#寻找边界" class="headerlink" title="寻找边界"></a>寻找边界</h1><p>对应的是<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的</span><br><span class="line">开始位置和结束位置。</span><br><span class="line"></span><br><span class="line">你的算法时间复杂度必须是 O(log n) 级别。</span><br><span class="line"></span><br><span class="line">如果数组中不存在目标值，返回 [<span class="number">-1</span>, <span class="number">-1</span>]。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>* searchRange(<span class="built_in">int</span>* nums, <span class="built_in">int</span> numsSize, <span class="built_in">int</span> target, <span class="built_in">int</span>* returnSize)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> *a =(<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>)*<span class="number">2</span>) ;</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">*returnSize = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(numsSize &lt; <span class="number">1</span>)</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> r = numsSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找左边界</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">         r = mid;   <span class="comment">// 往左缩小边界，直至找到左边界</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l&gt;numsSize<span class="number">-1</span> || nums[l]!=target)  <span class="comment">// 判断是否超出数组边界或没有目标值</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        </span><br><span class="line">    a[<span class="number">0</span>]=l;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时的l是已经在上一步寻找过的左边界</span></span><br><span class="line">r = numsSize;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">       l = mid +<span class="number">1</span> ;     <span class="comment">// 向右缩小边界，直至找到右边界</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            l = mid +<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span>        </span><br><span class="line">            r = mid ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">1</span>] = l<span class="number">-1</span>;     <span class="comment">// 此时需要 **l-1**是因为 (l=r=mid + 1) == (mid = l - 1)   </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些好的参考题解"><a href="#一些好的参考题解" class="headerlink" title="一些好的参考题解"></a>一些好的参考题解</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">1</a><br><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">2</a></p>
<p><del>😔最近好久没看书了，该捡起来读了</del></p>
<p><del>书非借哪能读啊</del></p>
]]></content>
      <tags>
        <tag>c</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>学习正则表达式</title>
    <url>/2019/08/02/%E2%80%9C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%9D/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>对于正则表达式，对它的第一印象是躺在书架上的一本又老又厚的《正则表达式》</p>
<p>不知怎的，竟对其报其畏敬之心，便心想终有一天要学学看</p>
<p>殊不知,早在日常使用中早已用到正则，如 *通配符</p>
<h2 id="什么是正则"><a href="#什么是正则" class="headerlink" title="什么是正则"></a>什么是正则</h2><p>正则表达式是一种特殊的字符串模式，用于匹配一组字符串，换句话说，正则表达式就是记录文本规则的代码。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">1-9</span>](<span class="link">[0-9]&#123;5,11&#125;</span>)</span><br><span class="line">用于匹配qq号</span><br></pre></td></tr></table></figure>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式中使用的 14 个元字符分别有相应的特殊含义。如果你想将这些字符作为字面值使用，必须在该字符前加一个反斜线将其转义。例如，你可以像这样 \$ 将美元符转义，或像这样 \ 将反斜线转义。</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配任意字符</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">对字符转义</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">选择操作（或）</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">行起始锚位符</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">行结束锚位符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配零次或一次的量词</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配零次或多次的量词</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">匹配一次或多次的量词</td>
</tr>
<tr>
<td style="text-align:center">[</td>
<td style="text-align:center">字符组起始</td>
</tr>
<tr>
<td style="text-align:center">]</td>
<td style="text-align:center">字符组结束</td>
</tr>
<tr>
<td style="text-align:center">{</td>
<td style="text-align:center">量词或代码块起始</td>
</tr>
<tr>
<td style="text-align:center">}</td>
<td style="text-align:center">量词或代码块结束</td>
</tr>
<tr>
<td style="text-align:center">(</td>
<td style="text-align:center">分组起始</td>
</tr>
<tr>
<td style="text-align:center">)</td>
<td style="text-align:center">分组结束</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">其他常用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任意的空白符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">匹配除数字外的字符</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">n 是一个非负整数，匹配确定的 n 次</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">至少匹配n 次</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">最少匹配 n 次且最多匹配 m 次</td>
</tr>
</tbody>
</table>
<h2 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">以这个表达式为例：a.*<span class="keyword">b，它将会匹配最长的以a开</span></span><br><span class="line"><span class="keyword">始，以b结束的字符串。如果用它来搜索aabab的话，</span></span><br><span class="line"><span class="keyword">它会匹配整个字符串aabab。这被称为贪婪匹配。</span></span><br></pre></td></tr></table></figure></p>
<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<p>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</p>
<h2 id="环视"><a href="#环视" class="headerlink" title="环视"></a>环视</h2><p>环视是一种非捕获分组，它根据某个模式之前或之后的内容匹配其他模式。环视也称为零宽度断言。</p>
<p>环视包括：</p>
<ul>
<li>正前瞻；(?=  这意味着要匹配某个模式时，需要在它后面找到含有给定前瞻模式的内容</li>
<li>反前瞻；(?!  这意味着要匹配某个模式时，需要在它后面找不到含有给定前瞻模式的内容</li>
<li>正后顾；(?&lt;= 这意味着要匹配某个模式时，需要在它前面找到含有给定后顾模式的内容 </li>
<li>反后顾。(?&lt;! 这意味着要匹配某个模式时，需要在它前面找不到含有给定后顾模式的内容</li>
</ul>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">比如<span class="symbol">\b</span><span class="symbol">\w</span>+(?=ing<span class="symbol">\b</span>)，匹配以ing结尾的单词的前面部分</span><br><span class="line">(除了ing以外的部分)，如查找I'm singing while you'</span><br><span class="line">re dancing.时，它会匹配sing和danc。</span><br><span class="line"></span><br><span class="line">比如(?&lt;=<span class="symbol">\b</span>re)<span class="symbol">\w</span>+<span class="symbol">\b</span>会匹配以re开头的单词的后半部分</span><br><span class="line">(除了re以外的部分)，例如在查找reading a book时，</span><br><span class="line">它匹配ading。</span><br></pre></td></tr></table></figure>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul>
<li><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">^([\d]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;.)&#123;<span class="number">3</span>&#125;[\d]&#123;<span class="number">3</span>&#125;$</span><br><span class="line">匹配是***.***.***.***  (*为数字)</span><br></pre></td></tr></table></figure>
<p> 在正则中有子表达式的概念，用()表示，(){3}则表示将()里的匹配3次</p>
</li>
<li><p>[ ]用于区分不同表达式或表示字符组，如[1-9]</p>
</li>
<li><p>| 为元字符中或的意思</p>
</li>
</ul>
<h2 id="大礼包解析"><a href="#大礼包解析" class="headerlink" title="大礼包解析"></a>大礼包解析</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;dd&gt;</span>.*?board-<span class="built_in">index</span>.*?&gt;(\d+)&lt;/i&gt;.*?data-src=<span class="string">"(.*?)"</span>.*?name<span class="comment">"&gt;&lt;a</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 从<span class="symbol">&lt;dd&gt;</span>开始最小匹配到board-<span class="built_in">index</span></span><br><span class="line"><span class="number">2</span>. 再继续最小匹配到&gt;</span><br><span class="line"><span class="number">3</span>. 然后匹配一个或多个数字到&lt;/i&gt;</span><br><span class="line"><span class="number">4</span>. 最小匹配到data-src= <span class="string">"最小匹配"</span></span><br><span class="line"><span class="number">5</span>. 最小匹配到name<span class="comment">"&gt;&lt;a</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小总结之动态规划、双指针</title>
    <url>/2019/11/17/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p><del>发现自己好久没有碎碎念了，hhh，最近刷题的感觉也是神奇，百思不知其错在哪的代码放那呆一会过会就能过了？？？<br>有时把错了的实例输入测试区然后通过了执行也过了？？？</del></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">动态规划</a>（英语：Dynamic programming，简称DP）常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
</blockquote>
<p>  动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p>
<p>  通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p>个人总结：</p>
<ol>
<li>先想大问题能否化为小问题的组合</li>
<li>想好存放历史值的数组所代表的意思</li>
<li>找出状态方程（小问题之间与大问题的联系）</li>
<li>初始化边界条件</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw" target="_blank" rel="noopener">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a><br><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655" target="_blank" rel="noopener">背包问题</a></p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>典型：<br>移除元素</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums 和一个值 <span class="keyword">val</span>，你需要原地移除所有数值等于 <span class="keyword">val</span> 的元素，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 <span class="constructor">O(1)</span> 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">核心思想：可以使用两个指针，一个遍历原数组，一个标记新数组，判断的条件就是元素时候和给定的<span class="keyword">val</span>相等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> remove<span class="constructor">Element(<span class="params">int</span><span class="operator">*</span> <span class="params">nums</span>, <span class="params">int</span> <span class="params">numsSize</span>, <span class="params">int</span> <span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;numsSize<span class="operator"> &amp;&amp; </span>j&lt;numsSize) </span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums<span class="literal">[<span class="identifier">i</span>]</span>!=<span class="keyword">val</span>)</span><br><span class="line">                        nums<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>=nums<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">                </span><br><span class="line">                    i++; </span><br><span class="line">                &#125;</span><br><span class="line">            return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉用了双指针就不用大量的套用for()来遍历了，快速排序也是双指针</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void q_sort(int a[],int l,int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        int <span class="built_in">i</span>=l,<span class="built_in">j</span>=n;</span><br><span class="line">        int val = a[l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">i</span>&lt;<span class="built_in">j</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> &lt; <span class="built_in">j</span> &amp;&amp; a[<span class="built_in">j</span>] &lt; val )</span><br><span class="line">                <span class="built_in">j</span>--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">j</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                a[<span class="built_in">i</span>++] = a[<span class="built_in">j</span>];    </span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> &lt; <span class="built_in">j</span> &amp;&amp; a[<span class="built_in">i</span>] &gt;= val )</span><br><span class="line">                <span class="built_in">i</span>++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">j</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[<span class="built_in">j</span>] = a[<span class="built_in">i</span>];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="built_in">i</span>] = val;</span><br><span class="line"></span><br><span class="line">        q_sort(a,l,<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">        q_sort(a,<span class="built_in">i</span>+<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程shell的使用</title>
    <url>/2020/05/01/%E5%A4%9A%E8%BF%9B%E7%A8%8Bshell%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>在正常情况下，shell执行一个命令都是fork一个子进程再exec相应命令</p>
<p>shell也可以实现多进程实现并发</p>
<p>将要用到多进程的语句用<code>{  }</code>括起来，在最后加上<code>&amp;</code>，就会在运行时运行多个子shell实现多进程</p>
<p>上面就类似于c语言中的<code>fork()</code>,那不得不说与之搭配的<code>wait（）</code>，shell里对应的是<code>wait</code></p>
<ul>
<li><code>wait</code> 默认是等待子进程全部退出，后接pid则为等待指定进程退出</li>
</ul>
<p>来一个批量ping的脚本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> &#123;1..254&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep 3</span><br><span class="line">    ping 192.168.1.<span class="variable">$ip</span> -c 3 &gt; /dev/null</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        hostname=`nslookup 192.168.1.<span class="variable">$ip</span> | awk <span class="string">'&#123;print $4&#125;'</span>`</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$hostname</span> != <span class="string">"find"</span> ]; <span class="comment">#当没找到hostname时为“find”</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"192.168.1.<span class="variable">$ip</span> <span class="variable">$hostname</span> is up"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"192.168.1.<span class="variable">$ip</span> is up"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;&amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用<code>ps aux | grep ping | grep -v grep | wc -l</code>来验证，结果为254，也就是实实在在有254个进程在并发实行</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>周年事记</title>
    <url>/2020/04/25/%E5%91%A8%E5%B9%B4%E4%BA%8B%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<blockquote>
<p>本来觉得摆脱标签活出自己就已经是尽力了,可渐渐却在追求自我的路上不断给自己加上标签,真像一头猪啊</p>
</blockquote>
<p>始终忘不了之前看过的一部电影,镜头先是一个喧闹的酒吧,人们在快活地跳着舞,随着是一个黑白的、无声音的、人们在地上诡异地扭动的上帝视角长镜头。那几分钟，仿佛是一个自我的觉醒</p>
<blockquote>
<p>一个无限遥远的目标不是目标,而是一个欺骗<br>  一个无限遥远的理由也不是理由,而是一个借口</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>思维导图简单学习</title>
    <url>/2019/05/11/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着时间变迁，发现自己虽然看的书在慢慢变多，但与此遗忘之前的内容越来越多，想着不总结的话再过久点可能就和<del>没看</del>差不多了,所以要慢慢养成总结的习惯啊</p>
<hr>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>心智图（英语：Mind Map），又称脑图、心智地图、脑力激荡图、思维导图、灵感触发图、概念地图、或思维地图，是一种图像式思维的工具以及一种利用图像式思考辅助工具来表达思维的工具。<br>心智图是使用一个中央关键词或想法引起形象化的构造和分类的想法;它用一个中央关键词或想法以辐射线形连接所有的代表字词、想法、任务或其它关联项目的图解方式。它可以利用不同的方式去表现人们的想法，如引题式，可见形象化式，建构系统式和分类式。它普遍地用作在研究、组织、解决问题和政策制定中。<br>心智图是一张集中了所有关连资讯的语义网路或认知体系图像。所有关连资讯都是被辐射线形及非线性图解方式接连在一起，以脑力激荡法为本去创建一个适当或相关的概念性组织任务框架。但脑力激荡法并非以制式的方式去互相连接语义网路或认知体系，亦即是可以自由相连接使用的。元素是直觉地以概念的重要性而被安排及组织入分组、分支，或区域中。会集知识方法能够支持现有的记忆，去思考语义的结构资讯。       </p>
<blockquote>
<p>—<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E5%9B%BE" target="_blank" rel="noopener">wiki</a></p>
</blockquote>
</blockquote>
<a id="more"></a>
<blockquote>
<p><img src="/images/20190511.jpg" alt="如何画思维导图"></p>
</blockquote>
<blockquote>
<p><img src="/images/20190511=2.jpg" alt="优秀实例"></p>
<blockquote>
<p>引自东尼·博赞《思维导图：大脑使用说明书》</p>
</blockquote>
</blockquote>
<p>可见其优越的直观性</p>
<hr>
<h1 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h1><p><a href="https://blog.csdn.net/qq_16093323/article/details/80967867" target="_blank" rel="noopener">csnd相关 </a></p>
<hr>
<h1 id="xmind初步探索"><a href="#xmind初步探索" class="headerlink" title="xmind初步探索"></a>xmind初步探索</h1><ul>
<li>默认从中心主题开始,为一切的基础</li>
<li>双击或tab可创立可自由拖动的主题</li>
</ul>
<ul>
<li>新建中有许多模板和各种样式供选择</li>
</ul>
<ul>
<li>不选中任意主题，然后在界面中的右下角按下图所示进行设置，变得多彩<br><img src="/images/20190511=3.png" alt="示意图"></li>
<li>在最右侧有一系列实用工具，如插入图片查看大纲等等</li>
</ul>
<p>于是呀要现学现用，总结了上上周做的事<br><img src="/images/20190511=4.png" alt="第八周"></p>
<hr>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>刚刚起步，感觉有些想表达不知怎么用线条联系起来，可能还缺少一些训练吧   <del>~先听听歌吧</del>~~</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22716492&auto=0&height=66"></iframe>










]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>xmind</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一个xshell自动化脚本</title>
    <url>/2019/12/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAxshell%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>在平时使用xshell的时候，有时需要大量进行一些重复的工作，如telnet至一个主机，然后又telnet到另一个主机，不同主机登录配置又不太一样，时间一长又难免会忘记，故萌生出写一些自动化脚本来帮我登陆进行操作</p>
<p><img src="/images/20191201=0.png" alt><br>xshell支持运行脚本(vb、python、js)</p>
<p><img src="/images/20191201=1.png" alt><br><img src="/images/20191201=2.png" alt><br>为官方帮助文档所提供的api</p>
<table>
<thead>
<tr>
<th style="text-align:center">常用功能</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Clear()</td>
<td style="text-align:center">清屏</td>
</tr>
<tr>
<td style="text-align:center">Send(LPCTSTR lpszStrToSend)</td>
<td style="text-align:center">向屏幕(终端)发送字符</td>
</tr>
<tr>
<td style="text-align:center">WaitForString(LPCTSTR lpszString)</td>
<td style="text-align:center">等待屏幕出现指定字符(就像是if条件语句)</td>
</tr>
</tbody>
</table>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">def <span class="constructor">Main()</span>:</span><br><span class="line"></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('<span class="params">ssh</span> <span class="params">cc</span>@127.0.0.1\<span class="params">r</span>')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">WaitForString('Password:')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('<span class="params">your</span> <span class="params">password</span>')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('\<span class="params">r</span>')</span></span><br><span class="line"></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('<span class="params">telnet</span> <span class="operator">*</span>.<span class="operator">*</span>.<span class="operator">*</span>.<span class="operator">*</span> ')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('\<span class="params">r</span>')</span></span><br><span class="line">	xsh.Session.<span class="constructor">Sleep(10)</span></span><br><span class="line"></span><br><span class="line">   	xsh.Screen.<span class="constructor">WaitForString('Primary-1EF6E9 <span class="params">login</span>:')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('<span class="params">admin</span>\<span class="params">r</span>')</span></span><br><span class="line">	xsh.Session.<span class="constructor">Sleep(10)</span></span><br><span class="line">	xsh.Screen.<span class="constructor">WaitForString('Password:')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('<span class="params">your</span> <span class="params">password</span>')</span></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('\<span class="params">r</span>')</span></span><br><span class="line"></span><br><span class="line">	xsh.Screen.<span class="constructor">Send('<span class="params">show</span> <span class="params">adoption</span> <span class="params">offline</span>\<span class="params">r</span>')</span></span><br><span class="line">   </span><br><span class="line">   	xsh.Screen.<span class="constructor">Send('<span class="params">r</span>\<span class="params">r</span>')</span></span><br></pre></td></tr></table></figure>
<p>虽然最初设想是全自动配合sed实现格式化输出内容，但没能找到重定向屏幕内容的方法，所以只能先告一段落</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>当KDE Connect遇上Zerotier</title>
    <url>/2020/02/20/%E5%BD%93KDE-Connect%E9%81%87%E4%B8%8AZerotier/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="KDE-Connect"><a href="#KDE-Connect" class="headerlink" title="KDE Connect"></a>KDE Connect</h1><p>在机缘巧合之下偶尔得知了<code>KDE Connect</code>,发现是意外的好用,重磅功能有电脑手机剪贴板共享、通知同步、查找不知道放哪的手机、同步文件等</p>
<p>参考<a href="https://www.omgubuntu.co.uk/2017/01/kde-connect-indicator-ubuntu" target="_blank" rel="noopener">How to Install KDE Connect on Ubuntu 16.04 </a>3在mint下非KDE桌面安装好了</p>
<ul>
<li><p>添加仓库</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:webupd8team/indicator-kdeconnect</span><br><span class="line"></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install kdeconnect indicator-kdeconnect</span><br></pre></td></tr></table></figure>
</li>
<li><p>手机版获取<a href="https://play.google.com/store/apps/details?id=org.kde.kdeconnect_tp" target="_blank" rel="noopener">google play</a></p>
</li>
</ul>
<p>安装好之后,已经是能看到了,打开<br><img src="/images/20200221=0.png" alt></p>
<ul>
<li>点击通知栏那个小手机的图案,点击Request  pairing</li>
<li>这时确保手机与电脑在同一网段,此时手机已经能发现电脑了<br><img src="/images/20200221=1.png" alt></li>
<li>点击配对,OK完成,已经可以享受各种功能了,如果有防火墙的话需要放行<code>1714:1764端口</code><br><img src="/images/20200221=2.png" alt></li>
</ul>
<p><del>妈妈再也不用担心我用电脑收不到手机通知了</del><br><img src="/images/20200221=10.png" alt></p>
<h1 id="Zerotier"><a href="#Zerotier" class="headerlink" title="Zerotier"></a>Zerotier</h1><blockquote>
<p><a href="https://zerotier.com/" target="_blank" rel="noopener">来自官网的简介</a>Easily connect cloud, mobile, desktop, and data center resources anywhere.</p>
</blockquote>
<p>也是非常简单易用啊,可以方便的实现家里宽带无公网IP达到内网穿透远程访问的目的了</p>
<p>大体原理为建立了一个VPN,通过分配给你的IP地址直接进行访问</p>
<p>走流程一套</p>
<ul>
<li>先注册一个账号<a href="https://my.zerotier.com/" target="_blank" rel="noopener">this</a></li>
<li>点击网页上方的Networks,再新建一个Network<br><img src="/images/20200221=3.png" alt></li>
<li>填写名字描述<br><img src="/images/20200221=4.png" alt></li>
<li>选择网段<br><img src="/images/20200221=5.png" alt></li>
<li>设备认证<br><img src="/images/20200221=6.png" alt></li>
</ul>
<p><a href="https://www.zerotier.com/download/" target="_blank" rel="noopener">客户端下载</a><br>这里我只用到linux、Android端</p>
<ul>
<li><p>linux(DEB\RPM)</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">https:</span><span class="comment">//install.zerotier.com | sudo bash</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Android   <a href="https://play.google.com/store/apps/details?id=com.zerotier.one" target="_blank" rel="noopener">google play</a></p>
</li>
</ul>
<p>电脑端连接<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 查看加入退出网络,&lt;network&gt;为之前的网络号</span><br><span class="line">zerotier-cli </span><br><span class="line">        listnetworks            - List all networks</span><br><span class="line">        join &lt;network&gt;          - Join a network</span><br><span class="line">        leave &lt;network&gt;         - Leave a network</span><br><span class="line"></span><br><span class="line"># 或查看更多帮助</span><br><span class="line">zerotier-cli  -h</span><br><span class="line"></span><br><span class="line"># 加入后会多一个虚拟网卡</span><br><span class="line">ifconfig </span><br><span class="line"></span><br><span class="line">&gt;     随机的名字: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">2800</span></span><br><span class="line">        inet <span class="number">10.20</span><span class="number">.1</span><span class="number">.32</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">10.20</span><span class="number">.1</span><span class="number">.255</span></span><br><span class="line">        ether <span class="number">6</span>a:<span class="number">53</span>:fb:<span class="number">88</span>:<span class="number">82</span>:<span class="number">85</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">212</span>  bytes <span class="number">99227</span> (<span class="number">99.2</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">1791</span>  bytes <span class="number">382922</span> (<span class="number">382.9</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 查看当前路由表</span><br><span class="line">route</span><br><span class="line"></span><br><span class="line">&gt;      Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">    <span class="number">10.20</span><span class="number">.1</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>       <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          随机的名字</span><br><span class="line"># 不用担心没加路由,记得加入后要到网页设置那认证当前设备,才会有ip地址</span><br></pre></td></tr></table></figure></p>
<p>手机端连接,输入之前的网络号,如果是数据流量要到设置里勾选数据流量<br><img src="/images/20200221=7.png" alt></p>
<p>如果都成功的话,应该是可以相互ping通的,实测在数据流量下可以基本满足用Web端管理路由器的需求</p>
<h1 id="两者合体-–-gt"><a href="#两者合体-–-gt" class="headerlink" title="两者合体 –&gt;"></a>两者合体 –&gt;</h1><p>KDE Connect可以在内网中连接设备,Zerotier则可以创建一个虚拟大内网(VPN),恩恩那么两者一起用岂不是可以实现非相同网络环境下的同步</p>
<p>在手机端KDE Connect设置里点击<code>通过IP添加设备</code>,输入新增接口的IP地址<br><img src="/images/20200221=8.png" alt></p>
<p>果不其然,这是可以的,一个在wifi下,一个在数据流量下,成功实现互联<br><img src="/images/20200221=9.png" alt></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>网络</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>动手写一个自己的ping程序</title>
    <url>/2020/02/10/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84ping%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<blockquote>
<p>ping是一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。ping的运作原理是向目标主机传出一个ICMP的请求回显数据包，并等待接收回显回应数据包,器工作原理与声呐相似,所以叫ping</p>
</blockquote>
<p>ping功能的实现依赖于icmp协议,而icmp又依赖TCP/IP,换句话说,ping的实现是在IP层上的ICMP协议,所以不可避免的要用到IP协议和ICMP协议</p>
<h1 id="ip报头格式"><a href="#ip报头格式" class="headerlink" title="ip报头格式"></a>ip报头格式</h1><p><img src="/images/20200210=0.png" alt></p>
<p>对应起来的ip数据结构<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ip_v:<span class="number">4</span>;		<span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ip_v:<span class="number">4</span>;		<span class="comment">/* version */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint8_t</span> ip_tos;			<span class="comment">/* type of service */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ip_len;		<span class="comment">/* total length */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ip_id;		<span class="comment">/* identification */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ip_off;		<span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	IP_RF 0x8000			<span class="comment">/* reserved fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	IP_DF 0x4000			<span class="comment">/* dont fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	IP_MF 0x2000			<span class="comment">/* more fragments flag */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	IP_OFFMASK 0x1fff		<span class="comment">/* mask for fragmenting bits */</span></span></span><br><span class="line">    <span class="keyword">uint8_t</span> ip_ttl;			<span class="comment">/* time to live */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ip_p;			<span class="comment">/* protocol */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ip_sum;		<span class="comment">/* checksum */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ip_src</span>, <span class="title">ip_dst</span>;</span>	<span class="comment">/* source and dest address */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>虽然看上去很多,但这次用到的只有ip报头长度(ip_hl) </li>
<li>由上可知,一般情况下(没有选项的话)一个ip报头最大字节数为ip_hl<em>4(ip_hl以4字节为单位),而从数据结构的定义中可以看到ip_hl只定义用了4位,即无论什么情况下最大ip报头长度为15</em>4字节</li>
</ul>
<h1 id="ICMP报头格式"><a href="#ICMP报头格式" class="headerlink" title="ICMP报头格式"></a>ICMP报头格式</h1><p>介绍完IP报头,那么它后面的数据段也就是ICMP报头也需要介绍介绍</p>
<p><img src="/images/20200210=1.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/ip_icmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删了部分没用到的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  icmp_type;	<span class="comment">/* type of message, see below */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  icmp_code;	<span class="comment">/* type sub code */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> icmp_cksum;	<span class="comment">/* ones complement checksum of struct */</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ih_pptr;	<span class="comment">/* ICMP_PARAMPROB */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ih_gwaddr</span>;</span>	<span class="comment">/* gateway address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ih_idseq</span>		/* <span class="title">echo</span> <span class="title">datagram</span> */</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">uint16_t</span> icd_id;</span><br><span class="line">      <span class="keyword">uint16_t</span> icd_seq;</span><br><span class="line">    &#125; ih_idseq;</span><br><span class="line">&#125;icmp_hun;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	icmp_id		icmp_hun.ih_idseq.icd_id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	icmp_seq	icmp_hun.ih_idseq.icd_seq</span></span><br></pre></td></tr></table></figure>
<ul>
<li>与<code>struct icmp</code>定义差不多的还有<code>struct icmphdr</code>,hdr即为header的意思,定义的内容也差不多,毕竟实现的是同一个协议</li>
<li>这里要用到的是能够成最小报文的是icmp_type、icmp_code、icmp_cknum、icmp_id    、    icmp_seq(注意最后面两个是宏定义,用起来更方便了)</li>
<li>icmp_id用于标示一个icmp报文,icmp_seq表示发送顺序</li>
</ul>
<p>ICMP报头最开始的类型在头文件中定义的很清楚<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_ECHOREPLY		0	<span class="comment">/* Echo Reply			*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_DEST_UNREACH	3	<span class="comment">/* Destination Unreachable	*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_SOURCE_QUENCH	4	<span class="comment">/* Source Quench		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_REDIRECT		5	<span class="comment">/* Redirect (change route)	*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_ECHO		8	<span class="comment">/* Echo Request			*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_TIME_EXCEEDED	11	<span class="comment">/* Time Exceeded		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_PARAMETERPROB	12	<span class="comment">/* Parameter Problem		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_TIMESTAMP		13	<span class="comment">/* Timestamp Request		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_TIMESTAMPREPLY	14	<span class="comment">/* Timestamp Reply		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_INFO_REQUEST	15	<span class="comment">/* Information Request		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_INFO_REPLY		16	<span class="comment">/* Information Reply		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_ADDRESS		17	<span class="comment">/* Address Mask Request		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_ADDRESSREPLY	18	<span class="comment">/* Address Mask Reply		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_ICMP_TYPES		18</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里用到了发送时的<code>ICMP_ECHO</code>    和接收时用到的<code>ICMP_ECHOREPLY</code></li>
</ul>
<p>报文类型和代码段组合起来有很多种解释<br><img src="/images/20200210=2.png" alt></p>
<p>所以可以得到一个完整的定义了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/ip_icmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> <span class="title">s_icmp</span>;</span></span><br><span class="line"></span><br><span class="line">  s_icmp.icmp_type = ICMP_ECHO;			        <span class="comment">//报头类型</span></span><br><span class="line">  s_icmp.icmp_code = <span class="number">0</span>;					 <span class="comment">//表示状态的代码</span></span><br><span class="line">  s_icmp.icmp_cksum = <span class="number">0</span>;				  <span class="comment">//校验和</span></span><br><span class="line"> 	s_icmp.icmp_id = pid;				 <span class="comment">//标识</span></span><br><span class="line">s_icmp.icmp_seq = <span class="number">0</span>;					<span class="comment">//顺序号</span></span><br></pre></td></tr></table></figure></p>
<h1 id="发送icmp报文"><a href="#发送icmp报文" class="headerlink" title="发送icmp报文"></a>发送icmp报文</h1><p>由于ip协议是无连接的,自然不需要使用bind()或connect()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,     </span><br><span class="line">                   <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于sendto()成功与否,需要加上判断</li>
</ul>
<h1 id="接受报文"><a href="#接受报文" class="headerlink" title="接受报文"></a>接受报文</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                    struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure>
<ul>
<li>与上同理</li>
</ul>
<p>具体实现<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//超过3秒后即退出</span></span><br><span class="line">signal(SIGALRM, ping_stat);</span><br><span class="line">alarm(<span class="number">3</span>);															<span class="comment">//默认不处理超时信号则退出整个程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span> )&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span> recv_in;</span><br><span class="line">	socklen_t len = <span class="keyword">sizeof</span>(recv_in);</span><br><span class="line">	int recvlen ;</span><br><span class="line">	<span class="keyword">if</span>((recvlen =  recvfrom(sockfd,buf,BUFLEN,<span class="number">0</span>,(<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span> *)&amp;recv_in,&amp;len)) &lt;<span class="number">0</span> )</span><br><span class="line">		exit_error(<span class="string">"recv error "</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//若收到的报文长度小于最大ip报文头部长度,则受到的不是所需数据</span></span><br><span class="line">	<span class="keyword">if</span>(recvlen &gt; MAXIPLEN)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ip</span></span> *p_ip = (<span class="class"><span class="keyword">struct</span> <span class="title">ip</span></span> *)buf;</span><br><span class="line">		int iplen =p_ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">icmp</span></span> * p = (<span class="class"><span class="keyword">struct</span> <span class="title">icmp</span></span> *)(buf+iplen);               <span class="comment">//跳过ip首部</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//若收到的报文标识号不是自己规定的标识号或报文类型不是 reply则不是想要的报文</span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;icmp_id == pid  &amp;&amp; p-&gt;icmp_type == ICMP_ECHOREPLY)&#123;</span><br><span class="line">			recv_num++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外利用select来检查套接字是否可读,也就是是否收到回复,也不失为一种办法</p>
<h1 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/ip_icmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define SELECT 0</span></span><br><span class="line"><span class="comment">//#define NORMAL 0</span></span><br><span class="line"><span class="comment">/*1.如果只定义了SELECT,超时处理为selcet版实现</span></span><br><span class="line"><span class="comment">	2.如果只定义了NORMAL则为堵塞式实现(若ping的主机不回复,</span></span><br><span class="line"><span class="comment">	将一直堵塞,无超时处理)</span></span><br><span class="line"><span class="comment">	3.两者都没定义,超时处理为信号实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SELECT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  NORMAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMPDATALEN 56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXIPLEN 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXICMPLEN 76</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN MAXICMPLEN+MAXIPLEN+ICMPDATALEN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_pak</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unpack_pak</span><span class="params">(<span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ping_stat</span><span class="params">(<span class="keyword">int</span>  )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit_error</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pid;								</span><br><span class="line"><span class="keyword">int</span> sockfd;					</span><br><span class="line"><span class="keyword">char</span> buf[BUFLEN];</span><br><span class="line"><span class="keyword">char</span> *iplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> recv_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> send_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s [ip address]"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iplist = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    send_pak(iplist);</span><br><span class="line">    unpack_pak();</span><br><span class="line"></span><br><span class="line">    ping_stat(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*校验和算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nleft = len;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *w = buf;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每次相加以两字节为单位</span></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		sum += *w++;</span><br><span class="line">		nleft -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nleft == <span class="number">1</span>) &#123;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (&amp;ans) = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) w;</span><br><span class="line">		sum += ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">	sum += (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	ans = ~sum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送icmp包*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_pak</span><span class="params">(<span class="keyword">char</span> *iplist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protoent</span> * <span class="title">p_prote</span>;</span></span><br><span class="line">    p_prote= getprotobyname(<span class="string">"ICMP"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用当前进程号作为唯一标识号</span></span><br><span class="line">    pid = getpid();</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET,SOCK_RAW,p_prote-&gt;p_proto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    	exit_error(<span class="string">"socket error "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化icmp数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> <span class="title">s_icmp</span>;</span></span><br><span class="line"></span><br><span class="line">    s_icmp.icmp_type = ICMP_ECHO;			<span class="comment">//报头类型</span></span><br><span class="line">    s_icmp.icmp_code = <span class="number">0</span>;								 <span class="comment">//代码</span></span><br><span class="line">    s_icmp.icmp_cksum = <span class="number">0</span>;				             <span class="comment">//校验和</span></span><br><span class="line">   	s_icmp.icmp_id = pid;					             <span class="comment">//标识</span></span><br><span class="line"> 	s_icmp.icmp_seq = <span class="number">0</span>;					            <span class="comment">//顺序号</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    s_icmp.icmp_cksum = check_sum((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)&amp;s_icmp,<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr_in</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;s_addr_in,<span class="number">0</span>,<span class="keyword">sizeof</span>(s_addr_in));</span><br><span class="line">    s_addr_in.sin_family = AF_INET;</span><br><span class="line">    s_addr_in.sin_addr.s_addr = inet_addr(iplist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = sendto(sockfd,&amp;s_icmp,ICMPDATALEN+<span class="number">8</span>,<span class="number">0</span>,(struct sockaddr *)&amp;s_addr_in,<span class="keyword">sizeof</span>(s_addr_in));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        exit_error(<span class="string">"sendto error "</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			send_num++;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//收回root权限</span></span><br><span class="line">	setuid(getuid());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unpack_pak</span><span class="params">(<span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SELECT</span></span><br><span class="line"><span class="comment">/* 超时实现由select() 实现*/</span></span><br><span class="line"></span><br><span class="line">	fd_set rset;</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	FD_SET(sockfd,&amp;rset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置超时时间为5s</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span> = &#123;</span><span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = select(sockfds[i]+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		exit_error(<span class="string">"select error "</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">if</span>(ret != <span class="number">0</span> )</span><br><span class="line">					<span class="keyword">if</span>(FD_ISSET(sockfds[i--],&amp;rset))</span><br><span class="line">					&#123;</span><br><span class="line">						recv_num++;</span><br><span class="line">					&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NORMAL</span></span><br><span class="line"><span class="comment">/* 若recvfrom()一直收不到回复,将一直堵塞,无超时处理*/</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_in</span>;</span></span><br><span class="line">		<span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(recv_in);</span><br><span class="line">		<span class="keyword">int</span> recvlen ;</span><br><span class="line">		<span class="keyword">if</span>((recvlen =  recvfrom(sockfd,buf,BUFLEN,<span class="number">0</span>,(struct sockaddr *)&amp;recv_in,&amp;len)) &lt;<span class="number">0</span> )</span><br><span class="line">			exit_error(<span class="string">"recv error "</span>);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//若收到的报文长度小于最大ip报文部长度,则受到的不是所需数据</span></span><br><span class="line">		<span class="keyword">if</span>(recvlen &gt; MAXIPLEN)&#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">p_ip</span> = (<span class="title">struct</span> <span class="title">ip</span> *)<span class="title">buf</span>;</span></span><br><span class="line">				<span class="keyword">int</span> iplen =p_ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;				<span class="comment">//首部长度以4字节为单位</span></span><br><span class="line"></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> * <span class="title">p</span> = (<span class="title">struct</span> <span class="title">icmp</span> *)(<span class="title">buf</span>+<span class="title">iplen</span>);</span>		<span class="comment">//跳过ip首部</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">//若收到的报文标识号不是发送程序的pid或报文类型不是 reply则不是想要的报文</span></span><br><span class="line">				<span class="keyword">if</span>(p-&gt;icmp_id == pid  &amp;&amp; p-&gt;icmp_type == ICMP_ECHOREPLY)&#123;</span><br><span class="line">					recv_num++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"bad packet\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/*信号*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//超过3秒后即退出</span></span><br><span class="line">	signal(SIGALRM, ping_stat);</span><br><span class="line">	alarm(<span class="number">3</span>);															<span class="comment">//默认不处理超时信号则退出整个程序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span> )&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_in</span>;</span></span><br><span class="line">		<span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(recv_in);</span><br><span class="line">		<span class="keyword">int</span> recvlen ;</span><br><span class="line">		<span class="keyword">if</span>((recvlen =  recvfrom(sockfd,buf,BUFLEN,<span class="number">0</span>,(struct sockaddr *)&amp;recv_in,&amp;len)) &lt;<span class="number">0</span> )</span><br><span class="line">			exit_error(<span class="string">"recv error "</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(recvlen &gt; MAXIPLEN)&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">p_ip</span> = (<span class="title">struct</span> <span class="title">ip</span> *)<span class="title">buf</span>;</span></span><br><span class="line">			<span class="keyword">int</span> iplen =p_ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> * <span class="title">p</span> = (<span class="title">struct</span> <span class="title">icmp</span> *)(<span class="title">buf</span>+<span class="title">iplen</span>);</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(p-&gt;icmp_id == pid  &amp;&amp; p-&gt;icmp_type == ICMP_ECHOREPLY)&#123;</span><br><span class="line">				recv_num++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	该函数功能有两个,一为程序状态显示,二为信号处理*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ping_stat</span><span class="params">(<span class="keyword">int</span> foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(recv_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s is live\n"</span>,iplist);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s is dead\n"</span>,iplist);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit_error</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    perror(p);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>c</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>新年快到了啊</title>
    <url>/2019/12/31/%E6%96%B0%E5%B9%B4%E5%BF%AB%E5%88%B0%E4%BA%86%E5%95%8A/</url>
    <content><![CDATA[<p>真的是过去了就真的过去了</p>
<p>好啦 要快乐哈</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1360807373&auto=0&height=66"></iframe>
]]></content>
  </entry>
  <entry>
    <title>网络排障简单总结</title>
    <url>/2019/06/19/%E7%BD%91%E7%BB%9C%E6%8E%92%E9%9A%9C%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">telnet</td>
</tr>
<tr>
<td style="text-align:center">TCP</td>
<td style="text-align:center">传输层</td>
<td style="text-align:center">UDP</td>
</tr>
<tr>
<td style="text-align:center">ICMP</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center">IP</td>
</tr>
<tr>
<td style="text-align:center">ARP</td>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">mac</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">物理层</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ping 127.0.0.1</span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>
<p>此时通的话可排除本身tcp/ip协议栈和网络层以下的问题,若不通多半是物理线路问题</p>
<hr>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-tag">baidu</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure>
<p>其原理是ICMP中的TTL，若过程中出现*可能是路由器未开启功能或防火墙过滤</p>
<hr>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Dig是域信息搜索器的简称(Domain Information Groper),使用dig命令可以执行查询域名相关的任务。<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dig</span> baidu.<span class="keyword">com</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20190619=0.png" alt="dig"><br>其比较重要的有 </p>
<ul>
<li><p><strong>status：NOERROR</strong></p>
</li>
<li><p><strong>ANSWER SECTION</strong> 查询结果  可看到具体记录</p>
</li>
<li><strong>SERVER</strong> 权威服务器</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dig </span><span class="keyword">baidu.com </span>+(no) <span class="keyword">short </span>  只输出查询结果</span><br><span class="line"><span class="keyword">dig </span>@<span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span> *      指定服务器查询dns</span><br><span class="line"><span class="keyword">dig </span><span class="keyword">baidu.com </span>+trace    可查看具体dns查询过程</span><br><span class="line"><span class="keyword">dig </span><span class="keyword">baidu.com </span>MX    查询具体记录</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">dig -x <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>      反向查询dns主机名</span><br></pre></td></tr></table></figure>
<p>若此时一切正常，则说明cdn正常或dns正常</p>
<hr>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">telnet baidu<span class="selector-class">.com</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>
<p>可用来简单判断传输层是否正常，常用来判断主机端口是否打开</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>到了这基本上就是应用层了，打开浏览器能否上网，最多再检查代理服务器是否正确配置</p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（02-03）</title>
    <url>/2020/05/10/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8802-03%EF%BC%89/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="step-02-talking-to-nodes"><a href="#step-02-talking-to-nodes" class="headerlink" title="step-02 talking to nodes"></a>step-02 talking to nodes</h1><p>现在我们可以开始了。 让我们用上一章中看到的命令: <code>anable</code> 这个命令是ansible提供的与节点交互的三个命令中的一个</p>
<h3 id="做些有用的事情"><a href="#做些有用的事情" class="headerlink" title="做些有用的事情"></a>做些有用的事情</h3><p>在前面的命令中,<code>-m ping</code> 的意思是“使用 ping模块”，这个模块是可用的许多模块之一。 <code>Ping</code> 模块非常简单，不需要任何参数。 接受参数的模块通过 <code>-a</code> 来传递参数，让我们看看其他一些模块</p>
<h3 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h3><p>这个模块允许你在远程主机上执行一个 shell 命令:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ansible -<span class="selector-tag">i</span> step-<span class="number">02</span>/hosts -m shell -<span class="selector-tag">a</span> <span class="string">'uname -a'</span> host0</span><br></pre></td></tr></table></figure></p>
<p>输出应该是这样的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>cool!</p>
<h3 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h3><p>毫无疑问，使用这个模块，您可以将文件从控制机复制到节点，假设我们要将 <code>/etc/hosts</code> 复制到目标节点的 <code>/tmp</code>:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ansible -<span class="selector-tag">i</span> step-<span class="number">02</span>/hosts -m copy -<span class="selector-tag">a</span> <span class="string">'src=/etc/hosts dest=/tmp/'</span> host0</span><br></pre></td></tr></table></figure></p>
<p>输出应该类似于:<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">host0 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"changed"</span>: true,</span><br><span class="line">    <span class="string">"dest"</span>: <span class="string">"/tmp/hosts"</span>,</span><br><span class="line">    <span class="string">"group"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="string">"md5sum"</span>: <span class="string">"d41d8cd98f00b204e9800998ecf8427e"</span>,</span><br><span class="line">    <span class="string">"mode"</span>: <span class="string">"0644"</span>,</span><br><span class="line">    <span class="string">"owner"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"/root/.ansible/tmp/ansible-1362910475.9-246937081757218/source"</span>,</span><br><span class="line">    <span class="string">"state"</span>: <span class="string">"file"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Ansible (更准确地说是在节点上执行的复制模块)以 JSON 格式回复了大量有用的信息,我们稍后将看到如何使用它。</p>
<p>我们将在下面看到其他有用的模块,有一个巨大的<a href="https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html），几乎涵盖了你可以在系统上做的任何事情。 如果您找不到合适的模块，那么编写一个模块非常简单(甚至不必是 Python，只需要使用 JSON" target="_blank" rel="noopener">模块仓库</a></p>
<h3 id="对不同的主机使用相同的命令"><a href="#对不同的主机使用相同的命令" class="headerlink" title="对不同的主机使用相同的命令"></a>对不同的主机使用相同的命令</h3><p>好的，上面的内容很有趣，但是我们有很多节点需要管理。让我们在其他主机上也尝试一下</p>
<p>让我们假设我们想要得到一些关于节点的信息，例如，想知道我们在节点上部署了哪个 Ubuntu 版本，这很简单:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ansible -<span class="selector-tag">i</span> step-<span class="number">02</span>/hosts -m shell -<span class="selector-tag">a</span> <span class="string">'grep DISTRIB_RELEASE /etc/lsb-release'</span> all</span><br></pre></td></tr></table></figure></p>
<p>All 是一个快捷方式，意思是“在目录文件中找到的所有主机”。它会返回:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">host1 | success | <span class="attribute">rc</span>=0 &gt;&gt;</span><br><span class="line"><span class="attribute">DISTRIB_RELEASE</span>=14.04</span><br><span class="line"></span><br><span class="line">host2 | success | <span class="attribute">rc</span>=0 &gt;&gt;</span><br><span class="line"><span class="attribute">DISTRIB_RELEASE</span>=14.04</span><br><span class="line"></span><br><span class="line">host0 | success | <span class="attribute">rc</span>=0 &gt;&gt;</span><br><span class="line"><span class="attribute">DISTRIB_RELEASE</span>=14.04</span><br></pre></td></tr></table></figure>
<h3 id="更多的facts（信息）"><a href="#更多的facts（信息）" class="headerlink" title="更多的facts（信息）"></a>更多的facts（信息）</h3><p>这很简单，然而，如果我们想要更多的信息(ip 地址，RAM 大小等等)，它会很快变得很麻烦. 这个解决方案来自另一个非常方便的模块，叫做<code>setup</code>: 它专门收集节点的facts（信息）</p>
<p>尝试一下:<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">ansible -i <span class="built_in">step</span><span class="number">-02</span>/hosts -m <span class="built_in">setup</span> host0</span><br></pre></td></tr></table></figure></p>
<p>提供大量信息:<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="string">"ansible_facts"</span>: &#123;</span><br><span class="line">    <span class="string">"ansible_all_ipv4_addresses"</span>: [</span><br><span class="line">        <span class="string">"192.168.0.60"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"ansible_all_ipv6_addresses"</span>: [],</span><br><span class="line">    <span class="string">"ansible_architecture"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">    <span class="string">"ansible_bios_date"</span>: <span class="string">"01/01/2007"</span>,</span><br><span class="line">    <span class="string">"ansible_bios_version"</span>: <span class="string">"Bochs"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">---snip---</span></span><br><span class="line">    <span class="string">"ansible_virtualization_role"</span>: <span class="string">"guest"</span>,</span><br><span class="line">    <span class="string">"ansible_virtualization_type"</span>: <span class="string">"kvm"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"changed"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">"verbose_override"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>为了简短起见，对它进行了截断，但是您可以在返回的数据中找到许多有趣的,您还可以过滤返回的键，以防您正在寻找某些特定的东西。</p>
<p>例如，让我们假设你想知道你在所有主机上有多少内存，简单地使用 <code>ansible -i step-02/hosts -m setup -a &quot;filter= ansible_memtotal_mb&quot; all:</code></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">host2 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"ansible_facts"</span>: &#123;</span><br><span class="line">        <span class="string">"ansible_memtotal_mb"</span>: <span class="number">187</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"changed"</span>: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host1 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"ansible_facts"</span>: &#123;</span><br><span class="line">        <span class="string">"ansible_memtotal_mb"</span>: <span class="number">187</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"changed"</span>: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host0 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"ansible_facts"</span>: &#123;</span><br><span class="line">        <span class="string">"ansible_memtotal_mb"</span>: <span class="number">187</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"changed"</span>: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，与前面的输出相比，主机的回复顺序不同，这是因为 ansible 与主机的通信是并行化的！</p>
<p>顺便说一句，在使用 <code>setup</code> 模块时，可以在 <code>filter=</code> 表达式中使用 <code>*</code>，它与<code>shell</code>相似</p>
<h3 id="选择主机"><a href="#选择主机" class="headerlink" title="选择主机"></a>选择主机</h3><p>我们看到 <code>all</code> 意味着所有的主机，但 ansible 提供了许多其他的方法来<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html" target="_blank" rel="noopener">选择主机</a>:</p>
<ul>
<li><code>host0:host1</code>  将在 host0和 host1上运行</li>
<li><code>host*</code> host开头的主机都会运行 (就像 shell语法一样)</li>
</ul>
<p>还有其他涉及主机组的方式，我们将在step-03中看到。</p>
<h1 id="step-03-主机组"><a href="#step-03-主机组" class="headerlink" title="step-03 主机组"></a>step-03 主机组</h1><p>库存中的主机可以任意分组，例如，您可以有一个 <code>debian</code> 组、一个 <code>web-server</code> 组、一个 <code>production</code> 组等等</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[debian]</span></span><br><span class="line">host0</span><br><span class="line">host1</span><br><span class="line">host2</span><br></pre></td></tr></table></figure>
<p>这甚至可以用更简短的方式来表达:<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[debian]</span></span><br><span class="line">host<span class="string">[0:2]</span></span><br></pre></td></tr></table></figure></p>
<p>如果您希望使用子组，只需定义一个 <code>[ groupname: children ]</code> 并在其中添加子组，例如，假设我们有不同发行版的 linux 运行，我们可以这样组织我们的库存:<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[ubuntu]</span></span><br><span class="line">host0</span><br><span class="line"></span><br><span class="line"><span class="string">[debian]</span></span><br><span class="line">host<span class="string">[1:2]</span></span><br><span class="line"></span><br><span class="line"><span class="string">[linux:children]</span></span><br><span class="line">ubuntu</span><br><span class="line">debian</span><br></pre></td></tr></table></figure></p>
<h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><p>您可以在几个地方为主机分配变量: 库存文件、主机变量文件、组 v变量文件等等</p>
<p>我通常将大部分变量设置在组变量或主机变量文件中(稍后将详细介绍)。但是，我经常直接在目录文件中使用一些变量，比如<code>ansible_host</code> 可以为主机设置 IP 地址。 默认情况下，Ansible 会在通过 SSH 连接时尝试解析主机的名称。 当在你启动一个主机时，它可能还没有一个确定的 IP 地址，<code>ansible_host</code> 用在这里很方便</p>
<p>当使用 <code>ansible</code> 或 <code>ansible-playbook</code> 命令时，也可以使用参数 <code>--extra-vars</code> (或<code>-e</code>)来设置变量，作为空格分隔的<code>key=val</code> 列表(对于每个变量的初始化，可以多次使用该方法)。 我们将在下一步讨论<code>ansible-playbook</code></p>
<p>您可以猜到，<code>ansible_port</code>指定一个 SSH 端口尝试连接<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[ubuntu]</span><br><span class="line">host0 ansible_host=<span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span> ansible_port=<span class="number">2222</span></span><br></pre></td></tr></table></figure></p>
<p>Ansible 将在组和主机变量文件中查找其他变量定义,这些文件在主目录文件所在的目录下的 <code>group_vars</code> 和 <code>host_vars</code> 的目录中搜索</p>
<p>文件将按名称搜索，例如，使用前面提到的库存文件，<code>host0</code>变量将在这些文件中搜索</p>
<ul>
<li><code>group_vars/linux</code></li>
<li><code>group_vars/ubuntu</code></li>
<li><code>host_vars/host0</code><br>~~~<br>这些文件是否存在并不重要，但是如果它们存在，ansible 将使用它们</li>
</ul>
<p>现在我们已经了解了模块、库存和变量的基本知识，让我们通过剧本来探索 Ansible 的真正力量</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假夏令营个人总结</title>
    <url>/2019/07/26/%E6%9A%91%E5%81%87%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>转眼间暑假培训就这么结束了，趁着思绪未乱，赶紧写下这篇总结<br><a id="more"></a></p>
<hr>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>本次用到的是二层交换机hp2626及三层交换机hp5308xl</p>
<h4 id="acl配置"><a href="#acl配置" class="headerlink" title="acl配置"></a>acl配置</h4><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(config)<span class="meta"># ip access-list standard &lt;1-99&gt;	/*创建一个标准访问列表</span></span><br><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(config-<span class="keyword">std</span>-nacl)<span class="meta"># permit &lt;any|host|ip address&gt;	/*定义规则</span></span><br><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(config-<span class="keyword">std</span>-nacl)<span class="meta"># deny &lt;any|host|ip address&gt;	/*定义规则</span></span><br><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(config)<span class="meta"># vlan 100	/*进入接口</span></span><br><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(vlan<span class="number">-100</span>)<span class="meta"># ip access-group 1 &lt;in|out|connection-rate-filter&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(config)<span class="meta"># ip access-list extended &lt;100-199&gt;	/*创建一个扩展访问列表</span></span><br><span class="line"><span class="number">5308</span><span class="built_in">xl</span>(config-ext-nacl)<span class="meta">#permit &lt;ip|tcp|udp&gt; &lt;any|host|ip address&gt; &lt;any|host|ip   address&gt;</span></span><br><span class="line">&#123;eq|gt|lt|<span class="keyword">neg</span>|range&#125;&#123;端口号或者应用&#125;	<span class="comment">/*定义规则</span></span><br><span class="line"><span class="comment">5308xl(config)# vlan 100</span></span><br></pre></td></tr></table></figure>
<h4 id="路由重发布"><a href="#路由重发布" class="headerlink" title="路由重发布"></a>路由重发布</h4><p>多用于网络边缘设备<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">5308xl(config)# router rip</span><br><span class="line">5308xl(rip)# redistribute ospf</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>用的是hp7102、7203，个人感觉命令风格更偏向思科，与交换机命令略不同</p>
<h3 id="dhcp服务搭建"><a href="#dhcp服务搭建" class="headerlink" title="dhcp服务搭建"></a>dhcp服务搭建</h3><h5 id="路由器上直接实现"><a href="#路由器上直接实现" class="headerlink" title="路由器上直接实现"></a>路由器上直接实现</h5><p><img src="/images/20190728=0.png" alt="配置图"></p>
<ul>
<li>首先建立dhcp地址池</li>
<li>设置其作用网段，dns服务器，网关</li>
<li>最后排除预设地址(及不希望被分配的地址)</li>
<li>再在相应vlan下设置ip-helper地址(及DHCP服务器地址)</li>
</ul>
<h5 id="linux下dhcp服务搭建"><a href="#linux下dhcp服务搭建" class="headerlink" title="linux下dhcp服务搭建"></a>linux下dhcp服务搭建</h5><blockquote>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install isc-dhcp-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p> 然后编辑配置文件，选择需要开启dhcp服务器的网卡<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">vi /etc/<span class="keyword">default</span>/isc-dhcp-<span class="keyword">server</span></span><br><span class="line">INTERFACES=<span class="string">"eth0"</span></span><br></pre></td></tr></table></figure></p>
<p>配置DHCP<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">vi /etc/dhcp/dhcpd.conf</span><br><span class="line">subnet <span class="number">10.6</span><span class="number">.10</span><span class="number">.0</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> &#123;</span><br><span class="line">option routers <span class="number">10.6</span><span class="number">.10</span><span class="number">.1</span>;</span><br><span class="line">option subnet-mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>;</span><br><span class="line">range dynamic-bootp <span class="number">10.6</span><span class="number">.10</span><span class="number">.3</span> <span class="number">10.6</span><span class="number">.10</span><span class="number">.254</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置该网卡为静态ip<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">vi /etc/dhcpcd.conf</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 10.6.10.2</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.6.10.1</span><br></pre></td></tr></table></figure></p>
<p>但用着发现有两个问题</p>
<ol>
<li>只能是方便的配置一个网段的地址分配，其文档讲的多网段分配实在难懂，最后是绑定了mac地址给另一个网段设备才实现能用</li>
<li>用着实在不稳定，经常是用着用着服务就挂了，只能靠重启解决<br><img src="/images/20190728=1.png" alt></li>
</ol>
<p>可能还需进一步学习才能找到问题所在，最后还是用了上一种方案</p>
<h3 id="pat对外上网实现"><a href="#pat对外上网实现" class="headerlink" title="pat对外上网实现"></a>pat对外上网实现</h3><p>按照步骤先创建一个访问控制列表表明允许被做PAT的内网地址范围，再将该ACL与外网地址做过载，合并为一个policy-class（这里我选择的是单一外网地址10.0.99.66，也可以设定为地址池），最后将该access-policy应用到内网接口即可。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ip access-list standard outbounds </span><br><span class="line">permit any any </span><br><span class="line"></span><br><span class="line">ip policy-class<span class="built_in"> nat </span></span><br><span class="line">nat source list outbounds<span class="built_in"> address </span>10.0.99.66 overload</span><br><span class="line"></span><br><span class="line">int eth 0/1</span><br><span class="line">ip access-policy nat</span><br></pre></td></tr></table></figure></p>
<p>查看pat转换情况<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">show<span class="built_in"> ip </span>policy-sessions</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="linux命令补充"><a href="#linux命令补充" class="headerlink" title="linux命令补充"></a>linux命令补充</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">ifconfig 修改参数只是暂时保存，重启失效</span><br><span class="line">iwconfig 类似ifconfig，偏向无线管理</span><br><span class="line">iwconfig wlan0 mode<span class="built_in"> monitor </span>切换为监听模式</span><br><span class="line">iwlist wifi-name scanning 查看wifi</span><br><span class="line">iw dev wlan0 info 查看wlan0信息</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（06-07）</title>
    <url>/2020/05/15/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8806-07%EF%BC%89/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="step-06-当配置正确时重新启动"><a href="#step-06-当配置正确时重新启动" class="headerlink" title="step-06 当配置正确时重新启动"></a>step-06 当配置正确时重新启动</h1><p>我们已经安装了 apache，配置了虚拟主机，并重新启动了服务器。 但是，如果我们只是希望在配置正确的情况下重新启动服务器，那又会怎样呢？ 让我们开始吧</p>
<h3 id="当出现问题的时候停止工作"><a href="#当出现问题的时候停止工作" class="headerlink" title="当出现问题的时候停止工作"></a>当出现问题的时候停止工作</h3><p>ansible 有一个俏皮的特性: 如果出现问题，它将停止所有的工作。 如果配置文件无效的话，我们将利用这个特性来停止我们的 playbook。</p>
<p>让我们修改一下我们的 <code>awesome-app</code> 虚拟主机配置文件:<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">  RocumentDoot /<span class="keyword">var</span>/www/awesome-<span class="keyword">app</span></span><br><span class="line"></span><br><span class="line">  Options -Indexes</span><br><span class="line"></span><br><span class="line">  ErrorLog /<span class="keyword">var</span>/<span class="keyword">log</span>/apache2/<span class="keyword">error</span>.<span class="built_in">log</span></span><br><span class="line">  TransferLog /<span class="keyword">var</span>/<span class="keyword">log</span>/apache2/access.<span class="built_in">log</span></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p>
<p>如前所述，当任务失败时，处理过程停止。 因此，在重新启动服务器之前，我们将确保配置有效。 我们还可以在删除缺省的虚拟主机之前添加虚拟主机，这样随后的重新启动(可能直接在服务器上完成)就不会破坏 apache。</p>
<p>请注意，我们一开始就应该这样做。 因为我们已经运行了我们的剧本，默认的虚拟主机已经被停用了。 当然，其他无关的主机也可以使用这个剧本，让我们保护他们。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Installs apache web server</span><br><span class="line">      apt:</span><br><span class="line">        pkg: apache2</span><br><span class="line">        state: present</span><br><span class="line">        update_cache: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    - name: Push future<span class="built_in"> default </span>virtual host configuration</span><br><span class="line">      copy:</span><br><span class="line">        src: files/awesome-app</span><br><span class="line">        dest: /etc/apache2/sites-available/</span><br><span class="line">        mode: 0640</span><br><span class="line"></span><br><span class="line">    - name: Activates our virtualhost</span><br><span class="line">      command: a2ensite awesome-app</span><br><span class="line"></span><br><span class="line">    - name: Check that our<span class="built_in"> config </span>is valid</span><br><span class="line">      command: apache2ctl configtest</span><br><span class="line"></span><br><span class="line">    - name: Deactivates the<span class="built_in"> default </span>virtualhost</span><br><span class="line">      command: a2dissite default</span><br><span class="line"></span><br><span class="line">    - name: Deactivates the<span class="built_in"> default </span>ssl virtualhost</span><br><span class="line">      command: a2dissite default-ssl</span><br><span class="line">      notify:</span><br><span class="line">        - restart apache</span><br><span class="line"></span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service:</span><br><span class="line">        name: apache2</span><br><span class="line">        state: restarted</span><br></pre></td></tr></table></figure>
<p>接下来开始吧：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"></span><br><span class="line">GATHERING FACTS <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Installs apache web server] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Push future default virtual host configuration] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Activates our virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Check that our config is valid] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">failed: [host1] =&gt; &#123;"changed": true, "cmd": ["apache2ctl", "configtest"], "delta": "0:00:00.045046", "end": "2013-03-08 16:09:32.002063", "rc": 1, "start": "2013-03-08 16:09:31.957017"&#125;</span><br><span class="line">stderr: Syntax error on line 2 of /etc/apache2/sites-enabled/awesome-app:</span><br><span class="line">Invalid command 'RocumentDoot', perhaps misspelled or defined by a module not included in the server configuration</span><br><span class="line">stdout: Action 'configtest' failed.</span><br><span class="line">The Apache error log may have more information.</span><br><span class="line"></span><br><span class="line">FATAL: all hosts have already failed -- aborting</span><br><span class="line"></span><br><span class="line">PLAY RECAP <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">host1              : ok=4    changed=2    unreachable=0    failed=1</span><br></pre></td></tr></table></figure></p>
<p>正如您可以看到的，因为 apache2ctl 在失败时返回退出代码为1，ansible 发现了这一点并停止了处理。 太好了！</p>
<p>嗯，实际上不是很好… 我们的虚拟主机已经添加了。 任何后续的 apache 重新启动都会抱怨我们的配置，然后退出。 因此，我们需要一种方法来发现故障并返回。</p>
<h1 id="step-07-使用条件语句"><a href="#step-07-使用条件语句" class="headerlink" title="step-07 使用条件语句"></a>step-07 使用条件语句</h1><p>我们已经安装了 apache，设置了虚拟主机，并重新启动了服务器。 但是，我们希望在出现问题时，能够将其恢复到稳定状态。</p>
<h3 id="当出错时回滚"><a href="#当出错时回滚" class="headerlink" title="当出错时回滚"></a>当出错时回滚</h3><p>提醒一句: 这里没有魔法。 之前配置错误不是 <code>ansible</code> 的错误。 它不是一个备份系统，它不能回滚所有的东西。 你的工作就是确保你的剧本是配置正确的。 ansible 不知道如何恢复一个<code>2ensite awesome-app</code>。</p>
<p>但是，如果我们关注配置错误时于怎么回滚，那么就可以利用它进行回滚</p>
<p>如前所述，当任务失败时，处理就会停止… 除非我们接受失败(我们应该接受)。 这就是我们要做的: 如果出现故障，继续处理，但是只恢复我们已经完成的操作。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Installs apache web server</span><br><span class="line">      apt:</span><br><span class="line">        pkg: apache2</span><br><span class="line">        state: present</span><br><span class="line">        update_cache: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    - name: Push future<span class="built_in"> default </span>virtual host configuration</span><br><span class="line">      copy:</span><br><span class="line">        src: files/awesome-app</span><br><span class="line">        dest: /etc/apache2/sites-available/</span><br><span class="line">        mode: 0640</span><br><span class="line"></span><br><span class="line">    - name: Activates our virtualhost</span><br><span class="line">      command: a2ensite awesome-app</span><br><span class="line"></span><br><span class="line">    - name: Check that our<span class="built_in"> config </span>is valid</span><br><span class="line">      command: apache2ctl configtest</span><br><span class="line">      register: result</span><br><span class="line">      ignore_errors: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    - name: Rolling back - Restoring old<span class="built_in"> default </span>virtualhost</span><br><span class="line">      command: a2ensite default</span><br><span class="line">      when: result is failed</span><br><span class="line"></span><br><span class="line">    - name: Rolling back - Removing our virtualhost</span><br><span class="line">      command: a2dissite awesome-app</span><br><span class="line">      when: result is failed</span><br><span class="line"></span><br><span class="line">    - name: Rolling back - Ending playbook</span><br><span class="line">      fail:</span><br><span class="line">        msg: <span class="string">"Configuration file is not valid. Please check that before re-running the playbook."</span></span><br><span class="line">      when: result is failed</span><br><span class="line"></span><br><span class="line">    - name: Deactivates the<span class="built_in"> default </span>virtualhost</span><br><span class="line">      command: a2dissite default</span><br><span class="line"></span><br><span class="line">    - name: Deactivates the<span class="built_in"> default </span>ssl virtualhost</span><br><span class="line">      command: a2dissite default-ssl</span><br><span class="line">      notify:</span><br><span class="line">        - restart apache</span><br><span class="line"></span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service:</span><br><span class="line">        name: apache2</span><br><span class="line">        state: restarted</span><br></pre></td></tr></table></figure></p>
<p><code>register</code> 关键字记录 <code>apache2ctl configtest</code> 命令(exit status、 stdout、 stderr、 …)的输出，以及 <code>when: result is failed</code> 检查注册变量(<code>result</code>)是否失败。</p>
<p>接下来开始吧：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-07/hosts -l host1 step-07/apache.yml</span><br><span class="line"></span><br><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"></span><br><span class="line">GATHERING FACTS <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Installs apache web server] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Push future default virtual host configuration] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Activates our virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Check that our config is valid] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">failed: [host1] =&gt; &#123;"changed": true, "cmd": ["apache2ctl", "configtest"], "delta": "0:00:00.051874", "end": "2013-03-10 10:50:17.714105", "rc": 1, "start": "2013-03-10 10:50:17.662231"&#125;</span><br><span class="line">stderr: Syntax error on line 2 of /etc/apache2/sites-enabled/awesome-app:</span><br><span class="line">Invalid command 'RocumentDoot', perhaps misspelled or defined by a module not included in the server configuration</span><br><span class="line">stdout: Action 'configtest' failed.</span><br><span class="line">The Apache error log may have more information.</span><br><span class="line">...ignoring</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Restoring old default virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Removing our virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Ending playbook] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">failed: [host1] =&gt; &#123;"failed": true&#125;</span><br><span class="line">msg: Configuration file is not valid. Please check that before re-running the playbook.</span><br><span class="line"></span><br><span class="line">FATAL: all hosts have already failed -- aborting</span><br><span class="line"></span><br><span class="line">PLAY RECAP <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">host1              : ok=7    changed=4    unreachable=0    failed=1</span><br></pre></td></tr></table></figure></p>
<p>看起来正常工作。让我们尝试重新启动 apache，看看它是否真的工作:</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">$ ansible -i step-<span class="number">07</span>/hosts -m service -a 'name=apache2 <span class="keyword">state</span>=restarted' host1</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span>=restarted' host1</span><br><span class="line">host1 | success &gt;&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: true,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"apache2"</span>,</span><br><span class="line">    <span class="string">"state"</span>: <span class="string">"started"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在我们的 apache 安全了，不会出现配置错误。</p>
<p>虽然这看起来需要做很多工作，但其实不然。 请记住，您几乎可以在任何地方使用变量，因此很容易将其作为 apache 的通用模板，并在任何地方使用它来部署虚拟主机。 创建一次剧本，就可在任何地方使用。 我们将在步骤9中完成这项工作，但是现在，让我们在步骤08中使用 git 部署我们的 web 站点。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（00-01）</title>
    <url>/2020/05/08/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8800-01%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>官方文档虽好，样样俱全，可就是太碎太细，难以拼接消化，那么就先从跟着一份好的教程先慢慢学起吧</p>
<p>源地址（包含所有所需文件）–&gt;<a href="https://github.com/leucos/ansible-tuto" target="_blank" rel="noopener">ansible-tuto</a></p>
<h1 id="step-00-安装"><a href="#step-00-安装" class="headerlink" title="step-00 安装"></a>step-00 安装</h1><p>Vagrant的出现让VirtualBox部署虚拟机变得非常简单容易，为了让本教程更加<code>self-contained</code>，已经提供了所需的Vagrantfile</p>
<h3 id="安装vagrant"><a href="#安装vagrant" class="headerlink" title="安装vagrant"></a>安装vagrant</h3><p>为了运行Vagrant，需要满足以下条件：</p>
<ul>
<li>安装VirtualBox</li>
<li>安装Ruby</li>
<li>安装Vagrant（1.1版本以上）<br>以上就是安装Vagrant所需的</li>
</ul>
<p>现在就可以根据以下命令去启动你的虚拟机了。请注意，你不需要手动下载任何<code>box</code>，本教程已经提供了一个所需的Vagrantfile，如果还需要其他的，那么还会提供另外一个的<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant up</span></span><br></pre></td></tr></table></figure></p>
<p>然后可以放松下去喝杯咖啡(注意，如果您使用 vagrant-hostmaster，您需要输入密码，因为sudo 提权需要密码)</p>
<p>如果有什么地方出了问题，请参考 <a href="https://www.vagrantup.com/intro/getting-started/index.html" target="_blank" rel="noopener">Getting Started Guide</a></p>
<h3 id="关于NetworkManager的警示"><a href="#关于NetworkManager的警示" class="headerlink" title="关于NetworkManager的警示"></a>关于NetworkManager的警示</h3><p>在某些系统上，<code>NetworkManager</code> 将接管 <code>vboxnet</code> 接口，并把一切都搞砸。 如果是这种情况，应该防止 <code>NetworkManager</code> 尝试自动配置<code>vboxnet</code>接口。 只需编辑 <code>/etc/networkmanager/networkmanager.conf</code> (或者你系统中的 NetworkManager 配置文件)并添加一节[keyfile] :<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">unmanaged-devices=<span class="string">mac:</span>MAC_OF_VBOXNET0_IF;<span class="string">mac:</span>MAC_OF_VBOXNET1_IF;...</span><br></pre></td></tr></table></figure></p>
<p>然后销毁 Vagrant 计算机，重新启动 NetworkManager，然后再试一次。</p>
<h3 id="为虚拟机添加SSH密钥"><a href="#为虚拟机添加SSH密钥" class="headerlink" title="为虚拟机添加SSH密钥"></a>为虚拟机添加SSH密钥</h3><p>按照该教程，您需要将您的密钥放在虚拟机中<code>root</code>用户文件夹中<code>authorized_keys</code>中，虽然这是不是绝对必要的(ansible可以使用 sudo，密码身份验证等) 但这样事情就简单多了</p>
<p>ansible非常擅长这个，然而，我现在不会解释发生了什么，相信我<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i <span class="built_in">step</span><span class="number">-00</span>/hosts <span class="built_in">step</span><span class="number">-00</span>/<span class="built_in">setup</span>.yml</span><br></pre></td></tr></table></figure></p>
<p>如果出现“超时连接”错误，请检查机器的防火墙设置。</p>
<p>如果出现以下错误:<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">fatal: [<span class="number">192.168</span><span class="number">.33</span><span class="number">.10</span>]: UNREACHABLE! =&gt; &#123;<span class="string">"changed"</span>: <span class="keyword">false</span>, </span><br><span class="line"><span class="string">"msg"</span>: <span class="string">"host key mismatch for 192.168.33.10"</span>, <span class="string">"unreachable"</span>: <span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么你可能已经在你的 <code>~/.ssh/known_hosts</code> 中有了那些 IP 的SSH主机密钥, 您可以使用<code>ssh-keygen-r ip</code>删除它们</p>
<p>然后，只要在提示访问 ssh 主机密钥(如果请求)时输入 <code>yes</code> 即可。</p>
<p><strong>注意</strong>: 我们假设您正在本地机器上使用 Ansible v2.5 + 版本。 如果没有，您应该在使用该存储库之前将其升级到 v2.5 + (或在 virtualenv 下运行)。</p>
<h1 id="step-01-Inventory"><a href="#step-01-Inventory" class="headerlink" title="step-01 Inventory"></a>step-01 Inventory</h1><p>在继续之前，您需要一个库存（invertory)文件，该文件文件的默认位置是 <code>/etc /anable/hosts</code>  然而，你可以通过配置 anable 去将其存储在其他地方，或使用环境变量（ANSIBLE_INVENTORY）指明库存路径，或者使用 <code>ansible</code> 命令中的  <code>-i</code>标志指明库存路径。</p>
<p>我们在目录中为您创建了一个库存文件，如下所示:<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">host0 <span class="attribute">ansible_host</span>=192.168.33.10 <span class="attribute">ansible_user</span>=root</span><br><span class="line">host1 <span class="attribute">ansible_host</span>=192.168.33.11 <span class="attribute">ansible_user</span>=root</span><br><span class="line">host2 <span class="attribute">ansible_host</span>=192.168.33.12 <span class="attribute">ansible_user</span>=root</span><br></pre></td></tr></table></figure></p>
<p><code>ansible_host</code> 是一个特殊的变量，它代表着主机连接时使用的 IP 地址。 如果您使用 <code>vagrant-hostmaster gem</code> ，那么在这里就没有必要了。 此外，如果您已经使用不同的ip地址设置了自己的虚拟机，则必须更改 ip</p>
<p><code>Ansible_user</code> 是另一个特殊的变量，它告诉 ansible 在使用 ssh 时以这个用户的身份连接。 默认情况下，ansible 将使用您当前的用户名，或者使用 <code>~/.ansible.cfg</code> 中提供的另一个默认用户名</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>ansible 安装好了，让我们检查一下是否一切正常<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ansible -m<span class="built_in"> ping </span>all -i step-01/hosts</span><br></pre></td></tr></table></figure></p>
<p>Ansible 在这里尝试做的只是在每个主机上执行 <code>ping</code> 模块(稍后在模块中进一步介绍)</p>
<p>输出应该是这样的:<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">host0 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"changed"</span>: false,</span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host1 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"changed"</span>: false,</span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host2 <span class="string">| success &gt;&gt; &#123;</span></span><br><span class="line">    <span class="string">"changed"</span>: false,</span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>以下为安装ssh密钥所用到的 <code>playbook</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">become:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">become_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">remote_user:</span> <span class="string">vagrant</span></span><br><span class="line"><span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="comment"># This should work too / #2372</span></span><br><span class="line"><span class="comment"># - name: Pushes user key to root's on vagrant boxes</span></span><br><span class="line"><span class="comment">#   action: authorized_key key=$FILE($item) user=root</span></span><br><span class="line"><span class="comment">#   first_available_file:</span></span><br><span class="line"><span class="comment">#     - ~/.ssh/id_dsa.pub</span></span><br><span class="line"><span class="comment">#     - ~/.ssh/id_rsa.pub</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Wait</span> <span class="string">for</span> <span class="string">ssh</span> <span class="string">to</span> <span class="string">be</span> <span class="string">up</span></span><br><span class="line"><span class="attr">become:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">wait_for:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">22</span></span><br><span class="line"><span class="attr">delay:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">connect_timeout:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="number">360</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">"<span class="template-variable">&#123;&#123; ansible_host &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">delegate_to:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Installs</span> <span class="string">python</span></span><br><span class="line"><span class="attr">raw:</span> <span class="string">apt-get</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="bullet">-y</span> <span class="string">python</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Creates</span> <span class="string">destination</span> <span class="string">directory</span></span><br><span class="line"><span class="comment"># Workaround for #2372</span></span><br><span class="line"><span class="attr">file:</span></span><br><span class="line"><span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line"><span class="attr">mode:</span> <span class="number">0700</span></span><br><span class="line"><span class="attr">dest:</span> <span class="string">/root/.ssh/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Pushes</span> <span class="string">user's</span> <span class="string">rsa</span> <span class="string">key</span> <span class="string">to</span> <span class="string">root's</span> <span class="string">vagrant</span> <span class="string">box</span> <span class="string">(it's</span> <span class="string">ok</span> <span class="string">if</span> <span class="string">this</span> <span class="string">TASK</span> <span class="string">fails)</span></span><br><span class="line"><span class="comment"># action: authorized_key user=root key='$FILE(~/.ssh/id_rsa.pub)'</span></span><br><span class="line"><span class="comment"># Workaround for #2372</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line"><span class="attr">src:</span> <span class="string">~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="attr">dest:</span> <span class="string">/root/.ssh/authorized_keys</span></span><br><span class="line"><span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mode:</span> <span class="number">0600</span></span><br><span class="line"><span class="attr">register:</span> <span class="string">rsa</span></span><br><span class="line"><span class="attr">ignore_errors:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Pushes</span> <span class="string">user's</span> <span class="string">dsa</span> <span class="string">key</span> <span class="string">to</span> <span class="string">root's</span> <span class="string">vagrant</span> <span class="string">box</span> <span class="string">(it's</span> <span class="string">NOT</span> <span class="string">ok</span> <span class="string">if</span> <span class="string">both</span> <span class="string">TASKs</span> <span class="string">fail)</span></span><br><span class="line"><span class="comment"># action: authorized_key user=root key='$FILE(~/.ssh/id_dsa.pub)'</span></span><br><span class="line"><span class="comment"># Workaround for #2372</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line"><span class="attr">src:</span> <span class="string">~/.ssh/id_dsa.pub</span></span><br><span class="line"><span class="attr">dest:</span> <span class="string">/root/.ssh/authorized_keys</span></span><br><span class="line"><span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mode:</span> <span class="number">0600</span></span><br><span class="line"><span class="attr">when:</span> <span class="string">rsa</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Checks</span> <span class="string">if</span> <span class="string">resolver</span> <span class="string">is</span> <span class="string">working</span> <span class="string">properly</span> <span class="string">(issues</span> <span class="string">with</span> <span class="string">some</span> <span class="string">VBox/Host</span> <span class="string">OS</span> <span class="string">combinations)</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">host</span> <span class="bullet">-t</span> <span class="string">A</span> <span class="string">ansible.cc</span></span><br><span class="line"><span class="attr">register:</span> <span class="string">ns</span></span><br><span class="line"><span class="attr">ignore_errors:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Pushes</span> <span class="string">new</span> <span class="string">resolver</span> <span class="string">configuration</span> <span class="string">if</span> <span class="string">resolver</span> <span class="string">fails</span></span><br><span class="line"><span class="attr">lineinfile:</span></span><br><span class="line"><span class="attr">regexp:</span> <span class="string">"^nameserver "</span></span><br><span class="line"><span class="attr">line:</span> <span class="string">"nameserver 8.8.8.8"</span></span><br><span class="line"><span class="attr">dest:</span> <span class="string">/etc/resolv.conf</span></span><br><span class="line"><span class="attr">when:</span> <span class="string">ns</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Checks</span> <span class="string">if</span> <span class="string">resolver</span> <span class="string">is</span> <span class="string">working</span> <span class="string">properly</span> <span class="string">with</span> <span class="string">new</span> <span class="string">nameserver</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">host</span> <span class="bullet">-t</span> <span class="string">A</span> <span class="string">ansible.cc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Final</span> <span class="string">greeting</span></span><br><span class="line"><span class="attr">pause:</span></span><br><span class="line"><span class="attr">seconds:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">echo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prompt:</span> <span class="string">"Don't worry about all the red above; if you made it here, your Vagrant VMs are probably fine !"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先，playbook的文件格式为 <code>yaml</code></li>
</ul>
<p>为了方便将其分开来说明<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">become:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">become_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">remote_user:</span> <span class="string">vagrant</span></span><br><span class="line"><span class="attr">gather_facts:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>每一个剧本都应指明相应的host也就是inventory（库存里的主机），默认的hosts文件在 <code>/etc/ansible/hosts</code> ,当然也可以将 <code>hosts</code> 文件存放在自己指定的位置，最后在执行 <code>ansible-play</code>时加上 <code>-i</code>参数指明路径，而 <code>all</code> 就代表着所有主机 </li>
<li>这里的 <code>become</code> 代表着提权，默认方式为 <code>sudo</code>，也可以指定其他方式，如 <code>become_method: su</code></li>
<li><code>become_user</code> 就好理解了，为提权后的用户</li>
<li>要用到提权难免会输入密码，此时运行该剧本时就应加上 <code>-k</code> 或 <code>--ask-become-pass</code></li>
<li><code>remote_user</code> 为远程登录用户</li>
<li><code>gather_facts</code> 用于收集系统信息，不需要时关闭可提高运行速度</li>
</ul>
<p>接下来就是<code>tasks</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Creates</span> <span class="string">destination</span> <span class="string">directory</span></span><br><span class="line"><span class="comment"># Workaround for #2372</span></span><br><span class="line"><span class="attr">file:</span></span><br><span class="line"><span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line"><span class="attr">mode:</span> <span class="number">0700</span></span><br><span class="line"><span class="attr">dest:</span> <span class="string">/root/.ssh/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Pushes</span> <span class="string">user's</span> <span class="string">rsa</span> <span class="string">key</span> <span class="string">to</span> <span class="string">root's</span> <span class="string">vagrant</span> <span class="string">box</span> <span class="string">(it's</span> <span class="string">ok</span> <span class="string">if</span> <span class="string">this</span> <span class="string">TASK</span> <span class="string">fails)</span></span><br><span class="line"><span class="comment"># action: authorized_key user=root key='$FILE(~/.ssh/id_rsa.pub)'</span></span><br><span class="line"><span class="comment"># Workaround for #2372</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line"><span class="attr">src:</span> <span class="string">~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="attr">dest:</span> <span class="string">/root/.ssh/authorized_keys</span></span><br><span class="line"><span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mode:</span> <span class="number">0600</span></span><br><span class="line"><span class="attr">register:</span> <span class="string">rsa</span></span><br><span class="line"><span class="attr">ignore_errors:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>根据 <code>yaml</code> 语法，<code>-</code>表示的是一个数组，后面的 <code>name</code> 可有可无，为了有更好的辨明度，最好加上</li>
<li>后面最先接的是一个模块名称，再后面就是进行的操作，之后的教程会说到</li>
</ul>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之数组、链表、队列、栈</title>
    <url>/2019/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E6%A0%88/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><blockquote>
<p>在计算机科学中，<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">数据结构</a>（英语：data structure）是计算机中存储、组织数据的方式。</p>
</blockquote>
<p>数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p>
<p>大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。举例而言，可为空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。</p>
<p>数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p>
<p>不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。例如B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上。</p>
<p>…</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" target="_blank" rel="noopener">抽象数据类型</a>（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。</p>
</blockquote>
<p>例如，抽象的堆栈（stack）由3个操作定义：推入push，弹出pop（接受约束：每次弹出返回的是最新被推入且没有被弹出的数据，也就是后进先出），查看堆栈顶端数据peek。当分析使用堆栈算法的效率，所有这3个操作用时相同，无论堆栈中包含多少项数据；并且对每项数据栈使用了常量大小的存储。</p>
<p><strong>抽象数据类型（ADT）是纯粹理论实体(数学的抽象)，用于简化描述抽象算法，分类与评价数据结构，形式描述程序设计语言的类型系统。一个ADT可以用特定数据类型或数据结构实现，但不涉及如何实现</strong></p>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote>
<p>在计算机科学中，<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
</blockquote>
<p>数组的优缺点：</p>
<ul>
<li>优点：存取速度很快</li>
<li>缺点：插入删除元素很慢</li>
</ul>
<p>应用</p>
<ul>
<li>数组实现数学向量和矩阵，以及其它类型的长方表格。许多数据库是由元素为（或包含）记录的一维数组所组成。 数组也用于实现其它数据结构，例如列表、堆、散列表、双向队列、队列、 堆栈、字符串和VLists。与基于树实现的数据结构相比，基于数组实现的数据结构通常是简单和有空间效率的（隐式数据结构），空间成本开销很少；但数组需要修改时则空间的复杂性相对比较差（已排序的数组结构，与搜索树相比）。</li>
</ul>
<p><a href="https://github.com/oneto1/data-structure-go/tree/master/arr" target="_blank" rel="noopener">个人实现</a></p>
<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">链表</a>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
</blockquote>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</p>
<p>专业术语:</p>
<ul>
<li>首节点：存放第一个有效数据的节点</li>
<li>尾节点：存放最后一个有效数据的节点</li>
<li>头结点：位于首节点之前的一个节点，头结点并不存放有效的数据，加头结点的目的主要是为了方便对链表的操作</li>
<li>头指针：指向头结点的指针变量</li>
<li>尾指针：指向尾节点的指针变量</li>
</ul>
<p>分类</p>
<ul>
<li>单链表：每一个节点只有一个指针域</li>
<li>双链表：每一个节点有两个指针域</li>
<li>循环链表：能通过任何一个节点找到其他所有的节点</li>
<li>非循环链表：不能通过任何一个节点找到其他所有的节点</li>
</ul>
<p>优缺点:</p>
<ul>
<li>优点：空间没有限制，插入和删除元素很快</li>
<li>缺点：存取速度很慢</li>
</ul>
<p>常用于组织检索较少，而删除、添加、遍历较多的数据<a href="https://github.com/oneto1/data-structure-go/tree/master/list" target="_blank" rel="noopener">个人实现</a></p>
 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码摘自Linux内核2.6.21.5源码(部分)，展示了链表的另一种实现思</span></span><br><span class="line">路，未采用ANSI C标准，采用GNU C标准，遵从GPL著作权许可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *next, *prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><span class="line">#define LIST_HEAD(name) \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> name = LIST_HEAD_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline void INIT_LIST_HEAD(<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *list) &#123;</span><br><span class="line">    list-&gt;next = list;</span><br><span class="line">    list-&gt;prev = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline void __list_add(<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *new,</span><br><span class="line">                              <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *prev,</span><br><span class="line">                              <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *next) &#123;</span><br><span class="line">    next-&gt;prev = new;</span><br><span class="line">    new-&gt;next = next;</span><br><span class="line">    new-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline void list_add(<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *new, <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *head) </span><br><span class="line">&#123;</span><br><span class="line">    __list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline void __list_del(<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *prev, <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline void list_del(<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *entry) &#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;next = NULL;</span><br><span class="line">    entry-&gt;prev = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define __list_for_each(pos, head) \</span><br><span class="line">        <span class="keyword">for</span> (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br><span class="line"></span><br><span class="line">#define list_for_each_entry(pos, head, member)                          \</span><br><span class="line">        <span class="keyword">for</span> (pos = list_entry((head)-&gt;next, <span class="keyword">typeof</span>(*pos), member);      \</span><br><span class="line">             prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);        \</span><br><span class="line">             pos = list_entry(pos-&gt;member.next, <span class="keyword">typeof</span>(*pos), member))</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/wanshilun/article/details/79747710" target="_blank" rel="noopener">Linux内核中经典链表 list_head 常见使用方法解析</a><br><a href="https://medium.com/@hauyang/%E6%88%91%E6%9C%89%E6%89%80%E4%B8%8D%E7%9F%A5%E7%9A%84-static-inline-b363892b7450" target="_blank" rel="noopener">我有所不知的 static inline function</a></p>
<hr>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>
</blockquote>
<p>分类:</p>
<ul>
<li>链式队列——用链表实现</li>
<li>静态队列——用数组实现</li>
<li>静态队列通常都必须是循环队列</li>
</ul>
<p>应用:</p>
<ul>
<li>消息队列</li>
<li>管道</li>
<li>命名管道</li>
</ul>
<p><a href="https://github.com/oneto1/data-structure-go/tree/master/queue" target="_blank" rel="noopener">个人实现</a></p>
<hr>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>（英语：stack）又称为栈或堆叠，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作。</p>
</blockquote>
<p>分类:</p>
<ul>
<li>静态(数组)栈</li>
<li>动态(链表)栈</li>
</ul>
<p>应用：</p>
<ul>
<li>函数调用</li>
<li>中断</li>
<li>表达式求值</li>
<li>内存分配</li>
<li>缓冲处理</li>
</ul>
<p><a href="https://github.com/oneto1/data-structure-go/tree/master/stack" target="_blank" rel="noopener">个人实现</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（12-13）</title>
    <url>/2020/05/18/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8812-13%EF%BC%89/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="step-12-迁移到-role"><a href="#step-12-迁移到-role" class="headerlink" title="step-12 迁移到 role"></a>step-12 迁移到 role</h1><p>现在我们的剧本完成了，让我们重构一切！ 我们将用 <code>role</code> 来取代我们的戏剧。  <code>role</code>只是一种组织文件的新方式，但是带来了有趣的特性。 在这里我不会详细讨论，因为它们已经列出在 Ansible 的文档中，但我最喜欢的可能是 <code>role</code>依赖性:  <code>role</code> b 可以依赖于另一个 <code>role</code> a，因此，当应用 <code>role</code> b 时， <code>role</code> a 也会自动应用。 我们将在下一章中看到这一点，但是现在，让我们重构一下我们的剧本，使用 <code>role</code>。</p>
<h3 id="role-的结构"><a href="#role-的结构" class="headerlink" title="role 的结构"></a>role 的结构</h3><p>role 为 Ansible 添加了一点“魔力” : 它们假定一个特定的文件组织。 虽然有一个关于角色的建议布局，但是您可以按照您想要的方式来组织包含内容。 然而，role  的约定有助于构建模块化的剧本，并且内务管理将简单得多。 Rubyists 会称之为“约定优于配置”。</p>
<p>role 的文件布局如下:<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">roles</span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|_some_role</span><br><span class="line">       |</span><br><span class="line"><span class="string">       </span>|_defaults</span><br><span class="line">       |<span class="string">   </span>|</span><br><span class="line">       |<span class="string">   </span>|<span class="string">_main.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_...</span></span><br><span class="line"><span class="string">       </span>|</span><br><span class="line">       |<span class="string">_files</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|</span><br><span class="line">       |<span class="string">   </span>|_file1</span><br><span class="line">       |<span class="string">   </span>|<span class="string">_...</span></span><br><span class="line"><span class="string">       </span>|</span><br><span class="line">       |<span class="string">_handlers</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|</span><br><span class="line">       |<span class="string">   </span>|<span class="string">_main.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_some_other_file.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_ ...</span></span><br><span class="line"><span class="string">       </span>|</span><br><span class="line">       |<span class="string">_meta</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|</span><br><span class="line">       |<span class="string">   </span>|<span class="string">_main.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_some_other_file.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_ ...</span></span><br><span class="line"><span class="string">       </span>|</span><br><span class="line">       |<span class="string">_tasks</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|</span><br><span class="line">       |<span class="string">   </span>|<span class="string">_main.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_some_other_file.yml</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_ ...</span></span><br><span class="line"><span class="string">       </span>|</span><br><span class="line">       |<span class="string">_templates</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|</span><br><span class="line">       |<span class="string">   </span>|<span class="string">_template1.j2</span></span><br><span class="line"><span class="string">       </span>|<span class="string">   </span>|<span class="string">_...</span></span><br><span class="line"><span class="string">       </span>|</span><br><span class="line">       |<span class="string">_vars</span></span><br><span class="line"><span class="string">           </span>|</span><br><span class="line">           |<span class="string">_main.yml</span></span><br><span class="line"><span class="string">           </span>|<span class="string">_some_other_file.yml</span></span><br><span class="line"><span class="string">           </span>|<span class="string">_ ...</span></span><br></pre></td></tr></table></figure></p>
<p>名为 <code>main.yml</code> 的文件不是强制的。 然而，当它们存在时，role 会自动将它们添加到剧本中。 您可以使用此文件运行包含其他任务、处理程序… 。 我们一会儿就知道了。</p>
<p>注意，还有一个 <code>vars</code> 和一个 <code>meta</code> 目录。 当你想把一堆关于 role 的变量。 然而，我不喜欢直接在角色中设置 vars。 我认为变量属于配置，而剧本是结构。 换句话说，我将剧本和角色视为工厂，将数据视为工厂的输入。 所以我真的更喜欢有“数据”(例如变量)以外的角色和发挥。 通过这种方式，我可以更容易地分享我的角色，而不用担心过多地暴露我的服务器。 但这只是个人偏好。 让你按照自己想要的方式去做。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（04-05）</title>
    <url>/2020/05/13/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8804-05%EF%BC%89/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="step04-Ansible-playbooks"><a href="#step04-Ansible-playbooks" class="headerlink" title="step04 Ansible playbooks"></a>step04 Ansible playbooks</h1><p>Playbook 的概念非常简单: 它只是一系列可接受的命令(tasks) ，就像我们使用 <code>ansible</code> CLI 工具时所使用的那样。 这些任务针对一组特定的主机/组。</p>
<p>这个步骤所需的文件应该已经神奇地出现(自带有)，甚至不需要输入它们</p>
<h3 id="Apache-示例-也就是-Ansible-的“-Hello-World-”"><a href="#Apache-示例-也就是-Ansible-的“-Hello-World-”" class="headerlink" title="Apache 示例(也就是 Ansible 的“ Hello World! ”)"></a>Apache 示例(也就是 Ansible 的“ Hello World! ”)</h3><p>我们假设我们有以下库存文件(让我们把它命名为<code>hosts</code>) :<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[web]</span></span><br><span class="line">host1</span><br></pre></td></tr></table></figure></p>
<p>所有的主机都是基于 debian 的</p>
<p><strong>注意</strong>: 请记住您可以(在我们的练习中我们这样做)使用 <code>ansible_host</code> 来设置主机的真实 IP。 您还可以更改库存并使用真正的主机名。 在任何情况下，使用一个非关键的机器测试！ 在真正的主机文件中，我们还有<code>ansible_user=root</code> 来处理潜在的不同的ansible 默认配置(ansible.cfg的默认用户为root,但可能被修改过)</p>
<p>让我们构建一个将在 <code>web</code> 组中的机器上安装 apache 的剧本。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Installs apache web server</span><br><span class="line">      apt:</span><br><span class="line">        pkg: apache2</span><br><span class="line">        state: present</span><br><span class="line">        update_cache: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>我们只需要使用 <code>apt</code> 模块正确说出我们想要做什么。 这里，我们使用 <a href="https://docs.ansible.com/ansible/latest/modules/apt_module.html" target="_blank" rel="noopener">apt</a> 模块来安装 debian 软件包。 我们还要求此模块更新包缓存。</p>
<p>我们还为这个任务添加了一个名称。 虽然这是不必要的，但是在剧本运行时它提供了很多信息，所以强烈推荐使用。</p>
<p>总而言之，这是相当容易的！</p>
<p>您现在可以运行 playbook (让我们称之为 <code>apache.yml</code>) :<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i step<span class="number">-04</span>/hosts -l host1 step<span class="number">-04</span>/apache.yml</span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>step-04/hosts</code> 是库存文件,<code>-l</code> 将限制只在主机 <code>host1</code>上运行，<code>apache.yml</code> 是我们的剧本。</p>
<p>当你运行上面的命令时，你应该会看到这样的东西:<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"></span><br><span class="line">GATHERING FACTS <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Installs apache web server] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">host1              : ok=2    changed=1    unreachable=0    failed=0</span><br></pre></td></tr></table></figure></p>
<p>让我们分析一次一行的输出<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br></pre></td></tr></table></figure></p>
<p>告诉我们它正在主机<code>web</code>上运行。 <code>playbook</code>是一套与<code>hosts</code>有关的可接受的指令。 如果我们有另一个<code>- host: blah</code>: 在我们的剧本中，它也会运行(但是只会在第一个剧本结束之后，一个剧本文件可以有包含多个剧本)</p>
<p>还记得我们使用 <code>setup</code> 模块的时候吗？ 每次运行之前，ansible 都在指定的主机上运行它，以收集事实。 如果因为不需要主机提供任何信息而不需要这样做，那么您可以添加 <code>gather_facts: no</code> 语段在主机条目的下面(与 <code>tasks:</code>相同缩进长度)。</p>
<p>接下来，是真正的任务: 我们的(第一个也是唯一的)任务正在运行，因为它表示<code>changed</code>，所以我们知道它改变了 host1上的某些内容。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">PLAY RECAP *********************</span><br><span class="line">host1              : <span class="attribute">ok</span>=2    <span class="attribute">changed</span>=1    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br></pre></td></tr></table></figure>
<p>最后，ansible 输出发生了什么: 两个任务已经运行，其中一个在主机上改变了一些东西(我们的 apache 任务，setup 模块没有改变任何东西)。</p>
<p>现在让我们再运行一次，看看会发生什么:<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-04/hosts -l host1 step-04/apache.yml</span><br><span class="line"></span><br><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"></span><br><span class="line">GATHERING FACTS <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Installs apache web server] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">host1              : ok=2    changed=0    unreachable=0    failed=0</span><br></pre></td></tr></table></figure></p>
<p>现在‘ changed’是‘0’。 这是绝对正常的，也是 <code>ansible</code> 的核心特征之一: 只有在有事情可做的时候，剧本才会采取行动。这就是所谓的幂等性，也就是说你可以随心所欲地运行你的剧本，你最终总是会处于相同的状态(当然，除非你用 shell 模块做了一些疯狂的事情，但这超出了 ansible 的控制范围)</p>
<h3 id="完善剧本"><a href="#完善剧本" class="headerlink" title="完善剧本"></a>完善剧本</h3><p>当然，我们的剧本可以安装 apache 服务器，但它可以更完整一点。它可以添加一个虚拟主机，确保重新启动 apache。它甚至可以从 git 仓库部署我们的网站</p>
<h1 id="step-05-完善-apache-设置"><a href="#step-05-完善-apache-设置" class="headerlink" title="step-05 完善 apache 设置"></a>step-05 完善 apache 设置</h1><p>我们已经安装了 apache，现在让我们设置虚拟主机。</p>
<h3 id="完善剧本-1"><a href="#完善剧本-1" class="headerlink" title="完善剧本"></a>完善剧本</h3><p>我们的服务器上只需要一个虚拟主机，但我们希望用更具体的东西替换默认主机。因此，我们必须移除当前(可能是默认的)虚拟主机，发送至虚拟机，激活它并重新启动 apache。</p>
<p>让我们创建一个名为 <code>files</code> 的目录，并为 host1添加虚拟主机配置，我们称之为 <code>awesome-app</code>:<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">  DocumentRoot /<span class="keyword">var</span>/www/awesome-<span class="keyword">app</span></span><br><span class="line"></span><br><span class="line">  Options -Indexes</span><br><span class="line"></span><br><span class="line">  ErrorLog /<span class="keyword">var</span>/<span class="keyword">log</span>/apache2/<span class="keyword">error</span>.<span class="built_in">log</span></span><br><span class="line">  TransferLog /<span class="keyword">var</span>/<span class="keyword">log</span>/apache2/access.<span class="built_in">log</span></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在，快速更新一下我们的 apache 剧本，我们准备好了:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Installs apache web server</span><br><span class="line">      apt:</span><br><span class="line">        pkg: apache2</span><br><span class="line">        state: present</span><br><span class="line">        update_cache: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    - name: Push<span class="built_in"> default </span>virtual host configuration</span><br><span class="line">      copy:</span><br><span class="line">        src: files/awesome-app</span><br><span class="line">        dest: /etc/apache2/sites-available/awesome-app</span><br><span class="line">        mode: 0640</span><br><span class="line"></span><br><span class="line">    - name: <span class="builtin-name">Disable</span> the<span class="built_in"> default </span>virtualhost</span><br><span class="line">      file:</span><br><span class="line">        dest: /etc/apache2/sites-enabled/default</span><br><span class="line">        state: absent</span><br><span class="line">      notify:</span><br><span class="line">        - restart apache</span><br><span class="line"></span><br><span class="line">    - name: <span class="builtin-name">Disable</span> the<span class="built_in"> default </span>ssl virtualhost</span><br><span class="line">      file:</span><br><span class="line">        dest: /etc/apache2/sites-enabled/default-ssl</span><br><span class="line">        state: absent</span><br><span class="line">      notify:</span><br><span class="line">        - restart apache</span><br><span class="line"></span><br><span class="line">    - name: Activates our virtualhost</span><br><span class="line">      file:</span><br><span class="line">        src: /etc/apache2/sites-available/awesome-app</span><br><span class="line">        dest: /etc/apache2/sites-enabled/awesome-app</span><br><span class="line">        state: link</span><br><span class="line">      notify:</span><br><span class="line">        - restart apache</span><br><span class="line"></span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service:</span><br><span class="line">        name: apache2</span><br><span class="line">        state: restarted</span><br></pre></td></tr></table></figure>
<p>我们开始吧:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-05/hosts -l host1 step-05/apache.yml</span><br><span class="line"></span><br><span class="line">PLAY [web] *********************</span><br><span class="line"></span><br><span class="line">GATHERING FACTS *********************</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Installs apache web server] *********************</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Push<span class="built_in"> default </span>virtual host configuration] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [<span class="builtin-name">Disable</span> the<span class="built_in"> default </span>virtualhost] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [<span class="builtin-name">Disable</span> the<span class="built_in"> default </span>ssl virtualhost] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Activates our virtualhost] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">NOTIFIED: [restart apache] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP *********************</span><br><span class="line">host1              : <span class="attribute">ok</span>=7    <span class="attribute">changed</span>=5    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br></pre></td></tr></table></figure>
<p>太酷了！好吧，想想看，我们有点操之过急了。在重新启动 apache 之前，我们是否应该检查一下配置是否正常？这样，如果配置文件不正确，我们就不会中断服务。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（08-09）</title>
    <url>/2020/05/16/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8808-09%EF%BC%89/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="step08-从-git-部署我们的网站"><a href="#step08-从-git-部署我们的网站" class="headerlink" title="step08 从 git 部署我们的网站"></a>step08 从 git 部署我们的网站</h1><p>我们已经安装了 apache，设置了虚拟主机，并安全地重新启动了服务器。 现在我们将使用 git 模块来部署我们的应用程序。</p>
<h3 id="Git-模块"><a href="#Git-模块" class="headerlink" title="Git 模块"></a>Git 模块</h3><p>这是一个小放松，没有什么新的东西。<code>git</code> 模块只是另一个模块。 尽管我们只是为了好玩而尝试。当它涉及 <code>ansible-pull</code>以后，我们将更加熟悉它，</p>
<p>我们的虚拟机已经设置好了，但是我们需要一些更改来完成部署。 首先，我们正在部署一个 PHP 应用程序。 因此，我们需要安装 <code>libapache2-mod-php</code> 包。 其次，我们必须安装 git，因为 <code>git</code> 模块(用于克隆我们应用程序的 git 存储库)将使用它。</p>
<p>我们可以这样做:<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">- name: Installs apache web server</span><br><span class="line">  apt:</span><br><span class="line">    pkg: apache2</span><br><span class="line">    <span class="keyword">state</span>: present</span><br><span class="line">    update_cache: true</span><br><span class="line"></span><br><span class="line">- name: Installs php module</span><br><span class="line">  apt:</span><br><span class="line">    pkg: libapache2-mod-php</span><br><span class="line">    <span class="keyword">state</span>: present</span><br><span class="line"></span><br><span class="line">- name: Installs git</span><br><span class="line">  apt:</span><br><span class="line">    pkg: git</span><br><span class="line">    <span class="keyword">state</span>: present</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>但是 ansible 提供了一种更易读的编写方式。 Ansible 可以在一系列 <code>items</code> 上循环遍历，并在一个动作中使用每个 <code>item</code> :<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Installs</span> <span class="string">necessary</span> <span class="string">packages</span></span><br><span class="line"><span class="attr">      apt:</span></span><br><span class="line"><span class="attr">        pkg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">        update_cache:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      with_items:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">apache2</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">libapache2-mod-php</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Push</span> <span class="string">future</span> <span class="string">default</span> <span class="string">virtual</span> <span class="string">host</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">      copy:</span></span><br><span class="line"><span class="attr">        src:</span> <span class="string">files/awesome-app</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/etc/apache2/sites-available/</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0640</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Activates</span> <span class="string">our</span> <span class="string">virtualhost</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">a2ensite</span> <span class="string">awesome-app</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Check</span> <span class="string">that</span> <span class="string">our</span> <span class="string">config</span> <span class="string">is</span> <span class="string">valid</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">apache2ctl</span> <span class="string">configtest</span></span><br><span class="line"><span class="attr">      register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">      ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Rolling</span> <span class="string">back</span> <span class="bullet">-</span> <span class="string">Restoring</span> <span class="string">old</span> <span class="string">default</span> <span class="string">virtualhost</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">a2ensite</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Rolling</span> <span class="string">back</span> <span class="bullet">-</span> <span class="string">Removing</span> <span class="string">out</span> <span class="string">virtualhost</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">a2dissite</span> <span class="string">awesome-app</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Rolling</span> <span class="string">back</span> <span class="bullet">-</span> <span class="string">Ending</span> <span class="string">playbook</span></span><br><span class="line"><span class="attr">      fail:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"Configuration file is not valid. Please check that before re-running the playbook."</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deploy</span> <span class="string">our</span> <span class="string">awesome</span> <span class="string">application</span></span><br><span class="line"><span class="attr">      git:</span></span><br><span class="line"><span class="attr">        repo:</span> <span class="attr">https://github.com/leucos/ansible-tuto-demosite.git</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/var/www/awesome-app</span></span><br><span class="line"><span class="attr">      tags:</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deactivates</span> <span class="string">the</span> <span class="string">default</span> <span class="string">virtualhost</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">a2dissite</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deactivates</span> <span class="string">the</span> <span class="string">default</span> <span class="string">ssl</span> <span class="string">virtualhost</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">a2dissite</span> <span class="string">default-ssl</span></span><br><span class="line"><span class="attr">      notify:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">apache2</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure></p>
<p>接下来开始吧：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-08/hosts -l host1 step-08/apache.yml</span><br><span class="line"></span><br><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"></span><br><span class="line">GATHERING FACTS <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Updates apt cache] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Installs necessary packages] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1] =&gt; (item=apache2,libapache2-mod-php,git)</span><br><span class="line"></span><br><span class="line">TASK: [Push future default virtual host configuration] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Activates our virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Check that our config is valid] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Restoring old default virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">skipping: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Removing out virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">skipping: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Ending playbook] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">skipping: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Deploy our awesome application] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Deactivates the default virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Deactivates the default ssl virtualhost] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">NOTIFIED: [restart apache] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">host1              : ok=10   changed=8    unreachable=0    failed=0</span><br></pre></td></tr></table></figure></p>
<p>你现在可以浏览 <a href="http://192.168.33.11，它应该会显示一张图片和服务器的主机名。" target="_blank" rel="noopener">http://192.168.33.11，它应该会显示一张图片和服务器的主机名。</a></p>
<p><strong>注意</strong> <code>tags: deploy</code>  这一行允许您只执行 playbook 的一部分。 比如说你为你的网站推出了一个新版本。 您希望加快处理速度，只执行处理 <code>deploy</code> 的部分。 标签允许你这样做。 当然，<code>deploy</code> 只是一个字符串，它没有任何特定的含义，可以是任何东西。 让我们来看看如何使用它:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-08/hosts -l host1 step-08/apache.yml -t deploy</span><br><span class="line">X11 forwarding request failed on channel 0</span><br><span class="line"></span><br><span class="line">PLAY [web] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"></span><br><span class="line">GATHERING FACTS <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Deploy our awesome application] <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">host1              : ok=2    changed=1    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>
<p>让我们在 <code>step-09</code> 中部署另一个 web 服务器。</p>
<h1 id="step-09-添加另外一个-webserver"><a href="#step-09-添加另外一个-webserver" class="headerlink" title="step-09 添加另外一个 webserver"></a>step-09 添加另外一个 webserver</h1><p>我们已经有了一个 webserver，让我们添加另外一个</p>
<h3 id="更新库存文件"><a href="#更新库存文件" class="headerlink" title="更新库存文件"></a>更新库存文件</h3><p>由于我们对此抱有有很大的期望，我们将添加另一个 web 服务器和一个负载均衡器，我们将在下一步配置它。让我们完成它。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[web]</span><br><span class="line">host1 <span class="attribute">ansible_host</span>=192.168.33.11 <span class="attribute">ansible_user</span>=root</span><br><span class="line">host2 <span class="attribute">ansible_host</span>=192.168.33.12 <span class="attribute">ansible_user</span>=root</span><br><span class="line"></span><br><span class="line">[haproxy]</span><br><span class="line">host0 <span class="attribute">ansible_host</span>=192.168.33.10 <span class="attribute">ansible_user</span>=root</span><br></pre></td></tr></table></figure>
<p>请记住，<code>ansible_host</code> 在这里指定可接受的主机，因为主机的 IP 与预期的不同(或者无法解析)。 您可以将这些主机添加到您的 <code>/etc/hosts</code> 中，而不必担心，或者使用真正的主机名(这是典型情况下应该做的)。</p>
<h3 id="部署另一个-webserver"><a href="#部署另一个-webserver" class="headerlink" title="部署另一个 webserver"></a>部署另一个 webserver</h3><p>部署另一个 webserver 很简单</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-09/hosts step-09/apache.yml</span><br><span class="line"></span><br><span class="line">PLAY [web] *********************</span><br><span class="line"></span><br><span class="line">GATHERING FACTS *********************</span><br><span class="line">ok: [host2]</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Updates apt cache] *********************</span><br><span class="line">ok: [host1]</span><br><span class="line">ok: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Installs necessary packages] *********************</span><br><span class="line">ok: [host1] =&gt; (<span class="attribute">item</span>=apache2,libapache2-mod-php,git)</span><br><span class="line">changed: [host2] =&gt; (<span class="attribute">item</span>=apache2,libapache2-mod-php,git)</span><br><span class="line"></span><br><span class="line">TASK: [Push future<span class="built_in"> default </span>virtual host configuration] *********************</span><br><span class="line">ok: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Activates our virtualhost] *********************</span><br><span class="line">changed: [host2]</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Check that our<span class="built_in"> config </span>is valid] *********************</span><br><span class="line">changed: [host2]</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Restoring old<span class="built_in"> default </span>virtualhost] *********************</span><br><span class="line">skipping: [host1]</span><br><span class="line">skipping: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Removing out virtualhost] *********************</span><br><span class="line">skipping: [host1]</span><br><span class="line">skipping: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Ending playbook] *********************</span><br><span class="line">skipping: [host1]</span><br><span class="line">skipping: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Deploy our awesome application] *********************</span><br><span class="line">ok: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Deactivates the<span class="built_in"> default </span>virtualhost] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Deactivates the<span class="built_in"> default </span>ssl virtualhost] *********************</span><br><span class="line">changed: [host2]</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">NOTIFIED: [restart apache] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">PLAY RECAP *********************</span><br><span class="line">host1              : <span class="attribute">ok</span>=10   <span class="attribute">changed</span>=5    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br><span class="line">host2              : <span class="attribute">ok</span>=10   <span class="attribute">changed</span>=8    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br></pre></td></tr></table></figure>
<p>我们所要做的就是从命令行中移除 <code>-l host1</code>。 记住 <code>-l</code> 是一个参数，它限制了 playbook 在特定主机上运行。 现在我们不再限制，它将运行在所有的主机上，在这些主机上的剧本打算运行(即 web组)。</p>
<p>如果我们在 group <code>web</code> 中有其他服务器，但是希望将 playbook 限制为一个子集，我们可以使用，例如:<code>-l firstthost: secondhost:...</code></p>
<p>现在我们已经有了这个不错的 web 服务器组，让我们通过在 <code>step-10</code> 中在它们前面放置一个负载均衡器，将它变成为一个集群。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>自言自语</title>
    <url>/2019/04/27/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/</url>
    <content><![CDATA[<p>从没想过一个懒得出奇又不会表达的人竟然会开始想写一些东西</p>
<p>真不知说什么好，那既然开始了，就好好坚持下去吧 -。-</p>
]]></content>
      <categories>
        <category>开始</category>
      </categories>
  </entry>
  <entry>
    <title>被停滞的时间</title>
    <url>/2019/05/15/%E8%A2%AB%E5%81%9C%E6%BB%9E%E7%9A%84%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h5 id="最近不知怎的，看书看不进去，对周遭的一切都感到陌生盲从，就像一具没有灵魂的躯壳，时间仿佛停滞在了过去"><a href="#最近不知怎的，看书看不进去，对周遭的一切都感到陌生盲从，就像一具没有灵魂的躯壳，时间仿佛停滞在了过去" class="headerlink" title="最近不知怎的，看书看不进去，对周遭的一切都感到陌生盲从，就像一具没有灵魂的躯壳，时间仿佛停滞在了过去"></a>最近不知怎的，看书看不进去，对周遭的一切都感到陌生盲从，就像一具没有灵魂的躯壳，时间仿佛停滞在了过去</h5><blockquote>
<p>明天该怎么过呢，日子会不会因此走慢点</p>
<p>我跟你一样有血有肉的人</p>
<p>请别再说出敷衍的话</p>
<p>我跟你一样有血有肉的人</p>
<p>请别再说出敷衍的话</p>
<p>跑吧离开我吧</p>
<p>享受这过程我只感到沮丧</p>
<p>走吧跟我走吧</p>
<p>我带你去我最爱的地方</p>
<p>一个与我格格不入的地方</p>
<p>和那与我格格不入的你 </p>
<blockquote>
<p>deca joins —— <a href="https://music.163.com/#/song?from=timeline&amp;id=483378330&amp;userid=304234053" target="_blank" rel="noopener">《巫堵》</a></p>
</blockquote>
</blockquote>
<hr>
<p>反思自己，对于很多事，拖延和逃避就好似成了我的万金油，而对于真正的问题却毫无裨益</p>
<p><em>有时候想啊到底为了什么而活啊，每日看着身边的人嬉笑无常真的感到非常困惑，日复一日，荒废的到底都是些什么</em></p>
<p><em>习惯性的失去面对生活的勇气，明明是很平常的事却脆弱得想哭</em></p>
<p><strong>为什么要习惯失望啊？可能大多期望太高的它最先坠落吧</strong></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>💁🏻‍♂️</title>
    <url>/2020/08/02/%F0%9F%92%81%F0%9F%8F%BB%E2%80%8D%E2%99%82%EF%B8%8F/</url>
    <content><![CDATA[<p>时间过得真快啊,一下子就快实习了两个月了,虽然这也不是什么断更的理由</p>
<p>那么就接下来继续努力吧</p>
<p><img src="/images/990672b3e82963502a597c34e55546b5.gif" alt></p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译: ansible-tuto（10-11) </title>
    <url>/2020/05/17/%E7%BF%BB%E8%AF%91-ansible-tuto%EF%BC%8810-11%EF%BC%89/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="step-10-模板"><a href="#step-10-模板" class="headerlink" title="step-10 模板"></a>step-10 模板</h1><p>我们将使用 <code>haproxy</code> 作为负载平衡器。 当然，安装就像我们对 apache 所做的一样。 但是现在的配置有点复杂，因为我们需要在 haproxy 的配置中列出所有的 web 服务器。 我们怎么才能做到呢？</p>
<h3 id="HAProxy-配置template（模板"><a href="#HAProxy-配置template（模板" class="headerlink" title="HAProxy 配置template（模板)"></a>HAProxy 配置template（模板)</h3><p>Ansible 使用了 <a href="https://jinja.palletsprojects.com/en/2.11.x/" target="_blank" rel="noopener">Jinja2</a>, Python 的 一个模板引擎。 当您编写 Jinja2模板时，您可以使用 Ansible 定义的任何变量。</p>
<p>例如，如果您想输出模板当前生成的主机的库存名称，只需在 <code>jinja</code> 模板中写入 `&#123; inventory hostname &#125; </p>
<p>或者如果你需要第一个以太网接口的 IP 地址(多亏了 <code>setup</code> 模块，所以ansible 才知道) ，你只需要写:  &#123;&#123; ansible_default_ipv4.address &#125;&#125; (相当于  &#123;&#123; ansible_default_ipv4[‘address’] &#125;&#125; )</p>
<p>Jinja2模板还支持条件、 for-loop 等。</p>
<p>让我们创建一个 <code>templates/</code> 目录并在其中创建一个 jinja 模板。 我们称之为<code>haproxy.cfg.j2</code>。 我们使用 <code>.j2</code> 扩展名，以显示这是一个 Jinja2模板，但这是不必要的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    daemon</span><br><span class="line">    maxconn <span class="number">256</span></span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    mode http</span><br><span class="line">    timeout connect <span class="number">5000</span>ms</span><br><span class="line">    timeout client <span class="number">50000</span>ms</span><br><span class="line">    timeout server <span class="number">50000</span>ms</span><br><span class="line"></span><br><span class="line">listen cluster</span><br><span class="line">    bind  &amp;#<span class="number">123</span>; &amp;#<span class="number">123</span>; ansible_host &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>;<span class="number">80</span></span><br><span class="line">    mode http</span><br><span class="line">    stats enable</span><br><span class="line">    balance roundrobin</span><br><span class="line"></span><br><span class="line">&amp;#<span class="number">123</span>;% <span class="keyword">for</span> backend <span class="keyword">in</span> groups[<span class="string">'web'</span>] %&amp;#<span class="number">125</span>;    server  &amp;#<span class="number">123</span>;&amp;#<span class="number">123</span>; hostvars[backend][<span class="string">'ansible_hostname'</span>] &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>; &amp;#<span class="number">123</span>;&amp;#<span class="number">123</span>; hostvars[backend].ansible_host &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>;check port <span class="number">80</span></span><br><span class="line">&amp;#<span class="number">123</span>;% endfor %&amp;#<span class="number">125</span>;    option httpchk HEAD /index.php HTTP/<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PS： 以上的<code>&amp;#123;</code>为<code>{</code>,<code>&amp;#125;</code>为<code>}</code>，均为markdown语法，这是因为 “&#123;&#123;  &#125;&#125;” 为当前博客模板所使用到的语法，不转义会发生错误</li>
</ul>
<p>我们这里有很多新奇事物</p>
<p>首先，” &#123;&#123; ansible host &#125;&#125;” 将被服务器的第二个 IP 替换，这个 IP 恰好是192.168.33.10。</p>
<p>然后，我们有一个循环。 此循环用于构建后端服务器列表。 它将循环遍历 <code>[web]组</code> 中列出的每个主机(并将此主机放入后端变量中)。 对于每个主机，它将使用主机的<code>facts</code> 呈现一行。 所有主机的 <code>facts</code> 都在 <code>hostvars</code> 变量中被设置，因此很容易访问其他主机变量(比如它的主机名或在本例中的 IP)。</p>
<p>我们可以用手写主机列表，因为我们只有两个主机。 但是我们希望这个服务器集群规模能够非常大，我们需要一百个这样的服务器。 因此，向配置中添加服务器或者交换一些服务器可以归结为从 <code>[web]</code> 组中添加或删除主机。</p>
<h3 id="Haproxy-的剧本"><a href="#Haproxy-的剧本" class="headerlink" title="Haproxy 的剧本"></a>Haproxy 的剧本</h3><p>我们已经完成了这项工作中最困难的部分，编写一个安装和配置 HAproxy 的剧本是一件轻而易举的事情:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Installs</span> <span class="string">haproxy</span> <span class="string">load</span> <span class="string">balancer</span></span><br><span class="line"><span class="attr">      apt:</span></span><br><span class="line"><span class="attr">        pkg:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">        update_cache:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Pushes</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        src:</span> <span class="string">templates/haproxy.cfg.j2</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/etc/haproxy/haproxy.cfg</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0640</span></span><br><span class="line"><span class="attr">        owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">        group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      notify:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">restart</span> <span class="string">haproxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Sets</span> <span class="string">default</span> <span class="string">starting</span> <span class="string">flag</span> <span class="string">to</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/etc/default/haproxy</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">"^ENABLED"</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">"ENABLED=1"</span></span><br><span class="line"><span class="attr">      notify:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">restart</span> <span class="string">haproxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">restart</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">      service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure>
<p>看起来很眼熟，是吧？ 这里唯一的新模块是 <code>template</code>，它具有与 <code>copy</code> 相同的参数。 我们还将这个剧本限制在 <code>group haproxy</code></p>
<p>现在… 让我们试试这个。 因为我们的库存只包含集群所需的主机，所以我们不需要限制主机列表，甚至可以同时运行两个剧本。 好吧，说实话，我们必须同时运行这两个服务器，因为 haproxy playbook 需要两个 web 服务器提供 <code>facts</code> 在步骤11中，我们将展示如何避免这种情况。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i step-10/hosts step-10/apache.yml step-10/haproxy.yml</span><br><span class="line"></span><br><span class="line">PLAY [web] *********************</span><br><span class="line"></span><br><span class="line">GATHERING FACTS *********************</span><br><span class="line">ok: [host1]</span><br><span class="line">ok: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Updates apt cache] *********************</span><br><span class="line">ok: [host1]</span><br><span class="line">ok: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Installs necessary packages] *********************</span><br><span class="line">ok: [host1] =&gt; (<span class="attribute">item</span>=apache2,libapache2-mod-php,git)</span><br><span class="line">ok: [host2] =&gt; (<span class="attribute">item</span>=apache2,libapache2-mod-php,git)</span><br><span class="line"></span><br><span class="line">TASK: [Push future<span class="built_in"> default </span>virtual host configuration] *********************</span><br><span class="line">ok: [host2]</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Activates our virtualhost] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Check that our<span class="built_in"> config </span>is valid] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Restoring old<span class="built_in"> default </span>virtualhost] *********************</span><br><span class="line">skipping: [host1]</span><br><span class="line">skipping: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Removing out virtualhost] *********************</span><br><span class="line">skipping: [host1]</span><br><span class="line">skipping: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Rolling back - Ending playbook] *********************</span><br><span class="line">skipping: [host1]</span><br><span class="line">skipping: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Deploy our awesome application] *********************</span><br><span class="line">ok: [host2]</span><br><span class="line">ok: [host1]</span><br><span class="line"></span><br><span class="line">TASK: [Deactivates the<span class="built_in"> default </span>virtualhost] *********************</span><br><span class="line">changed: [host1]</span><br><span class="line">changed: [host2]</span><br><span class="line"></span><br><span class="line">TASK: [Deactivates the<span class="built_in"> default </span>ssl virtualhost] *********************</span><br><span class="line">changed: [host2]</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">NOTIFIED: [restart apache] *********************</span><br><span class="line">changed: [host2]</span><br><span class="line">changed: [host1]</span><br><span class="line"></span><br><span class="line">PLAY RECAP *********************</span><br><span class="line">host1              : <span class="attribute">ok</span>=10   <span class="attribute">changed</span>=5    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br><span class="line">host2              : <span class="attribute">ok</span>=10   <span class="attribute">changed</span>=5    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PLAY [haproxy] *********************</span><br><span class="line"></span><br><span class="line">GATHERING FACTS *********************</span><br><span class="line">ok: [host0]</span><br><span class="line"></span><br><span class="line">TASK: [Installs haproxy load balancer] *********************</span><br><span class="line">changed: [host0]</span><br><span class="line"></span><br><span class="line">TASK: [Pushes configuration] *********************</span><br><span class="line">changed: [host0]</span><br><span class="line"></span><br><span class="line">TASK: [Sets<span class="built_in"> default </span>starting flag <span class="keyword">to</span> 1] *********************</span><br><span class="line">changed: [host0]</span><br><span class="line"></span><br><span class="line">NOTIFIED: [restart haproxy] *********************</span><br><span class="line">changed: [host0]</span><br><span class="line"></span><br><span class="line">PLAY RECAP *********************</span><br><span class="line">host0              : <span class="attribute">ok</span>=5    <span class="attribute">changed</span>=4    <span class="attribute">unreachable</span>=0    <span class="attribute">failed</span>=0</span><br></pre></td></tr></table></figure>
<p>看起来不错，现在去 <a href="http://192.168.33.10/" target="_blank" rel="noopener">http://192.168.33.10/</a> 看看结果，你的集群已经部署好了！</p>
<p>你甚至可以在 <a href="http://192.168.33.10/HAProxy?stats" target="_blank" rel="noopener">http://192.168.33.10/HAProxy?stats</a> 看到 HAProxy 的统计数据</p>
<p>现在进入 <code>step-11</code> 中关于“变量”的下一章。</p>
<h1 id="step-11-再次探索变量"><a href="#step-11-再次探索变量" class="headerlink" title="step-11 再次探索变量"></a>step-11 再次探索变量</h1><p>因此，我们已经设置了负载均衡器，它工作得非常好。 我们从 <code>facts</code> 中获取变量并使用它们来构建配置。 但是 Ansible 也支持其他类型的变量。 我们已经在库存中见过了 <code>ansible_host</code> ，但是现在我们将使用定义在在 <code>host_vars</code> 和 <code>group_vars</code> 文件中的变量。</p>
<h3 id="微调我们的-HAProxy-配置"><a href="#微调我们的-HAProxy-配置" class="headerlink" title="微调我们的 HAProxy 配置"></a>微调我们的 HAProxy 配置</h3><p>Haproxy 通常检查后端是否是活动的。 当一个后端看起来死了，它就会从后端池中删除，且 HAproxy 不再向它发送请求。</p>
<p>后端还可以有不同的权重(在0到256之间)。 权重越高，与其他后端相比，后端将接收的连接数量越多。 如果节点的能力不够强大，那么更好地传播流量是很有用的。</p>
<p>我们将使用变量来配置所有这些参数。</p>
<h3 id="Group-vars"><a href="#Group-vars" class="headerlink" title="Group vars"></a>Group vars</h3><p>Check interval 将在 haproxy 的 <code>group_vars</code> 文件中设置。 这将确保所有的 <code>haproxy</code> 将继承它。</p>
<p>我们只需要在库存目录下创建文件 <code>groups_vars/haproxy.yml</code>。 文件必须要以为其定义变量的组命名。 如果我们想为 web 组定义变量，那么这个文件应该命名为 <code>group _vars/web.xml</code></p>
<p><strong>请注意</strong>。 <code>.yml</code> 是可选的: 我们可以将 haproxy 的组变量文件命名为 <code>groups_vars/haproxy</code> 。这个扩展名只是帮助编辑器选择正确的语法使其高亮。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">haproxy_check_interval:</span> <span class="number">3000</span></span><br><span class="line"><span class="symbol">haproxy_stats_socket:</span> <span class="meta-keyword">/tmp/</span>sock</span><br></pre></td></tr></table></figure>
<p>这个名字是随意的。 当然，建议使用有意义的名称，这里没有什么必要的语法。 你甚至可以像这样使用 <code>complex variables</code>(也就是 Python dict) :</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">haproxy:</span></span><br><span class="line"><span class="symbol">    check_interval:</span> <span class="number">3000</span></span><br><span class="line"><span class="symbol">    stats_socket:</span> <span class="meta-keyword">/tmp/</span>sock</span><br></pre></td></tr></table></figure>
<p>这只是品味问题。 <code>complex variables</code> 可以更加有逻辑地分组东西。 在某些情况下，它们还可以合并随后定义的键(但是请注意，这不是默认的可合并行为)。 现在我们只使用简单的变量。</p>
<h3 id="Hosts-vars"><a href="#Hosts-vars" class="headerlink" title="Hosts vars"></a>Hosts vars</h3><p><code>Hosts vars</code> 遵循完全相同的规则，但是文件存储在 <code>host_vars</code> 目录下</p>
<p>让我们在 <code>hosts_vars/host1.example.com</code> 中定义后端的权重:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">haproxy_backend_weight: <span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>以及 <code>host_vars/host2.example.com</code>:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">haproxy_backend_weight: <span class="number">150</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们在 <code>group_vars/web</code> 中定义 haproxy 后端权重，它将被用作“缺省” : 在 <code>host_vars</code> 文件中定义的变量将覆盖 <code>group_vars</code> 中定义的变量。</p>
<h3 id="更新模板"><a href="#更新模板" class="headerlink" title="更新模板"></a>更新模板</h3><p>必须更新模板以使用这些变量。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    daemon</span><br><span class="line">    maxconn <span class="number">256</span></span><br><span class="line">&amp;#<span class="number">123</span>;% <span class="keyword">if</span> haproxy_stats_socket %&amp;#<span class="number">125</span>;    stats socket  &amp;#<span class="number">123</span>; &amp;#<span class="number">123</span>; haproxy_stats_socket &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>;&amp;#<span class="number">123</span>;% endif %&amp;#<span class="number">125</span>;</span><br><span class="line">defaults</span><br><span class="line">    mode http</span><br><span class="line">    timeout connect <span class="number">5000</span>ms</span><br><span class="line">    timeout client <span class="number">50000</span>ms</span><br><span class="line">    timeout server <span class="number">50000</span>ms</span><br><span class="line"></span><br><span class="line">listen cluster</span><br><span class="line">    bind  &amp;#<span class="number">123</span>; &amp;#<span class="number">123</span>; ansible_all_ipv4_addresses<span class="number">.1</span> &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>;<span class="number">80</span></span><br><span class="line">    mode http</span><br><span class="line">    stats enable</span><br><span class="line">    balance roundrobin</span><br><span class="line">&amp;#<span class="number">123</span>;% <span class="keyword">for</span> backend <span class="keyword">in</span> groups[<span class="string">'web'</span>] %&amp;#<span class="number">125</span>;    server  &amp;#<span class="number">123</span>; &amp;#<span class="number">123</span>; hostvars[backend][<span class="string">'ansible_hostname'</span>] &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>; &amp;#<span class="number">123</span>; &amp;#<span class="number">123</span>; hostvars[backend].ansible_all_ipv4_addresses<span class="number">.1</span> &amp;#<span class="number">125</span>;&amp;#<span class="number">125</span>;check port <span class="number">80</span></span><br><span class="line">&amp;#<span class="number">123</span>;% endfor %&amp;#<span class="number">125</span>;    option httpchk HEAD /index.php HTTP/<span class="number">1.0</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>，我们还引入了<code>&amp;#123;% if...</code> 。 只有在测试为真时，才会使用这个封闭的块。 因此，如果我们在某个地方为负载均衡器定义了 <code>haproxy_stats_socket</code> (我们甚至可以在命令行中使用 <code>--extra-vars“ haproxy_stats_sockets /tmp/sock”</code>) ，那么封闭其中的配置行将出现在生成的配置文件中(注意，建议的设置非常不安全!) </p>
<p>让我们试试看</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i step<span class="number">-11</span>/hosts step<span class="number">-11</span>/haproxy.yml</span><br></pre></td></tr></table></figure>
<p>请注意，虽然我们可以，但是没有必要运行 apache 的剧本，因为什么都没有改变，但是我们不得不为此作弊。 以下是最新的 haproxy 剧本:<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Installs</span> <span class="string">haproxy</span> <span class="string">load</span> <span class="string">balancer</span></span><br><span class="line"><span class="attr">      apt:</span></span><br><span class="line"><span class="attr">        pkg:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">        update_cache:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Pushes</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        src:</span> <span class="string">templates/haproxy.cfg.j2</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/etc/haproxy/haproxy.cfg</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0640</span></span><br><span class="line"><span class="attr">        owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">        group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      notify:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">restart</span> <span class="string">haproxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Sets</span> <span class="string">default</span> <span class="string">starting</span> <span class="string">flag</span> <span class="string">to</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/etc/default/haproxy</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">"^ENABLED"</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">"ENABLED=1"</span></span><br><span class="line"><span class="attr">      notify:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">restart</span> <span class="string">haproxy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">restart</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">      service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure></p>
<p>看到了吗？ 我们在顶部为 web 主机添加了一个空的剧本。 它除了收集 <code>facts</code> 以外什么也不做。 但是它必须在这里，因为它将触发 <code>facts</code> 收集在主机上的群组网络。 这是必要的，因为 haproxy playbook 需要从这个组的主机中选择 <code>facts</code> 。 如果我们不这样做，ansible 可能会抱怨说 <code>ansible_all_ipv4_addresses</code>都不存在</p>
<p>请注意，我们已经在前面的步骤中提到了这一点，但是我们没有提到它。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>翻译</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象方法学习</title>
    <url>/2019/10/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h1><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
<p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。当前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。</p>
<p>面向对象的三大特性：<br>1、封装<br>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。<br>2、继承<br>提高代码复用性；继承是多态的前提。<br>3、多态<br>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<hr>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">统一建模语言</a>（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。</p>
</blockquote>
<p><img src="/images/20191008=0.png" alt></p>
<ul>
<li>- 表示私有</li>
<li>+ 表示公用</li>
</ul>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><blockquote>
<p>表现层状态转换（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。</p>
</blockquote>
<ul>
<li><p>对于url进行资源的暴露，而不进行任何操作 </p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/<span class="built_in">rest</span>/api/dogs</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于HTTP动词</p>
</li>
</ul>
<p>在REST系统中我们使用4个基本HTTP动词来与资源进行交互：<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">- 检索特定资源（通过id）或资源集合</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">- 创建一个新资源</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">- 更新特定资源（通过ID）</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">- 按ID删除特定资源</span></span><br></pre></td></tr></table></figure></p>
<p>简单对比</p>
<blockquote>
</blockquote>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/myweb/</span>getDogs --&gt; GET <span class="meta-keyword">/rest/</span>api/dogs 获取所有小狗狗 </span><br><span class="line"><span class="meta-keyword">/myweb/</span>addDogs --&gt; POST <span class="meta-keyword">/rest/</span>api/dogs 添加一个小狗狗 </span><br><span class="line"><span class="meta-keyword">/myweb/</span>updateDogs/:dog_id --&gt; PUT <span class="meta-keyword">/rest/</span>api<span class="meta-keyword">/dogs/</span>:dog_id 修改一个小狗狗 </span><br><span class="line"><span class="meta-keyword">/myweb/</span>deleteDogs/:dog_id --&gt; DELETE <span class="meta-keyword">/rest/</span>api<span class="meta-keyword">/dogs/</span>:dog_id 删除一个小狗狗</span><br></pre></td></tr></table></figure>
<ul>
<li>补充<br><a href="https://www.jianshu.com/p/c5c83872dad2" target="_blank" rel="noopener">1</a> <a href="https://blog.csdn.net/qq_21383435/article/details/80032375" target="_blank" rel="noopener">2</a> <a href="https://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="noopener">3</a></li>
</ul>
]]></content>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>零碎知识收集(1) </title>
    <url>/2019/06/13/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p><img src="/images/20190613=2.png" alt="世界加钱可及？"><br><a id="more"></a></p>
<ul>
<li>地球周长：40076千米 (赤道)</li>
<li>光速 光在真空中的速率是299,792,458米/秒，约3×10ˆ5千米/秒，是已知的速度上限</li>
<li>BGP (边界网关协议) 是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。 BGP 构建在 EGP 的经验之上。 BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了 AS 互联的拓朴图并由此清除了路由环路，同时在 AS 级别上可实施策略决策。</li>
<li>BGP机房 采用BGP方案来实现双线路互联或多线路互联的机房，常用于线路加速</li>
<li>互联网数据中心（Internet Data Center）简称IDC</li>
</ul>
<h3 id="中国四大骨干网"><a href="#中国四大骨干网" class="headerlink" title="中国四大骨干网"></a>中国四大骨干网</h3><blockquote>
<p>CHINANET外，CERNET，CSTNET，CHINAGBN，合起来称为中国四大骨干网。<br>①中国公用计算机互联网（CHINANET）<br>又称邮电部互联网、中国公用Internet网，是邮电部经营管理的基于Internet网络技术的电子信息网，1995年初与国际互联网连通，并于5月向社会提供服务。CHINANET由骨干网、接入网组成，骨干网是其主要信息通路，由直辖市和各省会城市的网络节点构成；接入网是各省（区）建设的网络接点形成的网络。CHINANET的灵活接入方式和遍布全国各城市的接入点，可以方便地接入国际Internet, 享用Internet上的丰富信息资源和各种服务，并可为国内的计算机互联，为国内的信息资源共享提供方便的网络环境。<br>②中国教育与科研网（CERNET）<br>1994年启动，1995年底完成首期工程，包括北京（网络中心）、上海、南京、广州、武汉、西安、成都和沈阳等高等学校集中的大城市。有连接美国的国际专线。全国主干网（共11条64Kbps DDN专线）于1995年10月开通。二期工程完成后，全国主干网和国际联网的逐步升级，主干网达到2Kbps以上，国际联网达到8Kbps以上。<br>③中国科学技术网（CSTNET）<br>由中国科学院主持，联合清华、北大共同建设。1994年4月开通了与Internet的专线连接。1994年5月21日完成了我国最高域名CN主服务器的设置，实现了与Internet的TCP/IP连接。1995年底基本完成“百所联网”工程。至1997年底，已连接100多个以太网、3000多台计算机、1万多名用户，成为中国地域广、用量大、性能好、通信量大、服务设施齐全的全国性科研教育网络。<br>④中国金桥信息网（CHINAGBN）<br>即国家公用经济信息通信网，由原电子工业部管理，面向政府、企业、事业单位和社会公众提供数据通信和信息服务。金桥网年底与Internet连通，已开通24个城市，发展了1000多个本地和远程仿真终端，提供全面的Internet服务。</p>
<blockquote>
<p><a href="https://www.idcbest.com/idcnews/11002480.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</blockquote>
<h3 id="CN2-中国电信下一代承载网（ChinaNetNextCarryingNetwork）"><a href="#CN2-中国电信下一代承载网（ChinaNetNextCarryingNetwork）" class="headerlink" title="CN2 中国电信下一代承载网（ChinaNetNextCarryingNetwork）"></a>CN2 中国电信下一代承载网（ChinaNetNextCarryingNetwork）</h3><p>  Chinanet 又被称为163网<br>其区别</p>
<ul>
<li><p>CN2 其路由多为59.43.<em>.</em><br><img src="/images/20190613=0.png" alt="图"></p>
</li>
<li><p>chinanet 其路由多为202.97.<em>.</em><br><img src="/images/20190613=1.png" alt="图"></p>
</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmd</span><span class="bash"> &gt; tracert *</span></span><br></pre></td></tr></table></figure>
<h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">traceroute</span> *</span><br></pre></td></tr></table></figure>
<h5 id="web"><a href="#web" class="headerlink" title="web"></a>web</h5><p><a href="https://ipms.chinatelecomglobal.com/public/lookglass/lookglassDisclaimer.html?lang=zh_CN" target="_blank" rel="noopener">其在线测试网址</a></p>
<h3 id="CERNET2"><a href="#CERNET2" class="headerlink" title="CERNET2"></a>CERNET2</h3><p>第二代中国教育和科研计算机网CERNET2是中国下一代互联网示范工程CNGI最大的核心网和唯一的全国性学术网，是目前所知世界上规模最大的采用纯IPv6技术的下一代互联网主干网。</p>
<p><a href="http://www.edu.cn/include/cernet/ipv6/ipv6.htm" target="_blank" rel="noopener">中国教育和科研计算机网</a></p>
<p><del>最近马上在看ipv6相关书籍，下篇再写</del></p>
<hr>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
